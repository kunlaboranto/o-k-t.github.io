<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] Oracle 8 - Situation - 유형별 대응 사례??</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2007-06-19 04:43:26</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] Oracle 8 - Situation - 유형별 대응 사례??</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">From : <a href="http://database.sarang.net/?inc=read&amp;aid=8862&amp;criteria=oracle&amp;subcrit=&amp;id=112&amp;limit=20&amp;keyword=v%24statement&amp;page=29">http://database.sarang.net/?inc=read&amp;aid=8862&amp;criteria=oracle&amp;subcrit=&amp;id=112&amp;limit=20&amp;keyword=v%24statement&amp;page=29</a><br><br><table class="infotable" style="TEXT-ALIGN: left" cellspacing="0" cellpadding="3" border="0"><tbody><tr><td class="rowtitle" colspan="6">Oracle 8 - Situation</td></tr><tr><th class="infotable_th"><div style="WHITE-SPACE: nowrap">작성자</div></th><td class="rowmisc"><div style="WHITE-SPACE: nowrap">정재익(advance)</div></td><th class="infotable_th"><div style="WHITE-SPACE: nowrap">작성일</div></th><td class="rowmisc"><div style="WHITE-SPACE: nowrap">2001-12-12 23:37:24</div></td><th class="infotable_th"><div style="WHITE-SPACE: nowrap">조회수</div></th><td class="rowmisc" align="right"><div style="WHITE-SPACE: nowrap">1,460</div></td></tr></tbody></table><table class="viewtable" style="TEXT-ALIGN: left"><tbody><tr><td class="rowbody"><p><b><span style="COLOR: #008000">01. Tablespace의 조작</span></b></p><p>&nbsp;</p><pre>[b]1. 새로운 Tablespace Create[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startupSVRMGR&gt; create tablespace test     2  datafile '$HOME/DATA/DISK5/test_01.dbf'     3  size 10k ;SVRMGR&gt; select tablespace_name, bytes, file_name from dba_data_files ;[b]2. Table Create 후 table 에 row들을 insert[/b]$ sqlplus scott/tigerSQL&gt; create table test  2  (name varchar2(10))  3  storage (initial 4k)  4  tablespace test ;SQL&gt; insert into test values ('TEST') ;SQL&gt; insert into test select * from test ;SQL&gt; /   &lt;-- 아래의 error 메세지가 나올 때까지 여러번 반복한다.ORA-01653: unable to extend table SCOTT.TEST by 5 in tablespace TEST[b]3. Tablespace를 늘린다.[/b]SQL&gt; connect system/managerSQL&gt; alter tablespace test add datafile '$HOME/DATA/DISK6/test02_dbf' size 30k ;SQL&gt; select tablespace_name, bytes, file_name from dba_data_files ;SQL&gt; connect scott/tigerSQL&gt; insert into test select * form test ;또는 다음의 방법으로 datafile을 resize한다.SQL&gt; connect system/managerSQL&gt; alter database datafile '$HOME/DATA/DISK5/test_01.dbf' resize 50k ;SQL&gt; select tablespace_name, bytes, file_name from dba_data_files ;SQL&gt; !ls -la $HOME/DATA/DISK5SQL&gt; connect scott/tigerSQL&gt; insert into test select * from test ;SQL&gt; commit ;[b]4. 테스트가 끝나면 Drop[/b]SQL&gt; connect system/managerSQL&gt; drop tablespace test including contents ;SQL&gt; select tablespace_name, bytes, file_name from dba_data_files ;SQL&gt; !ls -la $HOME/DATA/DISK5SQL&gt; !ls -la $HOME/DATA/DISK6     --&gt; datafile이 그대로 존재한다. (reuse하기 위해서--다시 datafile을 만들때 속도가 빠르다.)     [b]5. Datafile도 삭제[/b]SQL&gt; !rm $HOME/DATA/DISK5/test_01.dbfSQL&gt; !rm $HOME/DATA/DISK6/test_02.dbfSQL&gt; !ls -la $HOME/DATA/DISK5SQL&gt; !ls -la $HOME/DATA/DISK6$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; shutdown immediateSVRMGR&gt; exit</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">02. Recovery-Temporary Tablespace의 유실</span></b></p><p>&nbsp;</p><pre> [b]1. Database를 기동[/b]$svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startupSVRMGR&gt; select tablespace_name, file_name from dba_datafiles ;        --&gt; Temporary Tablespace의 Data File 경로명을 확인SVRMGR&gt; !ls -la $HOME/DATA/DISK3/temp01.dbf        --&gt; 크기 확인        [b]2. Failure를 만든다.[/b]SVRMGR&gt; shutdown abort        --&gt; Failure를 상상SVRMGR&gt; ! mv $HOME/DATA/DISK3/temp01.dbf $HOME/DATA/DISK3/temp01.orgSVRMGR&gt; startupORA-01157: cannot identify data file 4 - file not foundORA-01110: data file 4:'/home/disk1/userDBA205/DATA/DISK3/temp01.dbf'[b]3. Recovery 수행[/b]   --&gt; Temporary Tablespace 이므로  Drop하고 새로 만들면 됨   SVRMGR&gt; alter database datafile '$HOME/DATA/DISk3/temp01.dbf' offline drop ;SVRMGR&gt; alter database open ;<span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span> processed.SVRMGR&gt; select * from dba_tablespaces ;        --&gt; "Temp_data" Tablespace는 그래도 존재함        --&gt; "Temp_data" Tablespace의 구성 File 중 하나를 Drop 한 것 뿐이니까.(여기선 우연히 하나였다.)SVRMGR&gt; drop tablespace temp_data including contents ;SVRMGR&gt; create tablespace temp_data     2  datafile '$HOME/DATA/DISK3/temp01.dbf' size 1M ;        --&gt; 앞에서 확인한 크기로 다시 생성SVRMGR&gt; shutdown immediate        --&gt; Shutdown 과 Startup을 해봐서 잘 되는지 확인SVRMGR&gt; startupSVRMGR&gt; shutdown immediateSVRMGR&gt; !rm $HOME/DATA/DISK3/temp01.org        --&gt; 필요 없는 file을 삭제SVRMGR&gt; exit</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">03. 데이터베이스 모드의 변환</span></b></p><p>&nbsp;</p><pre>[b][color=BLUE]DB mode의 변환[/color][/b] [b]1. database를 기동 시킨 후 database의 mode 를 확인[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startupSVRMGR&gt; archive log listSVRMGR&gt; select name, log_mode from v$database ;[b]2. archive와 관련된 parameter값 확인[/b]SVRMGR&gt; show parameter archive[b]3. database의 mode를 archivelog mode로 전환[/b]SVRMGR&gt; shutdown immediate$vi $ORACLE_HOME/dbs/initSID.ora    LOG_ARCHIVE_START=TRUE    LOG_ARCHIVE_DEST=$HOME/ARCHIVE/    LOG_ARCHIVE_FORMAT=arch_%s.arc    SVRMGR&gt; startup mountSVRMGR&gt; alter database archivelog ;SVRMGR&gt; alter database open ;SVRMGR&gt; alter system switch logfile ;SVRMGR&gt; show parameter archiveSVRMGR&gt; !ls -al $HOME/ARCHIVE[b][color=BLUE]Advanced Practice[/color][/b][b]1. automatic archiving 을 중단하고, log switch를 발생[/b]SVRMGR&gt; alter system archive log stop ;SVRMGR&gt; alter system switch logfile ;SVRMGR&gt; alter system switch logfile ;SVRMGR&gt; alter system switch logfile ;어떤 현상이 발생하는가? database가 운용되지 않고 hang되는 현상이 발생!!!왜 그런 현상이 발생했을까?[b]2. Server manager session을 하나 더 열어서 automatic archiving을 활성화하라.[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; alter system archive log start ;</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">04. Closed Database Backup 수행</span></b></p><p>&nbsp;</p><pre>[b]1. 현재 사용중인 database를 구성하고 있는 files(즉 backup의 대상이 되는 files)을 확인[/b]- Control File의 정보를 확인(V$CONTROLFILE, V$PARAMETER, init<sid>.ora, SHOW PARAMETER command)  SVRMGR&gt; select name from v$controlfile ;  - Log File 정보를 확인(V$LOGFILE)  SVRMGR&gt; select member from v$logfile ;  - Data File 정보를 확인(DBA_DATA_FIlES, V$DATAFILE)  SVRMGR&gt; select name from v$datafile ;  [b]2. database를 shutdown 시킨 후 backup을 수행(만일의 경우를 대비하여 DONTOUCH와 BACKUP 디렉토리에 각각 copy)[/b]SVRMGR&gt; shutdown immediate$ cp -rp $HOME/DATA/* $HOME/DONTOUCH$ cp $ORACLE_HOME/dbs/orapwSID $HOME/DONTOUCH$ cp $ORACLE_HOME/dbs/initSID.ora $HOME/DONTOUCH$ cp -rp $HOME/DATA/* $HOME/BACKUP$ cp $ORACLE_HOME/dbs/orapwSID $HOME/BACKUP$ cp $ORACLE_HOME/dbs/initSID.ora $HOME/BACKUP[b]3. Instance를 기동 후, system을 정상적으로 운용[/b]SVRMGR&gt; startup$ sqlplus scott/tigerSQL&gt; @ empdata.sqlSQL&gt; @ deptdata.sql[b]4. USER_DATA tablespace의 open backup 수행[/b]SQL&gt; connect system/managerSQL&gt; alter tablespace user_data begin backup ;SQL&gt; ! cp $HOME/DATA/DISK2/user01.dbf $HOME/BACKUP/user01.bkpSQL&gt; alter tablespace user_data end backup ;[b]5. controlfile의 backup 수행[/b]SQL&gt; alter database backup controlfile to trace ;SQL&gt; @ spid.sql  --&gt; process의 번호를 확인SQL&gt; !$ cp $HOME/TRACE$ cp dba???_ora_xxxx.trc $HOME/BACKUP/cntrl1.trc$ vi $HOME/BACKUP/cntrl1.trc  -- comment line을 모두 delete 한다.$ exitSQL&gt; alter database backup controlfile to '$HOME/BACKUP/cntrl1.bkp' ;</sid></pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">05. Norachivelog mode에서의 Complete Database Recovery 수행</span></b></p><p>&nbsp;</p><pre>[b]1. Database 를 Noarchivelog mode로 전환하고, ARCH process를 비활성하자.[/b]$ svrmgrlSVRMGR&gt; connect internalSVRMGR&gt; shutdown immediateSVRMGR&gt; ! vi $HOME/dbs/initSID.ora        --&gt; log_archive_start를 comment 처리 또는 false로 settingSVRMGR&gt; startup mountSVRMGR&gt; alter database noarchivelog ;SVRMGR&gt; alter database open ;SVRMGR&gt; archive log list [b]2. Full Closed Database Backup 수행( 이번에는 $HOME/BACKUP directory에만 copy)[/b]SVRMGR&gt; shutdown immediate ;SVRMGR&gt; host$ cp -r $HOME/DATA/* $HOME/BACKUP$ exitSVRMGR&gt; startup[b]3. sqlplus에 scott/tiger로 login해서 다음을 수행[/b]$ sqlplus scott/tigerSQL&gt; @ newemp.sqlSQL&gt; connect system/managerSQL&gt; select f.file_name from dba_tables t, dba_data_files f  2  where table_name='NEWEMP'  3  and t.tablespace_name = f.tablespace_name ;     --&gt; newemp table이 어떤 datafile에 들어 있는지를 확인     --&gt; $HOME/DATA/DISK2/user01.dbf에 newemp table이 속해 있음.     [b]4. failure를 발생시키고, database startup 수행[/b]SQL&gt; show user     --&gt; sys 또는 system user인지 확인한다. 만일 아니라면...         connect system/manager를 수행SQL&gt; @ breakdb.sql$ svrmgrlSVRMGR&gt; connect internal ;SVRMGR&gt; startup     --&gt; $HOME/DATA/DISK2/user01.dbf file이 없으므로 open을 할 수 없고, database는 mount 상태임     [b]5. Recovery 수행 후, database 기동[/b]SVRMGR&gt; connect / as sysdbaSVRMGR&gt; shutdown abort ;SVRMGR&gt; ! cp -r $HOME/BACKUP/D* $HOME/DATASVRMGR&gt; startup[b]6. sqlplus에 scott/tiger로 login 해서 newemp table을 query 해 보라.[/b]$ sqlplus scott/tigerSQL&gt; select * from newemp ;     --&gt; 어떤 결과가 나타나는가? 또, 그 이유는?SVRMGR&gt; shutdown immediate ;</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">06. Noarchive Log Mode Recovery - Disk의 유실</span></b></p><p>&nbsp;</p><p><b>1. failure가 발생되서 모든 file들을 Restore하려는 데, user01.dbf를 원래 위치에 Restore 할 수가 없다. 따라서, 할 수 없이 $HOME/DATA/DISK6에 Restore 한다.</b></p><p>&nbsp;</p><p>$ cd $HOME/DATA/DISK2</p><p>$ ls</p><p>$ rm user01.dbf --&gt; failure 발생!!!</p><p>$ svrmgrl</p><p>SVRMGR&gt; connect / as sysdba</p><p>SVRMGR&gt; startup --&gt; 실패!!!</p><p>SVRMGR&gt; shutdown abort</p><p>SVRMGR&gt; ! cp -r $HOME/BACKUP/D* $HOME/DATA --&gt; 원래 위치로 Restore</p><p>SVRMGR&gt; ! mv $HOME/DATA/DISK2/user01.dbf $HOME/DATA/DISK6</p><p>SVRMGR&gt; startup --&gt; 역시 실패!!!</p><p>SVRMGR&gt; select name from v$datafile ;</p><p>--&gt; Oracle Server는 File이 다른 곳($HOME/DATA/DISK6)에 있다는 것을 인지하지 못함.</p><p>&nbsp;</p><p><b>2. Oracle Server가 인지할 수 있도록 정보를 수정</b></p><p>&nbsp;</p><p>SVRMGR&gt; alter database rename file '$HOME/DATA/DISK2/user01.dbf'</p><p>2 to '$HOME/DATA/DISK6/user01.dbf' ;</p><p>&nbsp;</p><p><b>3. 다시 open 시도</b></p><p>&nbsp;</p><p>SVRMGR&gt; alter database open</p><p>--&gt; 성공 !!!</p><p>SVRMGR&gt; shutdown immediate</p><p>SVRMGR&gt; startup</p><p>&nbsp;</p><p><b>4. 원래 형태로 만들자.</b></p><p>&nbsp;</p><p>SVRMGR&gt; shutdown immediate</p><p>SVRMGR&gt; ! cp -r $HOME/BACKUP/D* $HOME/DATA</p><p>SVRMGR&gt; startup</p><p>SVRMGR&gt; shutdown</p><p>SVRMGR&gt; exit</p><p>[/pre]</p><p>&nbsp;</p><p><b><span style="COLOR: #008000">07. Archivelog moe에서의 Complete Database Recovery 수행</span></b></p><p>&nbsp;</p><pre> [b]1. database의 mode를 확인 후, automatic archiving이 가능하도록 setting 하라.[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startupSVRMGR&gt; select name, log_mode from v$database ;SVRMGR&gt; archive log listSVRMGR&gt; shutdown immediate        --&gt; log_archive_start=TRUE로 settingSVRMGR&gt; startup mountSVRMGR&gt; alter database archivelog ;SVRMGR&gt; alter database open ;SVRMGR&gt; archive log listSVRMGR&gt; show parameter archive[b]2. $HOME/BACKUP 디렉토리에 closed database backup 수행[/b]SVRMGR&gt; shutdown immediateSVRMGR&gt; ! cp -rp $HOME/DATA/* $HOME/BACKUPSVRMGR&gt; startup[b]3. sqlplus에 scott/tiger로 login해서 다음을 수행[/b]$ sqlplus scott/tigerSQL&gt; @ newemp.sqlSQL&gt; connect system/managerSQL&gt; select tablespace_name from dba_tables  2  where table_name='NEWEMP' ;     --&gt; newemp table이 어떤 datafile에 들어 있는지를 확인SQL&gt; select file_name from dba_data_files  2  where tablespace_name='USER_DATA' ;     --&gt; USER_DATA tablespace를 구성하고 있는 datafile을 확인     [b]4. failure를 발생시키고, database startup 수행[/b]SQL&gt; @ breakdb.sql$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startup     --&gt; $HOME/DATA/DISK2/user01.dbf file이 없으므로 open을 할 수 없고, database는 mount 상태임     [b]5. Recovery 수행 후, database open[/b]SVRMGR&gt; ! cp $HOME/BACKUP/DISK2/user01.dbf $HOME/DATA/DISK2SVRMGR&gt; recover automatic database ;SVRMGR&gt; alter database open ;SVRMGR&gt; select tablespace_name, status from dba_tablespaces     2  where tablespace_name='USER_DATA' ;[b]6. sqlplus에 scott/tiger로 login 해서 newemp table을 query 해 보라.[/b]$ sqlplus scott/tigerSQL&gt; select count(*) from newemp ;     --&gt; 어떤 결과가 나타나는가? Practice 6-1 6의 결과와 비교해 보라.</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">08. downtime을 줄이기 위한 tablespace online recovery 수행</span></b></p><p>&nbsp;</p><pre> [b]1. failure 발생 후 database restart 수행[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; shutdown immediateSVRMGR&gt; startupSVRMGR&gt; @ breakdb.sqlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startup[b]2. downtime을 최소화 하기 위해 일단 손상된 datafile을 무시한 채, database를 open[/b]SVRMGR&gt; alter database datafile '$HOME/DATA/DISK2/user01.dbf' offline ;SVRMGR&gt; alter database open ;[b]3. 해당 datafile을 포함한 tablespace의 online recovery 수행[/b]SVRMGR&gt; alter tablespace USER_DATA offline immediate ;SVRMGR&gt; ! cp $HOME/BACKUP/DISK2/user01.dbf $HOME/DATA/DISK2SVRMGR&gt; recover automatic tablespace USER_DATA ;    --&gt; 개별 tablespace의 recovery 수행SVRMGR&gt; alter tablespace USER_DATA online ;[b]4. sqlplus에 scott/tiger로 login 해서 newemp table을 query 해 보라.[/b]$ sqlplus scott/tigerSQL&gt; select count(*) from newemp ;</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">09. downtime을 줄이기 위한 datafile online recovery 수행</span></b></p><p>&nbsp;</p><pre>[b]1. failure 발생 후 database restart 수행[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; shutdown immediateSVRMGR&gt; startupSVRMGR&gt; @ breakdb.sqlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startup[b]2 downtime을 최소화 하기 위해 일단 손상된 datafile을 무시한 채, database를 open[/b]SVRMGR&gt; alter database datafile '$HOME/DATA/DISK2/user01.dbf' offline ;SVRMGR&gt; alter database open ;[b]3. 해당 datafile의 online recovery 수행[/b]SVRMGR&gt; ! cp $HOME/BACKUP/DISK2/user01.dbf $HOME/DATA/DISK2SVRMGR&gt; recover automatic databfile '$HOME/DATA/DISK2/user01.dbf'   -- 개별 datafile의 recovery 수행SVRMGR&gt; alter database datafile '$HOME/DATA/DISK2/user01.dbf' online ;[b]4. sqlplus에 scott/tiger로 login해서 newemp table을 query해 보라.[/b]$ sqlplus scott/tigerSQL&gt; select count(*) from newemp ;</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">10.loss of datafile with no backup의 경우 complete recovery</span></b></p><p>&nbsp;</p><pre>[b]1. 새로운 tablespace 생성[/b]$svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; create tablespace test_data     2  datafile '$HOME/DATA/DISK5/test01.dbf' size 20k ;SVRMGR&gt; archive log list ;SVRMGR&gt; connect scott/tigerSVRMGR&gt; create table test     2  tablespace test_data     3  as select * from dept ;SVRMGR&gt; select count(*) from test ;SVRMGR&gt; connect internal ;SVRMGR&gt; alter system switch logfile ;SVRMGR&gt; alter system switch logfile ;[b]2. Failure 발생[/b]SVRMGR&gt; shutdown abortSVRMGR&gt; ! rm $HOME/DATA/DISK5/test01.dbf[b]3. startup 도중 test01.dbf의 유실로 open이 불가능[/b]   --&gt; 하지만 backup이 없음.   SVRMGR&gt; startupORA-01157: cannot identify data file 6 - file not foundSVRMGR&gt; alter database     2  create datafile '$HOME/DATA/DISK5/test01.dbf' as '$HOME/DATA/DISK5/test02.dbf' ;SVRMGR&gt; recover datafile '$HOME/DATA/DISK5/test02.dbf'   --&gt; auto 입력   SVRMGR&gt; alter database open ;[b]4. 확인 후 원래 상태로.[/b]SVRMGR&gt; select count(*) from scott.test ;SVRMGR&gt; drop tablespace test_data including contents ;SVRMGR&gt; ! rm $HOME/DATA/DISK5/test02.dbfSVRMGR&gt; shutdown immediate ;SVRMGR&gt; startupSVRMGR&gt; exit</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">11. online backup 도중에 정전</span></b></p><p>&nbsp;</p><pre>[b]1. Online Backup 수행 도중 갑자기 정전[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; alter tablespace rollback_data begin backup ;SVRMGR&gt; ! cp $HOME/DATA/DISK3/rbs01.dbf $HOME/BACKUP/rbs01.bkpSVRMGR&gt; shutdown abort   --&gt; 정전 사태 발생!!!SVRMGR&gt; exit[b]2. 다시 전원이 들어와서 startup을 시도[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startup     --&gt; file의 sync 정보가 서로 일치하지 않으므로 실패!!!ORA-01113: file 2 needs media recovery[b]3. 복구[/b]SVRMGR&gt; select * from v$backup ;   &lt;-- status가 ACTIVE 상태이면, backup mode에 걸려 있다.SVRMGR&gt; select * from v$datafile_header ;SVRMGR&gt; alter database datafile     2  '$HOME/DATA/DISK3/rbs01.dbf' end backup ;SVRMGR&gt; alter database open ;SVRMGR&gt; select * from v$backup ;SVRMGR&gt; --&gt; 이 상태에서 Online Backup을 다시 받으면 된다.SVRMGR&gt; shutdown immediateSVRMGR&gt; startup  --&gt; DB가 정상적으로 운용됨SVRMGR&gt; exit</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">12. Archivelog mode에서의 Time-based Incomplete Database Recovery 수행</span></b></p><p>&nbsp;</p><pre>[b]1. sqlplus scott/tiger로 login 하여 드음을 수행[/b]$ sqlplus scott/tigerSQL&gt; insert into newemp select * from newemp ;SQL&gt; select count(*) from newemp ;     --&gt; 이때의 건수를 잘 기억해 두자. 나중에 제대로 복구되었는지 확인하기 위해서...SQL&gt; commit ;SQL&gt; ! date     --&gt; time-based recovery를 하기 위해 시간을 확인.SQL&gt; drop table newemp ;     --&gt; 사용자의 실수로 table이 drop됨     [b]2. time-based incomplete recovery[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; shutdown immediateSVRMGR&gt; ! $HOME/LABS/cpdbfile.sh    --&gt; 모든 datafile을 restore 한다.SVRMGR&gt; startupSVRMGR&gt; set autorecovery onSVRMGR&gt; recover database until time '1999-03-22:14:44:47'    --&gt; 앞에서 기억한 시간이어야 함SVRMGR&gt; alter database open resetlogs ;    --&gt; incomplete recovery 이니까 "resetlogs"로 openSVRMGR&gt; archive log list    --&gt; log sequence 번호가 reset 되었음.SVRMGR&gt; select count(*) from scott.newemp ;    --&gt; "newemp" table의 건수 확인SVRMGR&gt; shutdown immediateSVRMGR&gt; exit[b]3. Log Sequence 번호가 Reset 되었으니까 Full closed database backup 수행하고, 필요 없는 file들을 삭제[/b]$ cp -rp $HOME/DATA/* $HOME/BACKUP$ rm ARCHIVE/*.arc$ ls ARCHIVE</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">13. Inactive Online Redo Log Group의 유실</span></b></p><p>&nbsp;</p><pre> [b]1. 정상적인 업무를 수행[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startupSVRMGR&gt; @ moreemp.sqlSVRMGR&gt; exit[b]2. Inactive Online Redo Log Group을 유실  --&gt;   Failure 발생!!![/b]$ sqlplus system/managerSQL&gt; select * from v$log ;    --&gt; inactive redolog group이 archive가 되었는지 확인SQL&gt; wksh01.sql$ chmod 777 wksh01.sh$ rm $ORACLE_HOME/DATA/DISK1/log1a.rdo                                     $ rm $ORACLE_HOME/DATA/DISK2/log1b.rdo                                        --&gt; inactive redolog group의 유실[b]3. Database가 비정상적으로 수행됨을 확인[/b]$svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; @ moreemp.sql     --&gt; online redo log file의 유실로 인해 Error 발생!!!SVRMGR&gt; shutdown immediate  --&gt; shutdown 실패 (Server Process가 죽었다)SVRMGR&gt; exit    --&gt; exit 했다가 다시 들어가자.[b]4. Recovery 시작[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; shutdown abortSVRMGR&gt; startup           --&gt; mount까지만 수행됨SVRMGR&gt; alter database backup controlfile to trace ;   --&gt; 만일의 경우 대비SVRMGR&gt; alter database drop logfile group ? ;    --&gt; log file의 유실을 반영 : error 발생SVRMGR&gt; alter database clear logfile group ? ;SVRMGR&gt; alter database open ;SVRMGR&gt; ! ls $HOME/DATA/DISK1[b]5. System이 정상적으로 운용되는지 확인[/b]SVRMGR&gt; @ moreemp.sqlSVRMGR&gt; select * from v$logfile ;SVRMGR&gt; shutdown immediateSVRMGR&gt; statupSVRMGR&gt; shutdown immediateSVRMGR&gt; exit</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">14. Current Online Redo Log Group 의 유실</span></b></p><p>&nbsp;</p><pre>[b] 정상적인 업무를 수행[/b]$ svrmgrlSVRMGR&gt; connect / as sysdba ;SVRMGR&gt; startupSVRMGR&gt; @ moreemp.sqlSVRMGR&gt; ! ls -la ARCHIVESVRMGR&gt; exit[b]2. current online redo log group을 유실  --&gt; Failure 발생[/b]$ sqlplus system/managerSQL&gt; select * from v$log ;SQL&gt; @ wksh02.sql$ chmod 777 wksh02.sh$ wksh02.sh     --&gt; current redolog group의 유실[b]3. Database가 비정상적으로 수행됨을 확인[/b]$ svrmgrlSVRMGR&gt; connect / as sysdba ;SVRMGR&gt; @ moreemp   --&gt; Online Redo Log file의 유실로 인해 failure 발생                    --&gt; 무한정 대기하게 된다. 왜? "Ctrl+C"를 두번 눌러서 강제 종료SVRMGR&gt; shutdown immediate[b]4. Recovery 시작[/b]   --&gt; 유실된 Redo Log Group을 제거하고 재생성함으로써 해결할려고 시도   SVRMGR&gt; startup  --&gt; Redo Log Group이 유실 되었음을 알리며 Error 발생, Mount까지만 수행된다.                 --&gt; Log Group 번호 확인할 것SVRMGR&gt; alter database clear logfile group ? ;        --&gt; 유실된 Redo Log Group을 clear 시도        --&gt; Archive 되지 않은 Current Log 이므로 Error와 함께 실패!!!SVRMGR&gt; shutdown immediateSVRMGR&gt; exit[b]5. Alert File, Trace File 확인[/b]$ cd $HOME/TRACE$ vi alert_SID.log    --&gt; Archivign을 실패한 기록과 Sequence 번호 확인$ more arch_번호.trc  --&gt; 기록되지 않은 Log File의 Sequence 번호 확인  --&gt; (예)ORA-00255: error archiving log 1 of thread 1, sequence # 14  --&gt; 예를들어, sequence # 14 번이라면, Incomplete Recovery 시 14번 에서 "Cancel"을 입력  [b]6. cancel-based incomplete recovery 수행[/b]$ svrmgrlSVRMGR&gt; connect / as sysdba ;SVRMGR&gt; ! $HOME/LABS/cpdbfile.sh   --&gt; 모든 datafile을 restore 한다.SVRMGR&gt; startup mountSVRMGR&gt; recover database until cancel"cancel" 입력   --&gt; 계속 "Enter"를 누르다가 앞에서 확인한 번호에서 "Cancel"을 입력                --&gt; 이때, 유실된 Log File이 자동으로 만들어 진다.SVRMGR&gt; alter database open resetlogs ;SVRMGR&gt; archive log listSVRMGR&gt; shutdown immediateSVRMGR&gt; exit[b]7. Log Sequence 번호가 Reset 되었으니까 full closed database backup 수행[/b]$ cp -rp $HOME/DATA/*  $HOME/BACKUP$ cd ARCHIVE$ rm *.arc     --&gt; Archived Redo Log File들을 삭제한다.</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">15. backup controlfile을 이용한 복구</span></b></p><p>&nbsp;</p><pre>[b]1. 정상적인 업무를 수행[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startupSVRMGR&gt; @ moreemp.sqlSVRMGR&gt; ! ls -al ARCHIVE[b]2. emp table을 포함한 tablespace를 drop[/b]SVRMGR&gt; alter database backup controlfile to '$HOME/BACKUP/control.ctl' ;  --&gt; 현재의 controlfile을 backupSVRMGR&gt; drop tablespace user_data including contents ;SVRMGR&gt; select * from scott.emp  --&gt; error 발생SVRMGR&gt; alter system switch logfile ;SVRMGR&gt; alter system switch logfile ;SVRMGR&gt; alter system switch logfile ;SVRMGR&gt; shutdown immediateSVRMGR&gt; exit[b]3. drop 된 tablespace에는 중요한 table들이 있었으므로 tablespace가 drop 되기 직전으로 복구하려고 하지만,현재의 controlfile에는 그 tablespace에 대한 정보가 이미 사라지고 없다. Backup controlfile을 이용하여 time-based incomplete recovery를 수행[/b]$ cd TRACE$ vi alert_SID.log  --&gt; tablespace가 drop된 시점을 확인$ cp $HOME/BACKUP/control.ctl $HOME/DATA/DISK1/cntrl???_1.ctl$ cp $HOME/BACKUP/control.ctl $HOME/DATA/DISK2/cntrl???_2.ctl    --&gt; backup controlfile을 restore$ $HOME/LABS/cpdbfile.sh$ svrmgrlSVRMGR&gt; connect / as sysdba ;SVRMGR&gt; startup mount ;SVRMGR&gt; startup mountSVRMGR&gt; set autorecovery onSVRMGR&gt; recover database until time 'YYYY-MM-DD':HH:MI:SS'     2  using backup controlfile ;     [b]4. database를 resetlogs로 open 한 후, full closed database backup 수[/b]SVRMGR&gt; alter database open resetlogs ;SVRMGR&gt; shutdown immediateSVRMGR&gt; exit$ cp -rp $HOME/DATA/* $HOME/BACKUP$ cd ARCHIVE$ rm *.arc    --&gt; Archived Redo Log File들 삭제</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">16. Oracle Export and Import utilities 사용</span></b></p><p>&nbsp;</p><pre>[b]1. DB를 기동한 후 data의 변경이 많은 scott schema의 emp, dept table을 export 한다.[/b]$ svrmgrlSVRMGR&gt; connect / as sysdba ;SVRMGR&gt; startupSVRMGR&gt; host$ exp scott/tiger file=$HOME/empdept.dmp tables=emp,dept[b]2. scott가 작업 도중 실수로 emp 와 dept를 DROP.[/b]$ sqlplus scott/tigerSQL&gt; select count(*) from emp ;   --&gt; 건수 확인SQL&gt; select count(*) from dept ;  --&gt; 건수 확인SQL&gt; drop table emp ;SQL&gt; drop table dept ;SQL&gt; host[b]3. Import utility를 이용하여 emp와 dept를 restore 해보자.[/b]$ imp scott/tiger file=$HOME/empdetpt.dmp full=y[b]4. emp와 dept 테이블의 내용을 확인한다.[/b]$ sqlplus scott/tigerSQL&gt; select count(*) from emp ;SQL&gt; select count(*) from dept ;</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">17. Incremental export를 이용한 recovery</span></b></p><p>&nbsp;</p><pre>[b]1. scott schema의 emp table의 건수를 확인 후, 다음을 수행[/b]$ sqlplus scott/tigerSQL&gt; select count(*) from emp ;SQL&gt; exit$ exp userid=sys/change_on_install full=y file=comp001.dmp inctype=complete$ sqlplus system/managerSQL&gt; @ moreempSQL&gt; exit$ exp userid=sys/change_on_install full=y file=inc002.dmp inctype=incremental$ sqlplus system/managerSQL&gt; @ moreempSQL&gt; exit$ exp userid=sys/change_on_install full=y file=inc003.dmp inctype=incremental $ sqlplus system/managerSQL&gt; @ moreempSQL&gt; exit$ exp userid=sys/change_on_install full=y file=cum004.dmp inctype=cumulative$ sqlplus system/managerSQL&gt; @ moreempSQL&gt; exit$ exp userid=sys/change_on_install full=y file=inc005.dmp inctype=incremental$ sqlplus scott/tigerSQL&gt; select count(*) from emp ;SQL&gt; drop table emp ;[b]2. import를 이용하여 recovery 수행[/b]$ imp userid=sys/change_on_install full=y file=comp001.dmp ignore=y$ imp userid=sys/change_on_install full=y file=cum004.dmp ignore=y$ imp userid=sys/change_on_install full=y file=inc005.dmp ignore=y $ sqlplus scott/tigerSQL&gt; select count(*) from emp ;</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">18. RMAN : Overview</span></b></p><p>&nbsp;</p><pre>[b]1. RMAN 사용의 장점[/b]   - backup하는 동안 currupted block을 보호한다.   - Oracle Parallel Server를 지원한다.   - Automatic parallelization, Less redo generated, Restricted I/O for backups, Tape streaming     등을 통해 performance를 증가 시킨다.[b]2. Recovery Catalog에 대하여[/b]   1) recovery catalog 란?      - Datafile and archive log backup sets      - Datafile copies      - Archived redo logs      - The physical structure of the target database      - Stored job scripts   2) recovery catalog 사용의 장점      - Backup information retained      - Enough resources for a separate database      - Stored  scripts required      - Tablespace Point-in-time recovery or incremental block level backups are desired      - Recommended by Oracle[b]3. recovery catalog를 생성하는 script는?[/b]   $ORACLE_HOME/rdbms/admin/catrman.sql[b]4. recovery catalog 없이 RMAN을 사용하여 target DB에 connect 해보자[/b]$ rman target sys/change_on_install nocatalogRecovery Manager: Release 8.0.5.0.0 - ProductionRMAN-06009: using target database controlfile instead of recovery catalogRMAN-06005: connected to target database: DBA420RMAN&gt; exit[b]5. recovery catalog를 구성해 보자.[/b]Catalog database는 rcvcat alias를 사용하고, user는 rman01 이라면...$ sqlplus rman01/rman01@rcvcatSQL&gt; select * from session_roles ;   --&gt; recovery_catalog_owner role을 확인SQL&gt; select * from user_users ;SQL&gt; @ $ORACLE_HOME/rdbms/admin/catrmanSQL&gt; select distinct object_type, count(*)  2  from user_objects  3  group by object_type ;SQL&gt; select object_name from user_objects when object_type='VIEW' ;[b]6. 이번에는 recovery catalog를 이용해 보자[/b]$ rman target sys/change_on_install rcvcat rman01/rman01@rcvcatRecovery Manager: Release 8.0.5.0.0 - ProductionRMAN-06005: connected to target database: <dba205 sid="" :="">RMAN-06008: connected to recovery catalog databaseRMAN&gt; exit</dba205></pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">19. Recovery catalog Maintenance</span></b></p><p>&nbsp;</p><pre>[b]1. recovery catalog에 script를 생성[/b]$ rman target sys/change_on_install rcvcat rman01/rman01@rcvcatRMAN&gt; create script NightlyBackup {   2  allocate channel c1 type DISK ;   3  backup   4  incremental level = 0   5  format '$HOME/df_%d_%s_%p.bus'   6  tag=NIGHTLY   7  filesperset=5   8  (database include current controlfile) ;   9  release channel c1 ;  10  sql 'alter system archive log current' ; )  RMAN&gt; exit[b]2. sqlplus에서 script가 제대로 저장되었는지 확인[/b]$ sqlplus rman01/rman01@rcvcatSQL&gt; select * from rc_stored_script ;</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">20. Backup using RMAN scenario</span></b></p><p>&nbsp;</p><pre>[b]1. v$log를 조회하여 current redolog를 확인 후, current redolog를 archive 시킨다.[/b]$ sqlplus system/managerSQL&gt; select * from v$log ;   --&gt; current redolog 번호 확인SQL&gt; alter system archive log current ;[b]2. lab111.rmn 파일을 다음과 같이 편집하자[/b]$ cp lab11_1.rmn lab111.rmn$ vi lab111.rmn  create script lab11_rman   { allocate channel c1 type disk ;     copy     datafile '$HOME/DATA/DISK/system01.dbf'           to '$HOME/BACKUP/system01.dbf'          tag = SYSTEM01,     archivelog '$HOME/BACKUP/arch_XXX.arc'           to '$HOME/ARCHIVE/arch_XXX.arc',     --&gt; 앞에서 확인한 current redo log     current controlfile to '$HOME/BACKUP/control1.bak' ;     release channel c1 ; }[b]3. rman에 접속하여 script를 저장하고, 저장된 script를 수행.[/b]$ rman target sys/change_on_install rcvcat rman01/rman01@rcvcatRMAN&gt; @ lab111.rmn...RMAN&gt; **end-of-file**RMAN&gt; run { execute script lab111_rman ; }RMAN&gt; exit[b]4. 작업 도중 corrupt block 이 발견 되었는지 확인하고, v$datafile_copy를 이용하여 controlfile에 반영 되었는지 확인[/b]$ sqlplus system/managerSQL&gt; select * from v$copy_corruption ;SQL&gt; select name, tag from v$datafile_copy ;    --&gt; 여러 개SQL&gt; connect rman01/rman01@rcvcatSQL&gt; select * from rc_copy_corrution ;SQL&gt; select * from rc_datafile_copy ;           --&gt; 2 개 [b]5. lab11_2.rmn 파일을 다음과 같이 편집하자[/b]$ cp lab11_2.rmn lab112.rmn$ vi lab112.rmn  create script lab112_rman   { allocate channel c1 type disk ;     allocate channel c2 type disk ;     backup incremental level = 0     format '$HOME/BACKUP/INC0/df_%d_%s_%p.bus'     tag=BACKUP01     filesperset = 4     (database include current controlfile) ;     release channel c1 ;     release channel c2 ; }[b]6. rman에 접속하여 script를 저장하고, 저장된 script를 수행.[/b]$ rman target sys/change_on_install rcvcat rman01/rman01@rcvcatRMAN&gt; @ lab123.rmn...RMAN&gt; **end-of-file**RMAN&gt; run { execute script lab112_rman ; }RMAN&gt; exit ;[b]7. 작업 도중 corrupt block이 발견 되었는지 확인하고, v$backup_set을 이용하여 controlfile에 반영 되었는지 확인[/b]$ sqlplus system/managerSQL&gt; select * from v$copy_corruption ;SQL&gt; select * from v$backup_set ;SQL&gt; connect rman01/rman01@rcvcatSQL&gt; select * from rc_copy_corrution ;SQL&gt; select * from rc_backup_set ;[b]4. database를 정상적으로 운용[/b]SQL&gt; @ moreemp.sql [b]8. lab11_3.rmn을 다음과 같이 편집하자.[/b]$ cp lab11_3.rmn lab113.rmn$ vi lab113.rmn  create script lab113_rman   { allocate channel c1 type disk ;     allocate channel c2 type disk ;     backup incremental level=2       format '$HOME/BACKUP/INCR2/dv_%d_%s_%p.bus'       tag=BACKUP02       filesperset=4       (database include current controlfile) ;     release channel c1 ;     release channel c2 ;   }[b]9. rman에 접속하여 script를 저장하고, 저장된 script를 수행.[/b]$ rman target sys/change_on_install rcvcat rman01/rman01@rcvcatRMAN&gt; @ lab113.rmn...RMAN&gt; **end-of-file**RMAN&gt; run { execute script lab113_rman ; }RMAN&gt; exit[b]10. OS에 backup set file이 제대로 생성되었는지 확인[/b]$ ls -l $HOME/BACKUP/INC0$ ls -l $HOME/BACKUP/INC2</pre><p>&nbsp;</p><p><b><span style="COLOR: #008000">21. Restore and Recover using RMAN</span></b></p><p>&nbsp;</p><pre> [b]1. database 가 정상적으로 운용되는지 확인[/b]$ svrmgrlSVRMGR&gt; connect / as sysdbaSVRMGR&gt; startupSVRMGR&gt; shutdown immediate[b]2. datafile을 유실하여 failure 발생[/b]SVRMGR&gt; ! rm $HOME/DATA/DISK2/user01.dbfSVRMGR&gt; startupSVRMGR&gt; exit[b]3. RMAN을 이용하여 복구해 보자[/b]$ rman target sys/change_on_install rcvcat rman01/rman01@rcvcatRMAN&gt; create script recover_df   2    { allocate channel c1 type disk ;   3      restore datafile '$HOME/DATA/DISK2/user01.dbf' ;   4      recover datafile '$HOME/DATA/DISK2/user01.dbf' ;   5      release channel c1 ; }RMAN&gt; run { execute script recover_df ; }RMAN&gt; run { sql "alter database open" ; }RMAN&gt; exit[b]4. database가 정상적으로 open 되었는지, 정상적으로 복구 되었는지 확인[/b]$ svrmgrlSVRMGR&gt; select count(*) from scott.emp ;SVRMGR&gt; shutdown immediateSVRMGR&gt; startupSVRMGR&gt; shutdown immediate</pre></td></tr></tbody></table></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

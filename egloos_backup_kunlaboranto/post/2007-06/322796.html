<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] Dynamic SQL - 동적 쿼리, SP내에서의 DDL</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2007-06-19 04:28:32</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] Dynamic SQL - 동적 쿼리, SP내에서의 DDL</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content"><table class="infotable" style="TEXT-ALIGN: left" cellspacing="0" cellpadding="3" border="0"><tbody><tr><td class="rowtitle" colspan="6">From : <a href="http://database.sarang.net/?inc=read&amp;aid=4163&amp;criteria=oracle&amp;subcrit=&amp;id=25842&amp;limit=20&amp;keyword=v%24statement&amp;page=34">http://database.sarang.net/?inc=read&amp;aid=4163&amp;criteria=oracle&amp;subcrit=&amp;id=25842&amp;limit=20&amp;keyword=v%24statement&amp;page=34</a><br><br>Dynamic SQL 에 관한글</td></tr><tr><th class="infotable_th"><div style="WHITE-SPACE: nowrap">작성자</div></th><td class="rowmisc"><div style="WHITE-SPACE: nowrap">정재익</div></td><th class="infotable_th"><div style="WHITE-SPACE: nowrap">작성일</div></th><td class="rowmisc"><div style="WHITE-SPACE: nowrap">2001-05-10 23:12:27</div></td><th class="infotable_th"><div style="WHITE-SPACE: nowrap">조회수</div></th><td class="rowmisc" align="right"><div style="WHITE-SPACE: nowrap">1,475</div></td></tr></tbody></table><table class="viewtable" style="TEXT-ALIGN: left"><tbody><tr><td class="rowbody"><p>출처 : 미상</p><p>&nbsp;</p><p>DYNAMIC SQL 이란?　　　 </p><p>　　　 </p><p>PL/SQL은 Binding이 Compile시에 일어나므로 Database Object의 Name이 Compile시에 고정되어야 하는 등의 제한이</p><p>있다.　　　 </p><p>PL/SQL 2.1(RDBMS 7.1)이후 Version에서는 DBMS_SQL Package로 Dynamic SQL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>의 사용을 가능하게 한다. 이는</p><p>Database Object의 Name을 Runtime에 줄 수 있을 뿐더러 DDL문장을 기술할 수도 있는 장점이 있다.　　　 </p><p>&nbsp;</p><p>　* Function Open_Cursor　　　 </p><p>　 : SQL문의 실행에 필요한 새로운 Cursor를 열고 Cursor ID Number를Return 한다.　　　 </p><p>&nbsp;</p><p>　* Function Is_Open　　　 </p><p>　 : 주어진 Cursor가 현재 Open되어 있으면 TRUE를, 아니면 FALSE를 Return한다.　　　 </p><p>&nbsp;</p><p>　* Procedure Parse　　　 </p><p>　 : <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>를 Check하고 Cursor와 결합시킨다.　　　 </p><p>&nbsp;</p><p>　* Procedure Bind_Variable　　　 </p><p>　 : Program내에서 Data를 저장한 Placeholder의 값을 제공하는 역할을 한다.　　　 </p><p>&nbsp;</p><p>　* Procedure Define_Column　　　 </p><p>　 : Cursor로부터 Select된 Column의 값을 받는 변수를 지정한다.　　　 </p><p>&nbsp;</p><p>　* Function Execute　　　 </p><p>　 : SQL문을 실행하고 처리된 Row의 수를 Return한다. (Insert, Update, Delete인 경우에만　　　 </p><p>　　　 해당)　　　 </p><p>&nbsp;</p><p>　* Function Fetch_Rows　　　 </p><p>　 : Cursor로부터 Row를 Fetch하고 실제로 Fetch된 Row의 수를 Return한다. 이 Row들은 Buffer에　　　 </p><p>　　　 들어가며,　 Column_Value를 호출하여 읽어들여야 한다.　　　　 </p><p>&nbsp;</p><p>　* Function Execute_And_Fetch　　　 </p><p>　 : Execute와 Fetch Row를 동시에 수행하고 실제로 Fetch된 Row의 수를 Return한다.　　　 </p><p>&nbsp;</p><p>　* Procedure Variable_Value　　　 </p><p>　 : 주어진 변수의 값을 Return한다.　　　 </p><p>&nbsp;</p><p>　* Procedure Column_Value　　　 </p><p>　 : Fetch_Rows에 의해 Fetch된 Data의 값을 Return한다.　　　 </p><p>&nbsp;</p><p>　* Procedure Close_Cursor　　　 </p><p>　 : Cursor를 닫는다.　　　 </p><p>&nbsp;</p><p>　　　　 </p><p>l Using The DBMS_SQL Package To Execute DDL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>s:　　　 </p><p>&nbsp;</p><p>&lt; Example 1 &gt;　　　 </p><p>　　 Table을 Create하는 Procedure로 Table Name, Column Name과 그Type을Parameter로 받는다.　　　 </p><p>&nbsp;</p><p>CREATE OR REPLACE PROCEDURE ddlproc (tablename varchar2,　　　　 </p><p>cols varchar2) AS　　　 </p><p>　 cursor1 INTEGER;　　　 </p><p>BEGIN　　　 </p><p>　 cursor1 := dbms_sql.open_cursor;　　　 </p><p>　 dbms_sql.parse(cursor1, 'CREATE TABLE ' || tablename ||　　　 </p><p>　　　 ' ( ' || cols || ' )', dbms_sql.v7);　　　 </p><p>　 dbms_sql.close_cursor(cursor1);　　　 </p><p>end;　　　 </p><p>/　　　 </p><p>　　　　 </p><p>SQL&gt; execute ddlproc ('MYTABLE','COL1 NUMBER, COL2 VARCHAR2(10)');　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>SQL&gt; desc mytable;　　　 </p><p>　Name　　　　　　　　　　　　　　　　　　　　　　　　　　　 Null?　 Type　　　 </p><p>　-------------------------- ------ ------------　　　 </p><p>　COL1　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 NUMBER　　　 </p><p>　COL2　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 VARCHAR2(10)　　　 </p><p>　　　　 </p><p>　 DDL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>는 Parse Command에 의해 수행된다. 그러므로 DDL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>에서는 Bind Variable을 사용할 수가</p><p>없다.　　　 </p><p>&nbsp;</p><p>다음은 DDL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>내에 Bind Variable을 사용한 잘못된 예이다.　　　 </p><p>&nbsp;</p><p>CREATE OR REPLACE PROCEDURE ddlproc (tablename　　　　 </p><p>VARCHAR2, colname　　 VARCHAR2,　 coltype　　 VARCHAR2)　　　　 </p><p>AS　　　 </p><p>　 cursor1 INTEGER;　　　 </p><p>　 ignore　 INTEGER;　　　 </p><p>BEGIN　　　 </p><p>　 cursor1 := dbms_sql.open_cursor;　　　 </p><p>　 dbms_sql.parse(cursor1,'CREATE TABLE :x1 (:y1 :z1)',　　　　 </p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><p>dbms_sql.v7);　　　 </p><p>　 dbms_sql.bind_variable(cursor1, ':x1', tablename);　　　 </p><p>　 dbms_sql.bind_variable(cursor1, ':y1', colname);　　　 </p><p>　 dbms_sql.bind_variable(cursor1, ':z1', coltype);　　　 </p><p>　 ignore := dbms_sql.execute(cursor1);　　　 </p><p>　 dbms_sql.close_cursor(cursor1);　　　 </p><p>end;　　　 </p><p>/　　　 </p><p>&nbsp;</p><p>　Procedure를 create했을때에는 error를 만나지 않았지만, runtime에는 "ORA-00903: invalid table name" 이라는 error가</p><p>난다.　　　 </p><p>　　　　 </p><p>SQL&gt; execute ddlproc ('MYTABLE', 'COL1', 'NUMBER');　　　 </p><p>&nbsp;</p><p>begin ddlproc ('MYTABLE', 'COL1', 'NUMBER'); end;　　　 </p><p>　　　　 </p><p>*　　　 </p><p>ERROR at line 1:　　　 </p><p>ORA-00903: invalid table name　　　 </p><p>ORA-06512: at "SYS.DBMS_SYS_SQL", line 239　　　 </p><p>ORA-06512: at "SYS.DBMS_SQL", line 25　　　 </p><p>ORA-06512: at "SCOTT.DDLPROC", line 8　　　 </p><p>ORA-06512: at line 1　　　 </p><p>　　　　 </p><p>&nbsp;</p><p>&lt; Example 2 &gt;　　　 </p><p>　 Table을 Drop하는 Procedure로 Table Name을 Parameter로 받는다.　　　 </p><p>　　　　 </p><p>&nbsp;</p><p>create or replace procedure droptable (table_name varchar2) as　　　 </p><p>　 cursor1 integer;　　　 </p><p>begin　　　 </p><p>　 cursor1 := dbms_sql.open_cursor;　　　 </p><p>　 dbms_sql.parse(cursor1, 'DROP TABLE ' || table_name,　　　　 </p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　 dbms_sql.v7);　　　 </p><p>　 dbms_sql.close_cursor(cursor1);　　　 </p><p>end;　　　 </p><p>/　　　 </p><p>　　　　 </p><p>SQL&gt; begin　　　 </p><p>　 2　　　 droptable('MYTABLE');　　　 </p><p>　 3　 end;　　　 </p><p>　 4　 /　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>&nbsp;</p><p>　　　　 </p><p>&lt; Example 3 &gt;　　　 </p><p>　 DDL Statemenet를 수행하는 Procedure로 DDL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>자체를　 Parameter로 받는다.　　　 </p><p>　　　　 </p><p>create procedure anyddl (s1 varchar2) as　　　 </p><p>　 cursor1 integer;　　　 </p><p>begin　　　 </p><p>　 cursor1 := dbms_sql.open_cursor;　　　 </p><p>　 dbms_sql.parse(cursor1, s1, dbms_sql.v7);　　　 </p><p>　 dbms_sql.close_cursor(cursor1);　　　 </p><p>end;　　　 </p><p>/　　　 </p><p>　　　　 </p><p>SQL&gt; execute anyddl('CREATE TABLE MYTABLE (COL1 NUMBER)');　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>SQL&gt; desc mytable;　　　 </p><p>　Name　　　　　　　　　　　　　　　　　　　　　　　　　　　 Null?　　 Type　　　 </p><p>　-------------------------　　 -----　　 -----------　　　 </p><p>　COL1　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 NUMBER　　　 </p><p>　　　　 </p><p>SQL&gt; execute anyddl('drop table mytable');　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>　　 l Using the DBMS_SQL Package to Execute Dynamic SQL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>s:　　　 </p><p>&nbsp;</p><p>　DBMS_SQL package는 dynamic SQL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">statement</span>를 수행하는데 이용되어 질 수 있는데 이는 runtime전에 <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">statement</span>의 일부분</p><p>혹은 전체를 알 수 없는 경우에 쓰여진다.　　　 </p><p>&nbsp;</p><p>　　　　 </p><p>&lt; Example 4 &gt;　　　 </p><p>　 이 예제는 Run Time시에 주어진 Number보다 더 높은 Employee Number를 가진 모든 Employee 의 이름과</p><p>Employee Number를 Return한다.　　　 </p><p>　　　　 </p><p>CREATE or REPLACE PROCEDURE rows_greater_than (low_value　　　　 </p><p>　　　 number) AS　　　 </p><p>　 cursor1　 integer;　　　 </p><p>　 rows_processed　 integer;　　　 </p><p>　 myempno number;　　　 </p><p>　 myename varchar2(20);　　　 </p><p>BEGIN　　　 </p><p>　 cursor1 := dbms_sql.open_cursor;　　　 </p><p>　 dbms_sql.parse (cursor1, 'select empno, ename from emp　　　　 </p><p>　　　　　　　　 where empno &gt; :x', dbms_sql.v7);　　　 </p><p>　 dbms_sql.bind_variable(cursor1, 'x', low_value);　　　 </p><p>　 dbms_sql.define_column (cursor1, 1, myempno);　　　 </p><p>　 dbms_sql.define_column (cursor1, 2, myename, 20);　　　 </p><p>　 rows_processed := dbms_sql.execute (cursor1);　　　 </p><p>　 loop　　　 </p><p>　　　 if dbms_sql.fetch_rows (cursor1) &gt; 0 then　　　 </p><p>　　　　　 dbms_sql.column_value (cursor1, 1, myempno);　　　 </p><p>　　　　　 dbms_sql.column_value (cursor1, 2, myename);　　　 </p><p>　　　　　 dbms_output.put_line(to_char(myempno) || '　　 ' || myename);　　　 </p><p>　　　 else　　　 </p><p>　　　　　 exit;　　　 </p><p>　　　 end if;　　　 </p><p>　 end loop;　　　 </p><p>　 dbms_sql.close_cursor (cursor1);　　　 </p><p>EXCEPTION　　　 </p><p>　 WHEN OTHERS THEN　　　 </p><p>　　　 dbms_output.put_line(sqlerrm);　　　 </p><p>　　　 if dbms_sql.is_open (cursor1) then　　　 </p><p>　　　　　 dbms_sql.close_cursor (cursor1);　　　 </p><p>　　　 end if;　　　 </p><p>END;　　　 </p><p>/　　　 </p><p>　　　　 </p><p>　 DBMS_OUTPUT package을 사용하기 전에 먼저 SET SERVEROUTPUT ON command를 사용하여야 한다.　　　 </p><p>　　　　 </p><p>SQL&gt; set serveroutput on　　　 </p><p>SQL&gt; execute rows_greater_than(7500);　　　 </p><p>7521　　 WARD　　　 </p><p>7566　　 JONES　　　 </p><p>7654　　 MARTIN　　　 </p><p>7698　　 BLAKE　　　 </p><p>7782　　 CLARK　　　 </p><p>7788　　 SCOTT　　　 </p><p>7839　　 KING　　　 </p><p>7844　　 TURNER　　　 </p><p>7876　　 ADAMS　　　 </p><p>7900　　 JAMES　　　 </p><p>7902　　 FORD　　　 </p><p>8100　　 MILLER　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>SQL&gt; execute rows_greater_than(8000);　　　 </p><p>8100　　 MILLER　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>&nbsp;</p><p>&lt; Example 5 &gt;　　　 </p><p>　이 예제는 Where Clause의 Parameter를 Column_Name과 Operator(&lt;,&lt;=,=,&gt;=,&gt;), New_Value로 받아서</p><p>Employee 이름과 Number를 Return한다.　　　 </p><p>&nbsp;</p><p>　　　　 </p><p>CREATE or REPLACE PROCEDURE get_rows (column_name　　　　 </p><p>varchar2,　 comparison_type varchar2, new_value number)　　　 </p><p>　AS　　　 </p><p>　 cursor1　 integer;　　　 </p><p>　 rows_processed　 integer;　　　 </p><p>　 myempno number;　　　 </p><p>　 myename varchar2(20);　　　 </p><p>BEGIN　　　 </p><p>　 cursor1 := dbms_sql.open_cursor;　　　 </p><p>　 dbms_sql.parse (cursor1, 'select empno, ename from emp　　　 </p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 where ' || column_name ||　　　 </p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 ' ' || comparison_type || ' :x',　　　 </p><p>　　　　　　　　　　　　　　　　　　　　　 dbms_sql.v7);　　　 </p><p>　 dbms_sql.bind_variable(cursor1, 'x', new_value);　　　 </p><p>　 dbms_sql.define_column (cursor1, 1, myempno);　　　 </p><p>　 dbms_sql.define_column (cursor1, 2, myename, 20);　　　 </p><p>　　　 rows_processed := dbms_sql.execute (cursor1);　　　 </p><p>　 loop　　　 </p><p>　　　 if dbms_sql.fetch_rows (cursor1) &gt; 0 then　　　 </p><p>　　　　　 dbms_sql.column_value (cursor1, 1, myempno);　　　 </p><p>　　　　　 dbms_sql.column_value (cursor1, 2, myename);　　　 </p><p>　　　　　 dbms_output.put_line(to_char(myempno) || '　　 ' || myename);　　　 </p><p>　　　 else　　　 </p><p>　　　　　 exit;　　　 </p><p>　　　 end if;　　　 </p><p>　 end loop;　　　 </p><p>　 dbms_sql.close_cursor (cursor1);　　　 </p><p>EXCEPTION　　　 </p><p>　 WHEN OTHERS THEN　　　 </p><p>　　　 dbms_output.put_line(sqlerrm);　　　 </p><p>　　　 if dbms_sql.is_open (cursor1) then　　　 </p><p>　　　　　 dbms_sql.close_cursor (cursor1);　　　 </p><p>　　　 end if;　　　 </p><p>END;　　　 </p><p>/　　　 </p><p>　　　　 </p><p>SQL&gt; begin　　　 </p><p>　 2　　　 get_rows('EMPNO', '&lt;', 2000);　　　 </p><p>　 3　 end;　　　 </p><p>　 4　 /　　　 </p><p>1111　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>SQL&gt; execute get_rows('SAL', '&gt;', 3000);　　　 </p><p>7566　　 JONES　　　 </p><p>7788　　 SCOTT　　　 </p><p>7839　　 KING　　　 </p><p>7902　　 FORD　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>SQL&gt; begin　　　 </p><p>　 2　　　 get_rows('DEPTNO', '&gt;=', 20);　　　 </p><p>　 3　 end;　　　 </p><p>　 4　 /　　　 </p><p>7369　　 SMITH　　　 </p><p>7499　　 ALLEN　　　 </p><p>7521　　 WARD　　　 </p><p>7566　　 JONES　　　 </p><p>7654　　 MARTIN　　　 </p><p>7698　　 BLAKE　　　 </p><p>7788　　 SCOTT　　　 </p><p>7844　　 TURNER　　　 </p><p>7876　　 ADAMS　　　 </p><p>7900　　 JAMES　　　 </p><p>7902　　 FORD　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>&lt; Example 6 &gt;　　　 </p><p>　　 이 예제는 Where Clase 전체를 Runtime시에 Parameter로 받는다.　　　 </p><p>　　　　 </p><p>CREATE or REPLACE PROCEDURE get_rows (where_clause varchar2) AS　　　 </p><p>　 cursor1　 integer;　　　 </p><p>　 rows_processed　 integer;　　　 </p><p>　 myempno number;　　　 </p><p>　 myename varchar2(20);　　　 </p><p>BEGIN　　　 </p><p>　 cursor1 := dbms_sql.open_cursor;　　　 </p><p>　 dbms_sql.parse (cursor1, 'select empno, ename from emp where '　　　　 </p><p>　　　　　　　　　　　　　　 || where_clause, dbms_sql.v7);　　　 </p><p>　 dbms_sql.define_column (cursor1, 1, myempno);　　　 </p><p>　 dbms_sql.define_column (cursor1, 2, myename, 20);　　　 </p><p>　　　 rows_processed := dbms_sql.execute (cursor1);　　　 </p><p>　 loop　　　 </p><p>　　　 if dbms_sql.fetch_rows (cursor1) &gt; 0 then　　　 </p><p>　　　　　 dbms_sql.column_value (cursor1, 1, myempno);　　　 </p><p>　　　　　 dbms_sql.column_value (cursor1, 2, myename);　　　 </p><p>　　　　　 dbms_output.put_line(to_char(myempno) || '　　 ' || myename);　　　 </p><p>　　　 else　　　 </p><p>　　　　　 exit;　　　 </p><p>　　　 end if;　　　 </p><p>　 end loop;　　　 </p><p>　 dbms_sql.close_cursor (cursor1);　　　 </p><p>EXCEPTION　　　 </p><p>　 WHEN OTHERS THEN　　　 </p><p>　　　 dbms_output.put_line(sqlerrm);　　　 </p><p>　　　 if dbms_sql.is_open (cursor1) then　　　 </p><p>　　　　　 dbms_sql.close_cursor (cursor1);　　　 </p><p>　　　 end if;　　　 </p><p>END;　　　 </p><p>/　　　 </p><p>　　　　 </p><p>SQL&gt; execute get_rows('ENAME = ''KING'' ');　　　 </p><p>7839　　 KING　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>SQL&gt; execute get_rows('SAL &gt; 1000 AND DEPTNO = 10');　　　 </p><p>7782　　 CLARK　　　 </p><p>7839　　 KING　　　 </p><p>8100　　 MILLER　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>&lt; Example 7 &gt;　　　 </p><p>　 이 예제는 Non-Query SQL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">Statement</span>를 실행한다.　　　 </p><p>　　　　 </p><p>create procedure anysql (s1 varchar2) as　　　 </p><p>　 cursor1 integer;　　　 </p><p>　 return_value integer;　　　 </p><p>begin　　　 </p><p>　 cursor1 := dbms_sql.open_cursor;　　　 </p><p>　 dbms_sql.parse(cursor1, s1, dbms_sql.v7);　　　 </p><p>　 return_value := dbms_sql.execute(cursor1);　　　 </p><p>　 dbms_sql.close_cursor(cursor1);　　　 </p><p>end;　　　 </p><p>/　　　 </p><p>　　　　 </p><p>　　　　 </p><p>SQL&gt; execute anysql('CREATE TABLE MYTABLE (COL1 number, col2 varchar2(3))');　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>SQL　　　　　　　　　　　　　　　　　　　　 </p><p>SQL&gt; desc mytable;　　　 </p><p>　Name　　　　　　　　　　　　　　　　　　　　　　　　　　　 Null?　　　 Type　　　 </p><p>　-------------------------- ------- -----------　　　 </p><p>　COL1　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 NUMBER　　　 </p><p>　COL2　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 VARCHAR2(3)　　　 </p><p>　　　　 </p><p>SQL&gt; execute anysql('INSERT INTO MYTABLE VALUES(1, ''ABC'')');　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>SQL&gt; begin　　　 </p><p>　 2　　　 anysql(　　　 </p><p>　 3　　　　　 'declare　　　 </p><p>　 4　　　　　　　　 var1 varchar2(3);　　　 </p><p>　 5　　　　　　 begin　　　 </p><p>　 6　　　　　　　　 select col2　　　 </p><p>　 7　　　　　　　　　　 into var1　　　 </p><p>　 8　　　　　　　　　　 from mytable　　　 </p><p>　 9　　　　　　　　　　 where col1 = 1;　　　 </p><p>　10　　　　　　　　 dbms_output.put_line(''var1 = '' || var1);　　　 </p><p>　11　　　　　　 end;');　　　 </p><p>　12　 end;　　　 </p><p>　13　 /　　　 </p><p>var1 = ABC　　　 </p><p>　　　　 </p><p>PL/SQL procedure successfully completed.　　　 </p><p>　　　　 </p><p>　　　　 </p><p>&nbsp;</p><p>　　　　　 </p><p>　　 더 자세한 사항은 Oracle7 Server Documentation Addendum을 참조.　　　 </p><p>&nbsp;</p><p>Forms3.0은 PL/SQL 1.1만을 지원하므로 dynamic SQL을 쓸 수 없으며 stored procedure를 만들어 호출해서 사용해야 한다. 이때 Forms가 부른 stored procedure나 function은 그 내에서 commit을 사용할 수 없게 되어 있기 때문에 COMMIT이나</p><p>ROLLBACK을 만나면 ORA-00034: Commit and Rollback from PL/SQL disabled for this session이란 error가 난다. 따라서 DDL <span style="FONT-WEIGHT: bold; COLOR: brown; BACKGROUND-COLOR: yellow">statement</span>도 사용을 할 수 없다.</p></td></tr></tbody></table></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

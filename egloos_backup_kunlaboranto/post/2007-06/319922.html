<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] sleep에 얽힌 이야기들 </title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2007-06-18 13:08:08</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] sleep에 얽힌 이야기들 </h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content"><p>From : <a href="http://chonga.pe.kr/computer/programming/sleep_story.txt">http://chonga.pe.kr/computer/programming/sleep_story.txt</a> </p><p>[sleep에 얽힌 이야기들]</p><p>작성: 이홍기(orinmir _at_ chonga _dot_ pe _dot_ kr; <a href="mailto:chonga@isoniconline.com">chonga@isoniconline.com</a>)</p><p>작성일: 2001년 7월 31일</p><p>1. 개요</p><p>&nbsp;&nbsp; 세상에는 sleep, usleep, nanosleep, select sleep, </p><p>&nbsp;&nbsp; 그리고 assembly clock 소모성 sleep이 존재한다. </p><p><br>2. 특징</p><p>&nbsp;&nbsp; sleep은 1초 단위 이상의 sleeping을 지원하며, thread에서는 안전하지 못하다.</p><p>&nbsp;&nbsp; usleep은 BSD 파생, nanosleep은 POSIX 표준이다.&nbsp; </p><p>&nbsp;&nbsp; select sleep은 좀더 유연한 플래폼 확장성을 가진다. (Windows 플래폼 제외)</p><p>&nbsp;&nbsp; 하지만 select를 이용한 sleep은 다른 sleep들에 비해 cpu clock을 더 많이</p><p>&nbsp;&nbsp; 먹을 수 밖에 없다는 단점이 있다. 게다가 unix 플래폼에서도 select 구현<br>&nbsp; <br>&nbsp;&nbsp; 방식에 따라 sleep time이 변화가 있다. (3. 결론 참고)<br>&nbsp;&nbsp; </p><p>&nbsp;&nbsp; nanosleep은 sleep이나 usleep에 비해 signal에 영향을 받지 않는다는 장점이 있다.</p><p>&nbsp;<br>&nbsp;&nbsp; 대부분의 UNIX OS(특히 Linux) kernel timer는 1/HZ정도로 맞추어져있으며, <br>&nbsp;&nbsp; <br>&nbsp;&nbsp; 한 thread내에서 sleep등으로 context switching이 일어날 경우 다른 thread를 </p><p>&nbsp;&nbsp; 수행하고 다시 현재의 thread로 돌아오는 시간은 최소 &gt; 10ms가 </p><p>&nbsp;&nbsp; 되며, 이것은 Intel Platform에서 지원하는 timer 주기와 맞물린다고 한다.</p><p>&nbsp;&nbsp; (이에 대해선 linux의 jiffies설정과 기타 문서 참조.)</p><p>&nbsp;&nbsp; 따라서 실제로 thread내에서 usleep이든, nanosleep이든 sleep할 수 있는 최소의</p><p>&nbsp;&nbsp; 시간은 &gt;1/HZ(10ms intel)가 되어야하며, 이것은 1/100초 즉, 10msec라고 할 수 있다.</p><p>&nbsp;&nbsp; 실제 sleep할 수 있는 시간은 10msec가 아닌 60msec정도가 한계인 경우(irix,solaris </p><p>&nbsp;&nbsp; 혹은 linux)도 있다.&nbsp; 이것은 또한 사용자 레벨에서 줄 수 있는 최소의 sleep time이라 </p><p>&nbsp;&nbsp; 볼 수 있다.</p><p>&nbsp;&nbsp; 하지만 nanosleep에서는 SCHED_RR이나 SCHED_FIFO (sched_setscheduler) 설정에 따라 <br>&nbsp;&nbsp; <br>&nbsp;&nbsp; busy-wait상태가 되면서 2ms 까지도 보장해준다고 한다. 이것은 time critical한 </p><p>&nbsp;&nbsp; 부분에서 쓰일 수 있다.</p><p><br>&nbsp;&nbsp; 좀더 자세한 사항은 man page를 참고.</p><p>&nbsp;&nbsp; man sleep<br>&nbsp;&nbsp; man usleep<br>&nbsp;&nbsp; man nanosleep</p><p><br>&nbsp;&nbsp; 마지막으로 assembly clock 소모성 sleep 에 대한 이야기인데 (busy-wait이다),</p><p>&nbsp;&nbsp; 이것은 주로 nop과 같은 1~3 cpu clock을 여러번 inline asm을 통해 호출함으로써</p><p>&nbsp;&nbsp; 얻을 수 있는 시간차를 사용하는 것이다. scheduling 방식에 따라 cpu intensive한</p><p>&nbsp;&nbsp; sleep일 수도 있다. 하지만 CPU와 architecture 등 하드웨어에 따라 clock수가<br>&nbsp;<br>&nbsp;&nbsp; 다르고 수행 시간이 틀려 통일성을 얻기 위해서는 다소 어려운 점이 있다.</p><p>&nbsp;&nbsp; 특히 포팅문제가. -.-;</p><p><br>3. 결론</p><p>&nbsp;&nbsp; 실제 sleep time은 예상한 시간보다 더 많이 sleep한다. (특히나 &lt;1s 용 sleep인 경우)<br>&nbsp;<br>&nbsp;&nbsp; gettimeofday를 이용한 time estimate 측정툴에 대한 결과는 다음과 같다.</p><p>&nbsp;&nbsp; sleep은 대상에서 제외된다.(1s 단위는 매우 잘 지켜진다. --;)</p><p><br>&nbsp;&nbsp; 실제로 우리가 원하는 &lt;1sec 시간을 설정하였음에도 불구하고, 시간은 제대로 </p><p>&nbsp;&nbsp; 지켜지지 않고, 약 +10%정도 추가 지연시간을 갖게 된다. 이렇게 되면 매우 힘들게 된다. -.-;<br>&nbsp; <br>&nbsp;&nbsp; FreeBSD와 Linux에서 동시에 테스트되었다. (소스 부록은 4. 부록편을 참조.)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_nanosleep(0,100000000L); //estimate time usleep : 0.109942<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 0.1sec보다 10%더 많이 쉬었다. -.-;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usleep(100000); // estimate time usleep : 0.109575<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 마찮가지다. 0.1sec보다 10%더 많이 쉬었다. -.-;</p><p>&nbsp;&nbsp; my_selectsleep(0,100000); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FreeBSD: estimate time usleep : 0.109907<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Linux: estimate time usleep : 0.099969<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FreeBSD는 select도 다른것들과 마찮가지다.</p><p><br>&nbsp;&nbsp; 이에 대한 테스트는 계속 진행중이며,</p><p>&nbsp;&nbsp; 당연하겠지만 가끔씩 시간이 원하는 sleep time의 2배까지 튀는 현상도 발생한다. <br>&nbsp;&nbsp; (Linux에 경우이다., FreeBSD에서도 10%이상 튀는 경우가 역시 발생한다.)</p><p>&nbsp;&nbsp; 역시 일반적인 설정으로는 time critical한 부분에서는 사용할 수가 없겠다는</p><p>&nbsp;&nbsp; 결론에 이른다. 좀더 테스트가 필요하다.</p><p><br>&nbsp;&nbsp; 한편, asm sleep은, nop 으로 1000개를 inline asm으로 발생시키는 경우</p><p>&nbsp;&nbsp; Pentium MMX 200 : nop 명령 38600000 번이 0.1s sleep<br>&nbsp;&nbsp; P3-500 1Mcache 4way : nop 명령 96500000 번이 0.1s sleep</p><p>&nbsp;&nbsp; busy-wait이므로 오래 wait을 하면 전체 process의 응답 속도에 엄청난 영향을</p><p>&nbsp;&nbsp; 미친다.</p><p><br>4. 부록</p><p>[sleep_functions.c]</p><p>// sleep functions<br>//<br>// Lee, Hongki &lt;orinmir _at_ chonga _dot_ pe _dot_ kr&gt; : <a href="http://chonga.pe.kr/">http://chonga.pe.kr</a></p><p>#include &lt;stdio.h&gt;<br>#include &lt;sys/time.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;sched.h&gt;<br>#include &lt;errno.h&gt;</p><p>int my_setsched(iPolicy);<br>&nbsp;&nbsp;&nbsp; struct sched_param p;<br>&nbsp;&nbsp;&nbsp; //int iPolicy=SCHED_RR;</p><p>&nbsp;&nbsp;&nbsp; p.sched_priority = sched_get_priority_max(iPolicy);<br>&nbsp;&nbsp;&nbsp; return sched_setscheduler(0,iPolicy,&amp;p);<br>&nbsp;&nbsp;&nbsp; // error when -1 return<br>&nbsp;&nbsp;&nbsp; // then check the errno.<br>}</p><p>// nanosleep wrapper function<br>void my_nanosleep(time_t sec,long nsec)<br>{<br>&nbsp;&nbsp;&nbsp; struct timespec req;</p><p>&nbsp;&nbsp;&nbsp; struct timespec rem;</p><p>&nbsp;&nbsp;&nbsp; if ((sec==0) &amp;&amp; (nsec==0)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req.tv_sec=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req.tv_nsec=999999999L; // 999 999 999<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req.tv_sec=sec;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req.tv_nsec=nsec; // 999 999 999<br>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; //rem.tv_sec=0;<br>&nbsp;&nbsp;&nbsp; //rem.tv_nsec=0;</p><p>&nbsp;&nbsp;&nbsp; //while (nanosleep(&amp;req, &amp;rem))<br>&nbsp;&nbsp;&nbsp; while (nanosleep(&amp;req, &amp;req))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (errno != EINTR)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return;<br>}</p><p><br>void my_selectsleep(int sec,int msec) {<br>&nbsp;&nbsp;&nbsp; struct timeval tv;<br>&nbsp;&nbsp;&nbsp; tv.tv_sec=sec;<br>&nbsp;&nbsp;&nbsp; tv.tv_usec=msec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; select(0,NULL,NULL,NULL,&amp;tv);<br>&nbsp;&nbsp;&nbsp; return;<br>}</p><p>&nbsp;</p><p>// 소모 cpu clock 측정<br>// system이 boot up된 이후에 수행된 clock을 담고 있다고 한다.<br>// 시작과 끝부분을 검사하면 되는 걸로 알고 있음.<br>__inline__ unsigned long long int rdtsc()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long int x;<br>&nbsp;&nbsp;&nbsp; __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));<br>&nbsp;&nbsp;&nbsp;&nbsp; return x;<br>}</p><p>// 테스트를 위한 inline asm busy wait sleep<br>__inline__ void asm_sleep(unsigned int sleepclocks) {</p><p>&nbsp;&nbsp;&nbsp; int i=0;<br>&nbsp;&nbsp;&nbsp; for (i=0;i&lt;sleepclocks;i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //__asm__ volatile ("nop ; nop ; nop ; nop");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; "); // 486 takes 1clock, 386 taks 3clocks<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return;<br>}</p><p>__inline__ void asm_sleep_1000nop() {</p><p>&nbsp;&nbsp;&nbsp; // 486 takes 1clock, 386 taks 3clocks<br>&nbsp;&nbsp;&nbsp; // 586 ?<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");<br>&nbsp;&nbsp;&nbsp; __asm__ volatile ("nop ; nop; nop; nop; nop; nop; nop; nop; nop; nop;");</p><p>&nbsp;return;</p><p>}</p><p><br>&nbsp;</p></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

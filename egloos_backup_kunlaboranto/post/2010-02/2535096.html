<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] [oracle] hang 문제를 해결하는 Systemstate dump</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2010-02-04 22:18:08</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] [oracle] hang 문제를 해결하는 Systemstate dump</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content"><br>From : http://www.dbguide.net/blog/post/post_list.jsp?page=3&amp;urlid=een&amp;cnum=null<br><br><span class="bold">hang 문제를 해결하는 Systemstate dump</span><br><br>오라클 데이터 서버를 운영하면서 hang현상이나 슬로우 퍼포먼스 문제를 만나게 되는 경우 v$session, v$process, v$session_wait,v$transaction, v$lock, dba_internal_locks, $latch, v$latchholder,v$db_object_cache, v$librarycache, v$sysstate 등과 같이 여러 딕셔너리 테이블들을 조회하여 문제해결을 위한 분석 작업을 하게 된다.<br>이렇게 딕셔너리 테이블들을 직접 조회하는 작업은 문제가 지속되고 있는 상황에서만 가능한 방법이기 때문에 운영 시스템의 가용성 측면에서 적용하기 어려운 경우가 있을 수 있다. 이경우Systemstate dump 분석방법을 사용할 수 있다. 즉, 문제 발생시 Systemstate dump를 수집하여 두고 우선 애플리케이션을 다시 구동하거나 오라클 데이터베이스를 다시 시작하는 등의 선 조치 후 수집된dump를 분석하는 것이다.<br>이렇게 딕셔너리 테이블들을 조회하지 않고 hang에 대한 원인 파악이 가능한 것은 Systemstate dump가 딕셔너리 테이블에 대한 정보가 담겨 있는 데이터베이스 스테이트에 대한‘스냅샷’이기 때문이다.<br><p>&nbsp;</p><br><p class="sub1">State Object</p><br><p><br>Systemstate dump는 오라클 인스탠스를 이루는 모든 프로세스들이 사용 중이던 스테이트 오브젝트들로 구성되어 있다.<br>스테이트 오브젝트는 오라클 프로세스들이 사용하는 메모리 저장소에 대한 기록이다. 오라클 백그라운드 프로세스 및 포그라운드들은 데이터베이스 오퍼레이션중 다양한 스테이트 오브젝트들을 사용하게 되며 프로세스가 종료될 때는 사용하던 스테이트 오브젝트들은 모두 정리가 되어야 한다. 만약 자신이 사용하던 스테이트 오브젝트들이 정리할 기회 없이 비정상적으로 종료되었을 경우 피온 프로세스가 대신 정리작업을 해 주게 되면 이 과정에서 이 데드 프로세스가 사용 중이던 락이나 트랜잭션을 정리하게 된다.<br><br></p><br><p><br></p><br><p class="sub1">SO(State Object) hierarchy</p><br><p><br>오라클 프로세스가 사용하던 스테이트 오브젝트는 아래와 같이 프로세스 오브젝트를 루트로 하는 계층 구조를 이루게 된다. Systemstate dump는 오라클 인스탠스를 이루고 있는모든 프로세스들에 대하여 프로세스 스테이트 오브젝트부터 시작하여 계층구조를 이루는 모든 차일드 스테이트 오브젝트들에 대한dump를담고있다.</p><br><p><img src="http://www.dbguide.net/images/know/tech/061222_du_01.jpg" width="500" height="340"></p><br><p><b>&lt;그림 1&gt; Process state object hierarchy</b></p><br><p class="sub1"><br>SO common header</p><br><p><br><br>모든 스테이트 오브젝트는 아래와 같이 공통된 헤더를 갖는다.<br><br></p><br><p>.SO : state object address<br>SGA내에 위치하는 스테이트 오브젝트에 대한 주소로 SO에 대한 ID로 사용될 수 있다.<br>.Type : state object type<br>.Owner : parent state object address<br>Parent state object의 주소를 담고 있어 이 값을 사용하여 프로세스 스테<br>이트 오브젝트들에 대한 계층 구조를 파악할 수 있다.<br></p><br><p class="sub1">&nbsp;</p><br><p class="sub1">hang 상황 재연</p><br><p><br><br>이제부터는 특정 hang 현상을 시나리오에 따라 발생시킨 후 수집된<br>Systemstate dump를 분석하는 과정을 설명해 보겠다.<br><br></p><br><p>&nbsp;</p><br><p class="sub1">Hang Scenario</p><br><p><br><br>Systemstate dump 분석 사례를 설명하기 위하여 미리 작성된 시나리오에 의하여 hang 상황을 연출해 보겠다.</p><br><p><br><strong>사전 준비<br></strong><br>아래와 같이 테스트에 사용될 스키마 오브젝트들을 생성해 둔다.<br></p><p class="sourcebox"><sql setup="" case="" test="" 1.=""><br>SQL&gt; Create table Employee(empno number, ename varchar2(200), deptno<br>number);<br>SQL&gt; Insert into Employee values(1, ''홍길동'', 10);<br>SQL&gt; Commit;<br>SQL&gt; Create or replace procedure deleteEmployee(eno number)<br>Is<br>Begin<br>Delete Employee where empno = eno;<br>End;<br>/</sql></p><br><br><p><img src="http://www.dbguide.net/images/know/tech/061222_du_02.jpg" width="500" height="413"></p><br><p><b>&lt;그림 2&gt; Hang Scenario<br></b></p><br><p><br><strong>작업 절차</strong><br><br>.T1-Session 1<br>transaction T1 이 시작되고 Employee table에 대하여 TM lock과 empno=1 row에 row level lock이 잡히게 된다.<br><br>.T2-Session 2<br>deleteEmployee procedure에서 empno=1인 Employee table의 열을 삭제하려는 과정에서 이 열이 이미 T1에 의하여 row level lock이 걸려 있어 T1이 종료되기를 기다리게 된다.<br><br>이때 Session 2는 처리절차에 있으므로 deleteEmployee procedure에대하여 역할 모드의 라이브러리 캐시 핀을 소유하게 된다.</p><p><br>.T3-Session 3<br>pl/sql 컴파일 과정에서 해당 라이브러리 오브젝트에 대하여 라이브러리 캐시 락 과 핀이 필요하게 된다. deleteEmployee procedure에 대하여 개별상태로 라이브러리 캐시 락을 승인 받은 후 개별상태의 핀을 모으는 과정에서 Session 2가 이미 소유하고 있으므로 이 공유상태의 핀이 해제될 때를 기다리게 된다.<br></p><br><p class="sourcebox"><sql lock="" cache="" library="" 3.=""><br>X$kgllk를 조회한 결과<br>SQL&gt; SELECT s.sid, KGLLKHDL "Handle", lco.KGLNAOBJ, kgllkmod "Mode",<br>KGLLKREQ "Req", SPID "OS Process" , KGLLKSQLID<br>FROM v$session_wait w, x$kgllk l, x$kglob lco, v$session s,<br>v$process o<br>WHERE l.kgllkuse=s.saddr<br>AND kgllkhdl=w.p1raw<br>and w.event like ''%library cache lock%''<br>and s.paddr=o.addr<br>and lco.KGLHDADR = l.KGLLKHDL<br>/<br>SID Handle KGLNAOBJ Mode Req OS Process<br>----------- ---------------- -------------------- -------- ------- -----------------<br>143 C00000004FDA0438 DELETEEMPLOYEE 3 0 14400<br>147 C00000004FDA0438 DELETEEMPLOYEE 0 2 13102<br>147 C00000004FDA0438 DELETEEMPLOYEE 1 0 13102<br>% DELETEEMPLOYEE library cache object에 대하여 X mode로 잡고 있는 143<br>Session으로 인하여 147 Session이 S mode로 기다리고 있음.<br></sql></p><br><p><br><br>&nbsp;</p><p class="sub2">Systemstate dump 수집</p><br><p><br><br>Systemstate dump를 받는 명령은 여러 가지 방법들이 있으나 주로 아래의 두 가지 방법들을 사용한다.<br></p><p class="sourcebox">* ‘Alter session’command 사용<br>SQL&gt; alter session set events ‘immediate trace name systemstate level 10’;<br>* Oradebug tool 사용<br>SQL&gt; oradebug setmypid<br>SQL&gt; oradebug dump systemstate 10</p><br>hang문제 발생 시 블로커나 대기자가 변하는지를 파악하기 위하여 여러 번의 dump를 받게 된다. Trace file은 user_dump_dest directory에 생성된다.<br><br><p>&nbsp;</p><br><p><br>Systemstate 분석</p><p><br><br>hang 문제의 경우 우선 non-idle wait event상태에서 기다리고 있는 프로세스들을 먼저 파악하고 이 프로세스들이 기다리고 있는 자원을 소유하고 있는 blocking process들을 확인하는 작업을 하게 된다. 우리는 이미 hang현상에 대한 시나리오를 잘 알고 있기에 Session 4의 session state dump부터 확인하여 blocking session들을 추적해 보겠다.</p><p>&nbsp;</p><br><p class="sub2"><br>Session 4 SO analysis</p><br><p><br><img src="http://www.dbguide.net/images/know/tech/061222_du_03.jpg" width="487" height="1244"> <br></p><br><p>예상한대로 이 Session의 wait event가‘library cache lock’임을 보여주고 있다. 이 wait event의 파라미터 중 handle address와lock address를 이용하여 이 library cache lock에 대한 정보를 찾아 정리해 보았다.</p><br><p class="sourcebox">1. (process) - SO type description.<br>Oracle pid - v$process의 pid로 oracle process id를 의미.<br>2. ospid - oracle process의 OS PID<br>3. SID - v$session의 SID를 의미<br>4. user - 접속한 DB schema 이름<br>5. user - client의 OS account 이름<br>ospid - client process의 OS PID<br>machine - client machine 이름<br>6. program - client prograom 이름<br>7. request - library cache lock을 share mode로 request.<br>만약 library cache lock을 share mode로 소유하고 있는 상태라면 mode=S 로 표시될 것이다.<br>8. library cache lock 의 대상이 되는 LCO handle<br>모든 library cache lock/pin은 그 대상이 되는 LCO를 갖는데 이 LCO의 handle이 그 LCO에 대한 Identifier 역할을 하게 된다.<br>9. LCO 이름이 SCOTT.DELETEEMPLOYEE 임<br></p><br><p><br>위 프로세스 16의 SO dump에서와 <sql 3.="" cachelock”="" “library="">의 결과 모두 oracle process 13102 가 공유상태의 Library cache lock을 기다리고 있는 상황임을 설명하고 있음을 알 수 있다.<br><br>이제 OSPID 13102 process 가 기다리고 있는 Library cache lock에 대한 블로커를 찾아 보도록 하겠다. 위 dump 내용에서 library cache lock의 대상이 되는 LCO handle ddress가 c0000-0004fda0438였으므로 이 주소를 사용하여 SCOTT.D-ELETEEMPLOYEE LCO에 대한 library cache lock들을 조사해 본다.</sql></p><br><p>&nbsp;</p><br><p class="sub2"><br>Session 3 SO analysis</p><br><p><br><br>library cache lock dump들을 조사하던 중 LCO handle c00000004 fda0438에X mode의 library cache lock이걸려있는 내용을 찾아 아래의 내용들을 파악했다.<br><br><img src="http://www.dbguide.net/images/know/tech/061222_du_04.jpg" width="500" height="429"></p><br><p class="sourcebox">1. eXclusive mode로 library cache lock을 소유<br>2. 위 library cache lock을 소요하고 있는 Session SO에서 이 Session이 library cache pin을 기다리고 있는 상태임을 확인<br>3. library cache pin에 대한 대상 LCO handle address<br>4. oracle server process의 OS PID가 14400<br>5. library cache pin을 eXclusive mode로 request<br><br>dump 내용에서 이 14400이 LCO handle address가 c00000004 fda0438인 LCO에 대하여 라이브러리 캐시 핀을 eXclusive mode로 기다리고 있는 상태임을 확인했다. 이 주소를 사용하여 이LCO 에 대하여 라이브러리 캐시 핀을 소유하고 있는 내용을 찾아보았다.</p><br><p>&nbsp;</p><br><p>Session 2 SO analysis</p><br><p><br><br>OSPID 14400 process의 Session이 기다리고 있는 라이브러리 캐시 핀의 LCO handle address를 가지고 조사한 결과 아래의 SO들을 찾을 수 있었다.<br><br></p><br><p><img src="http://www.dbguide.net/images/know/tech/061222_du_05.jpg" width="362" height="605"></p><br><p>1. OSPID 14400 프로세스의 Session이 기다리던 library cache handle에 대하여 공유상태로 라이브러리 캐시 핀을 잡고 있음.<br>2. 이 Session은 TX lock이 해제되기를 기다리고 있음.<br></p><br><p class="sourcebox">&lt;참고 1&gt;TX enqueue wait event의 parameter에서 XID 확인<br>TX Enqueue wait Event parameter P1, P2, P3에서 기다리고 있는 Transaction ID를 유추하여 보면 아래와 같다.<br>Enqueue wait event의 P1, P2, P3<br>P1 (lock type &amp; mode) - 54580006<br>ORACLE KOREA MAGAZINE<br>P2 (lock ID1) - 90022<br>P3 (lock ID2) - 19e<br>TX lock의 ID1, ID2<br>ID1 - (Undo Segment Number &lt;&lt; 16)+Undo Slot<br>ID2 - Sequence Number<br>위 format에 따라 wait event의 enqueue type 과 XID를 계산<br>Lock type = 5458 (''TX'')<br>Lock mode = 6 (eXclusive)<br>Usn : parameter2의 16진수 값 중 상위 4자리 ==&gt; 9<br>Slot : parameter2의 16진수 값 중 하위 4자리 ==&gt; 0x22<br>Seq : parameter3 ==&gt; 0x19e<br>Xid = 9.22.19e<br></p><br><p>3. wait event ''enq: TX - row lock contention'' 의 parameter들로 구성한 resource name과 동일<br>4. TX-00090022-0000019E enqueue를 X mode로 기다리고 있음.</p><br><p>이제 이 TX enqueue를 소유하고 있는 블로커를 찾아보기로 한다. Enqueue에 대한 대기자나 블로커를 조사하려면 enqueueresource name을 사용하면 되므로 TX-00090022-0000019E를 search keyword로 관련 사항들을 찾아보았다.<br><br><img src="http://www.dbguide.net/images/know/tech/061222_du_06.jpg" width="358" height="750"></p><br><p>1. &lt;참고 1&gt; ''TX enqueue wait event의 parameter에서 XID 확인'' 에서 확인<br>하였던 XID와 일치하고 있다.<br>2. enqueue resource name 이 Session 2가 기다리고 있던 enqueue name과 동일하다.<br>3. 이 session이 TX-00090022-0000019E lock을 eXclusive mode로 잡고 있다.<br>4. Session wait event가 ''''SQL*Net message from client'' 로 클라이언트로부터 메시지를 기다리고 있는 정지 상태임.<br>5. 이제까지 설명했던 모든 대기자들에 대한 root cause인 블로커가 OS PID 9729 process임을 알았다.<br></p><br><p>&nbsp;</p><br><p class="sub1">결론</p><br><p>실제로 Oracle support engineer들은 Systemstate dump를 이용한 분석 작업을 자주 하고 있다. 그 이유는 Oracle code상으로 준비된 진단기능 중에 특정 예외상황, 즉 ORA-600 [2103] 이나 ORA-29740과 같은 에러 발생 시 Systemstate dump를 발생시키는 디버깅 기능을 두고 있기 때문이기도 하지만 Systemstate dump가 Systemstate의 스냅샷을 제공하기 때문에 hang 문제나 slow performance 문제 발생 시 가장 유용한 정보를 주기 때문이다.<br>지금까지 hang 문제 발생 상황에서 Systemstate dump를 사용한 분석 사례를 설명해 보았다. 지면 관계상 Systemstate dump에 담겨 있는 많은 정보들을 모두 설명하지는 못했지만 Systemstate dump를 사용하는 목적과 분석 과정을 조금이나마 이해하는데 도움이 되기를 기대한다.</p><br><p>&nbsp;</p> <p><a href="http://www.dbguide.net/" target="_blank"><b><font color="midnightblue">제공 : DB포탈사이트 DBguide.net </font></b></a></p><p>출처명: 한국 오라클                            </p>                                                                                                                출처명 : 한국 오라클<br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

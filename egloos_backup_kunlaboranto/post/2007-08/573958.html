<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] [sun] 코어 덤프 관리</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2007-08-23 08:53:17</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] [sun] 코어 덤프 관리</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">From : http://www.sdnkorea.com/blog/392<br><br><div class="titleWrap"><h2><a href="http://www.sdnkorea.com/blog/392">코어 덤프 관리</a></h2><span class="category"><a href="http://www.sdnkorea.com/blog/category/%EC%86%94%EB%9D%BC%EB%A6%AC%EC%8A%A4/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%BD%94%EB%84%88">솔라리스/개발자코너</a> </span><span class="date">2007/06/13 10:02</span></div><!-- titleWrap close --><div class="article"><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="smaller" valign="top"><em>Adam Zhang, 썬 마이크로시스템즈, 2007년 4월</em></td><td width="10">&nbsp;</td><td align="right" valign="bottom"><div class="sitelinks" style="padding: 0px;"><table border="0" cellpadding="0" cellspacing="0"><tbody></tbody></table></div><br></td></tr></tbody></table><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="http://www.sun.com/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p><b>요약:</b> 프로세스의 비정상적인 종료는 코어 덤프 파일을 생성하도록 합니다. 코어 덤프 파일은 프로그래머 혹은서포트 엔지니어들에게 비정상적인 종료의 원인이 무엇인지 결정하는데 큰 도움을 줍니다. 왜냐하면 이 파일은 크래시 타임시의 런타임상태에 대한 가치를 따질 수 없는 정보를 제공하기 때문입니다. 이 글은 코어 덤프에 대한 정보를 제공하고 솔라리스 운영체제에서코어 덤프를 관리하는데 사용 될 수 있는 기능들과 분석툴들에 대해 설명합니다.</p><p><b><i>주의:</i></b> 이 글에 포함된 정보는 주로 솔라리스10을 위한 것입니다.</p><p><b>순서:</b></p><ul><li>코어 덤프의 종류들: 프로세스와 시스템 </li><li>프로세스 코어 덤프의 원인 </li><li>프로세스 코어 덤프를 관리하는 방법 </li><li>프로세스 코어 덤프를 수동으로 생성하는 방법 </li><li>프로세스 코어 덤프 파일을 분석하는 방법 </li><li>시스템 코어 덤프의 원인 </li><li>시스템 코어 덤프가 생성되는 방법 </li><li>시스템 코어 덤프를 관리하는 방법 </li><li>시스템 코어 덤프를 수동으로 생성하는 방법 </li><li>시스템 코어 덤프 파일을 분석하는 방법 </li><li>참고자료 </li></ul><div><b>코어 덤프의 종류들: 프로세스와 시스템</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>코어 덤프는 파일로써 프로세스에 대한 내용과 더불어 프로세서 레지스터의 값 같은 다른 유용한 정보들이 같이 저장되어있습니다. 두가지 종류의 코어 덤프가 존재 하는데: 시스템 코어 덤프와 프로세스 코어 덤프가 바로 그것입니다. 이것들은 여러가지측면에서 특히 생성되는 방법과 이것들을 분석하는 방법에 있어서 큰 차이가 있습니다.</p><div><b>프로세스 코어 덤프의 원인</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>어플리케이션 프로세스가 특정한 시그널을 받고 종료 됐을때 시스템은 코어 덤프를 생성하고 프로세스를 정지 시킵니다. 대부분의 경우 어플리케이션을 크래쉬로 이끄는 시그널은 <code>SIGSEGV</code> 혹은 <code>SIGBUS</code> 입니다. </p><p><code>SIGSEGV</code> 는 어플리케이션이 비정상적인 메모리 주소에 접근하고 있는 것을 가르킵니다. 이러한 상황은 C/C++ 프로그램에서 포인터 조작이 잘못됐을때 자주 발생합니다.</p><p>솔라리스에서 여러분은 <code>libumem(3LIB)</code> 라이브러리를 유저-모드 메모리 할당자로써 <code>libc</code> 대신 사용할 수 있습니다. <code>libumem</code>라이브러리는 메모리 누출, 버퍼 오버플로우, 할당해제된 데이타에 대한 접근 시도, 그리고 수 많은 메모리 할당 에러들을 찾는데도움을 줍니다. 또한 메모리 할당자로써 매우 빠르고 멀티쓰레드 어플리케이션에서 확장성이 뛰어 납니다. </p><p><code>SIGBUS</code> 는 어플리케이션이 CPU 메모리 정렬 규칙을 따르지 않는 메모리 주소에 접근할때발생합니다. 이것은 보통 UltraSPARC 프로세서에서 자주 발생합니다. x86/x64 CPU 의 시스템들은 정렬되지 않은메모리 주소를 다룰 수 있지만 퍼포먼스의 문제가 발생합니다.</p><p>썬 스튜디오 C/C++ 컴파일러는 <code>-xmemalign</code> 옵션을 가지고 있어서 컴파일 타임에서 식별해 낼 수 있는 정렬되지 않은 메모리 주소들이 있을때 UltraSPARC CPU 에서의동작을 조정하는데 사용할 수 있습니다. <code>-xmemalign</code> 옵션은 컴파일러가정렬되지 않은 메모리의 접근에 대해 추가적인 load/store 명령을 생성하도록 합니다. 그러나 <code>-xmemalign</code> 옵션은 런타임시의 정렬되지 않은 메모리 접근을 다루지는 못합니다. 만약 정렬되지 않은 메모리에 대한 접근이 런타임시에 발생한다면 개발자는 소스 코드를 수정해야 한다.</p><p>기본적인 목적이 코어 덤프를 생성하는 다른 시그널들이 존재 합니다. 예를 들어 <code>SIGFPE</code> 는 부동 소숫점 예외를 가르 킵니다. <code>Signal</code>(3HEAD) 멘 페이지에서 좀 더 자세한 정보를 제공하고 있습니다.</p><div><b>프로세스 코어 덤프를 관리하는 방법</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>솔라리스는 3가지의 코어 덤프 파일을 각각의 비정상적으로 종료된 프로세스마다 생성하려고 시도 합니다. 코어 덤프 파일중에하나는 프로세스별(per-process) 코어 파일로 불리고 현재 디렉토리에 위치하게 됩니다. 다른 코어 덤프 파일은 글로벌코어 파일로 불리고 시스템 전역의 장소에 생성됩니다. 만약 프로세스가 로컬 존에서 실행되고 있다면 3번째 코어 파일은 글로벌존에 생성 됩니다.</p><p>여러분은 <code>coreadm(1M)</code> 커맨드를 이용해서 코어 덤프 파일을 관리할 수 있습니다. 모든 설정은 <code>/etc/coreadm.conf</code> 설정 파일에 저장됩니다.</p><p>아래는 전형적인 시나리오로 코어 덤프에 대한 현재 시스템의 설정을 보여 줍니다:</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>-bash-3.00# coreadm<br>     global core file pattern:<br>     global core file content: default<br>       init core file pattern: core<br>       init core file content: default<br>            global core dumps: disabled<br>       per-process core dumps: enabled<br>      global setid core dumps: disabled<br> per-process setid core dumps: disabled<br>     global core dump logging: disabled<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>이전의 출력에서:</p><ul><li><code>global core dumps: disabled</code> 는 어떠한 글로벌 코어 덤프도 생성되지 않을 것임을 가르킴. </li><li><code>per-process core dumps: enabled</code> 는 프로세스별 코어 덤프가 각각의 비정상적인 프로세스마다 생성될 것임을 가르킴. </li><li><code>init core file pattern</code> 는 내용이 살아 있는 프로세스 부터 프로세스-별 코어 덤프까지의 정보를 모두 취합할 것임을 가르킴. </li></ul><p>또한 <code>coreadm</code> 커맨드를 통해서 코어 덤프 파일 이름을 조정할 수 있습니다:</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>-bash-3.00# coreadm -i core.%f.%p<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>이 커맨드는 프로세스-별 코어 파일 이름에 프로그램 파일 이름 <code>(%f)</code> 과 런타임 프로세스 ID <code>(%p)</code> 를 추가시킨 것입니다. 코어 덤프 파일은 프로세스의 현재 작업 디렉토리에 생성될 것입니다.</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>-bash-3.00# coreadm -g /globalcore/core.%f.%p -e global<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>기본적으로 글로벌 코어 덤프는 비활성화 되어 있습니다. 여러분은 <code>coreadm</code> 커맨드를 <code>-e global</code> 옵션을 주고 실행해서 활성화 시킬 수 있습니다. <code>-g</code> 옵션은 프로그램 이름 <code>(%f)</code> 과 런타임 프로세스 ID <code>(%p)</code> 를 코어 파일 이름에 추가시키도록 할 수 있습니다. </p><p>이전에 언급했던 대로 <code>coreadm</code> 은 코어 파일에 저장될 프로세스의 부분을 지정할 수 있습니다.이전에서 만약 사후 분석을 수행한다고 했을때 여러분은 의존 라이브러리들과 런타임 모듈들의 모든 버전 정보들을 얻을 필요가 있을것입니다. 왜냐하면 코어 덤프 파일은 이러한 정보를 포함하고 있지 않기 때문입니다. 프로그래머가 본래 머신의 환경과 똑같은환경을 재생성하는 것은 매우 어려운 일입니다.</p><p>기본적인 설정으로 솔라리스는 "기본" 패턴을 각각의 프로세스 코어 덤프에 적용하는데 이 것은 즉 프로세스 코어 덤프가스택, 힙, 텍스트, 공유 메모리(SHM), intimate 공유 메모리(ISM), 그리고 동적인 intimate 공유메모리(DISM) 정보와 다른 정보들을 모두 포함하게 됩니다. 프로세스 코어 덤프 파일의 텍스트 부분은 또한 어떠한 의존라이브러리들도 없이 코어 파일로 부터 직접 읽기가 가능한 스택 트레이스를 얻을 수 있도록 도와 주는 부분적인 심볼테이블(dynsm)을 포함 합니다. 만약 dynsm 이 불충분하다면 <code>coreadm</code> 을 이용해서 모든 심볼 테이블을 포함하도록 할 수 있습니다: </p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>-bash-3.00# coreadm -G all -i all<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>이전의 커맨드는 글로벌 코어 파일 (<code>-G</code>) 과 프로세스-별 코어 파일 (<code>-i</code>) 이 프로세스의 모든 부분을 포함하도록 합니다.</p><p><code>coreadm</code> 을 이용해서 변경이 올바르게 되어 있는지 확인합니다:</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>-bash-3.00# coreadm<br>     global core file pattern: /globalcore/core.%f.%p<br>     global core file content: all<br>       init core file pattern: core.%f.%p<br>       init core file content: all<br>            global core dumps: enabled<br>       per-process core dumps: enabled<br>      global setid core dumps: disabled<br> per-process setid core dumps: disabled<br>     global core dump logging: disabled<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p><code>coreadm</code> 커맨드는 <code>coreadm</code> 서비스의 설정 파일을 수정하는데 사용되고 이것은 서비스 관리 설비(SMF) 에서 다음과 같은 서비스 인식자를 가집니다: <code>svc:/system/coreadm:default</code>. </p><div><b>프로세스 코어 덤프를 수동으로 생성하는 방법</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>솔라리스는 분석의 목적을 위해서 현재 실행되고 있는 라이브 프로세스의 코어 덤프를 생성할 필요가 있을때를 위해서 <code>gcore(1)</code> 커맨드를 제공합니다:</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>-bash-3.00# echo $$<br>2770<br>-bash-3.00# gcore $$<br>gcore: core.2770 dumped<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>라이브 프로세스 ID가 생성되는 코어 덤프 파일에 자동적으로 추가 됩니다. 이전의 예제에서 현재 쉘의 프로세스가 덤프 됐고 프로세스 ID 는 2770 입니다. </p><p><b><i>주의:</i></b> 코어 덤프를 생성할때 고려해야할 몇가지 제약 조건들이 있습니다. 예를 들어 목적 디렉토리의 퍼미션, 목적 디렉토리의 존재 여부, 파일 시스템의 마운트 옵션, 그리고 프로세스의 리소스 제한 등 입니다. 리소스 제한에 대한 정보는 <code>setrlimit</code>(2) 과 <code>ulimit</code>(1) 을 참고하시기 바랍니다. </p><div><b>프로세스 코어 덤프 파일을 분석하는 방법</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>솔라리스에는 코어 덤프 파일을 분석하는 수 많은 툴들이 존재 합니다: <code>dbx(1)</code>, <code>mdb(1)</code>, 그리고 <code>pstack(1)</code>. 가장 편리한 방법은 <code>pstack</code> 툴을 이용해서 프로세스의 스택을 검사하는 것입니다. 이 툴은 멀티쓰레드 프로그램의 정보 또한 보여 줍니다:</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre> -bash-3.00# pstack core.2580  | more<br> core 'core.2580' of 2580:       java_vm<br> -----------------  lwp# 1 / thread# 1  --------------------<br>  fef40a27 read     (b, 804280c, 1)<br>  feb11ba8 __1cDhpiEread6FipvI_I_ (b, 804280c, 1) + a8<br>  feb11aef JVM_Read (b, 804280c, 1) + 2f<br>  fe77045e ???????? (80685b8, 8042864, 22)<br>  ...<br>  feb1d55c jni_CallStaticVoidMethod (80685b8, 8069020, 80e8355,<br>0) + 14c<br>  080516c2 main     (2, 8047168, 8047174) + 50c<br>  08050daa ???????? (2, 80472cc, 80472d4, 0, 80472d5, 8047301)<br> -----------------  lwp# 2 / thread# 2  --------------------<br>  fef40d27 lwp_cond_wait (8067ae8, 8067ad0, fb3a9c08, 0)<br>  fef2de3f _lwp_cond_timedwait (8067ae8, 8067ad0, fb3a9c50) + 35<br> ...<br>  fef3fc32 _thr_setup (fef82400) + 4e<br>  fef3ff20 _lwp_start (fef82400, 0, 0, fb3a9ff8, fef3ff20,<br>fef82400)<br> -----------------  lwp# 3 / thread# 3  --------------------<br>  fef40d27 lwp_cond_wait (8116588, 8116570, 0, 0)<br>  feab737c __1cCosHSolarisFEventEpark6M_v_ (8116548) + 4c<br> ...<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>일반적으로 프로그램의 심볼 테이플이 strip 되지 않았고 런타임 스택 트레이스가 사용 가능하다면 여러분은 문제의 50 퍼센트 이상이 해결되었다고 생각해도 됩니다. </p><p><code>dbx</code> 는 썬 스튜디오 소프트웨어의 의해 무료로 제공 되는 소스-레벨 디버깅 툴입니다. 썬 스튜디오소프트웨어는 솔라리스와 리눅스에서 무료로 사용할 수 있는 최적화된 C, C++, Fortran 컴파일러를 포함하고 있습니다.dbx 는 프로그램의 상태를 조사할 뿐만 아니라 프로그램의 퍼포먼스 데이타 또한 수집합니다. 아래에 코어 파일을 dbx 를이용해서 분석하는 전형적인 시나리오가 있습니다. dbx 에 대한 좀 더 자세한 정보는 <a href="http://docs.sun.com/app/docs/doc/819-3683">Sun Studio 11: Debugging a Program With dbx</a> 문서를 참고하시기 바랍니다. </p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>  -bash-3.00# /opt/SUNWspro/bin/dbx   tServer   core<br>  For information about new features see 'help changes'<br>  To remove this message, put 'dbxenv suppress_startup_message 7.5'<br>in your .dbxrc<br>  Reading tServer<br>  core file header read successfully<br>  Reading ld.so.1<br>  Reading libpthread.so.1<br>  Reading librt.so.1<br>  Reading libsocket.so.1<br>  Reading libnsl.so.1<br>  Reading libc.so.1<br>  Reading libthread.so.1<br>  Reading libCrun.so.1<br>  Reading libm.so.1<br>  Reading libkstat.so.1<br>  t@1 (l@1) program terminated by signal SEGV (no mapping at<br>the fault address)<br>  0xffffffff7ce3ce90: strcmp+0x0014:      ldub     [%i1], %i5<br>  Current function is txnAtomMatchRqst<br>    177  &amp;&amp; strcmp(pMsg-&gt;inHeader.msgVer, "01" == 0)) {<br>  (dbx) threads                    ** show all the threads<br>  o&gt;    t@1  a  l@1   ?()   signal SIGSEGV in  strcmp()<br>     t@2  b  l@2   tTimerThread()   LWP suspended in  __pollsys()<br>  (dbx) thread -info t@1           ** show the thread information<br><br>    Thread t@1 (0xffffffff7a500000) at priority 0<br>    state: active on    l@1<br>    base function: 0x0: 0x0000000000000000() stack:<br>0xffffffff80000000[8388608]<br>    flags: (none)<br>    masked signals: (none)<br>    Currently active in strcmp<br>  (dbx) where                      ** show the thread stack<br>  current thread: t@1<br>   [1] strcmp(0x100263d63, 0x0, 0xac, 0x0, 0x30, 0x31), at<br>0xffffffff7ce3ce90<br>  =&gt;[2] tAtomMatchRqst(), line 177 in "tAtomMatchRqst.c"<br>   [3] tFlow(), line 96 in "tFlow.c"<br>   [4] tServer(rqst = 0x1001e6c58), line 73 in "tServer.c"<br>   [5] _tsvcdsp(0x1700, 0x0, 0x10004ca60, 0x1001e55c0, 0x0,<br>0x1001d9440), at 0xffffffff7e15d138<br>   [6] _trunserver(0x1001e3844, 0x1001da958, 0x0,<br>0xffffffff7e3525c8, 0x1400, 0x1001ee400), at 0xffffffff7e180ea0<br>   [7] _tstartserver(0x0, 0xffffffff7ffff568, 0x1001bcc38,<br>0x1001d9440, 0x0, 0x0), at 0xffffffff7e15be28<br>   [8] main(0xf, 0xffffffff7ffff568, 0xffffffff7ffff5e8, 0x0,<br>0x0, 0x100000000), at 0x1000099ec<br>  (dbx) quit<br>  -bash-3.00#<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>이전의 예제에서 여러분은 dbx 를 사용해서 비정상적인 쓰레드를 "o," 마크를 통해서 확인 할 수 있고 소스 코드를 보여줌으로써 근본 원인을 알아낼 수가 있었습니다. 물론 이것은 여러분의 어플리케이션 소스 코드와 컴파일 단계에서 디버그 정보 추가를하지 않았다면 불가능했을 것입니다.</p><p>여러분이 어셈블리 언어, 하드웨어 특성과 친숙하다면 <code>mdb</code> 를 사용해서 코어 파일을 디버그 할 수 있습니다. 왜냐하면 <code>mdb</code> 는 저-레벨 디버깅 유틸리티로 솔라리스 OS 자체와 프로그램을 양쪽에서 모두 쓸 수 있습니다.</p><div><b>시스템 코어 덤프의 원인</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>솔라리스가 크래쉬되고 코어 덤프를 생성하는 데에는 수 많은 이유들이 존재 합니다. 소프트웨어 적인 문제 즉 드라이버나 프로그램 뿐만 아니라 하드웨어 오류 자체도 시스템의 코어 덤프를 유발할 수 있습니다.</p><div><b>시스템 코어 덤프가 생성되는 방법</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>데이타 무결성이 훼손됐거나 하드웨어에서 오류가 발생한 것을 감지 한다면 솔라리스는 <code>panic()</code> 을 호출합니다. <code>panic()</code> 루틴은 마치 OS 가 정지한 것처럼 모든 프로세스들을 인터럽트 합니다. 이때 메모리 상의 OS 를 그대로 복사한 시스템 코어 덤프를 생성하고 이것을 덤프 디바이스에 저장 합니다. 크래쉬 후에 운영체제는 <code>savecore(1)</code> 를 통해서 덤프 디바이스로 부터 코어 덤프를 <code>savecore</code> 디렉토리로 다음 번 부팅 동안 가져 옵니다. <code>savecore</code> 루틴은 두가지 파일을 생성합니다. 하나는 <code>unix.&lt;X&gt;</code> 로 OS 심볼 테이블 이고 다른 하나는 <code>vmcore.&lt;X&gt;</code> 로 코어 덤프 데이타 파일 입니다. 기본적으로 덤프 디바이스는 swap 파티션이고 <code>savcore</code> 디렉토리는 <code>/var/crash/&lt;hostname&gt;</code> 으로 설정되어 있습니다. 파일이름 끝에 붙는 <code>&lt;X&gt;</code> 는 정수로 <code>savecore</code> 가 매번 돌때 마다 증가합니다.</p><div><b>시스템 코어 덤프를 관리하는 방법</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>여러분은 <code>dumpadm(1M)</code> 을 사용해서 덤프 디바이스와 <code>savecore</code> 디렉토리를 관리할 수 있습니다:</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>-bash-3.00# dumpadm -d /dump  -s /savecore<br>      Dump content: kernel pages<br>      Dump device: /dump (dedicated)<br>Savecore directory: /savecore<br>Savecore enabled: yes<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>변경 사항을 점검하거나 현재의 설정을 보기 위해 아무런 옵션 없이 <code>dumpadm</code> 만을 사용합니다:</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>-bash-3.00# dumpadm<br>      Dump content: kernel pages<br>      Dump device: /dump (dedicated)<br>Savecore directory: /savecore<br>Savecore enabled: yes<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>여러분은 <code>dumpadm</code> 을 이용해서 덤프의 내용을 설정할 수 있고 <code>savecore(1)</code> 작업을 부트시간 동안에 활성화 할 수 있습니다. operation during the boot.</p><p>모든 설정 정보들은 <code>/etc/dumpadm.conf</code> 설정 파일에 저장 됩니다. 시스템 크래쉬 덤프 서비스는 또한 SMF 로 관리되고 서비스 인식자는 다음과 같습니다: <code>svc:/system/dumpadm:default</code>.</p><div><b>시스템 코어 덤프를 수동으로 생성하는 방법</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>어떤 경우에 여러분은 코어 덤프 파일을 수동으로 저장해서 현재 라이브 시스템의 스냅샷을 취할 필요가 있습니다. 솔라리스에서 사용할 수 있는 여러가지 방법들이 있습니다. 예를 들어 <code>reboot -d</code> 를 이용해서 재부팅과 동시에 코어 덤프의 생성을 강제할 수 있습니다. 혹은 <code>savecore -L</code> 을 이용해서 라이브 OS 코어 덤프를 생성할 수 있습니다. 만약 <code>savecore(1M)</code> 를 이용해서 라이브 코어 덤프를 생성하길 원한다면 여러분은 반드시 <code>dumpadm</code> 을 사용하여 non-swap 디바이스를 덤프 디바이스로 설정해줘야 합니다. 왜냐하면 라이브 코어 덤프는 swap 디바이스를 가상 메모리의 일부로 사용하기 때문입니다.</p><p>종종 시스템은 크래쉬 없이 멈출 경우가 있습니다. 만약 썬 UltraSPARC 프로세서 기반의 머신을 사용한다면 Stop-A 를 눌러서 OpenBoot PROM (OBP) 모드로 들어갈 수 있고 <code>sync</code> OBP 커맨드를 통해서 크래쉬 코어 덤프를 강제로 생성해 줄 수 있습니다.</p><p>x86 플랫폼에서는 해당되는 OBP 유닛이 없습니다. 그러나 <code>kmdb(1M)</code> 를 사용할 수 있습니다. <code>kmdb</code> 를 사용해서 코어 덤프를 생성하려면 시스템 부팅시에 모듈을 로딩해와야 합니다.</p><p>솔라리스10 1/06 혹은 그이후의 버전에서의 단계입니다.</p><ol><li><code>/boot/grub/menu.lst</code> 파일을 편집해서 <code>-k</code> string 을 <code>initrd</code> 줄에 아래처럼 추가 시킨다: <!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>title Solaris 10 11/06 s10x_u3wos_10 X86<br>root (hd0,1,a)<br>kernel /platform/i86pc/multiboot -k<br>module /platform/i86pc/boot_archive<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>이것은 OS 가 <code>kmdb</code> 와 함께 부팅되도록 한다. </p></li><li>머신을 수동으로 재시작 시킨다. </li></ol><p>이 방법 대신 솔라리스10 GA 버전에서는 시스템 부팅 스테이지에서<code> Select (B)oot or (I)nterpreter:</code> 메세지가 보일 때 <code>b -k</code> 를 입력할 수도 있습니다.</p><p>이러한 단계들을 수행한 후에는 F1-A 눌러서 시스템을 <code>kmdb</code> 로 들어가도록 합니다. 이 동작은 반드시 콘솔 모드에서 수행되어야 합니다. 왜냐하면 <code>kmdb</code> 는 시스템 과 GUI 어플리케이션을 일시 정지시키기 때문입니다. 만약 데스크탑 시스템을 사용한다면 솔라리스는 콘솔 모드의 전환이 실패할 것이고 데스크탑이 멈추게 될 것입니다. 그러나 <code>kmdb</code> 는 실행중이고 여러분은 여전히 커맨드를 입력할 수 있습니다.</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>$&lt;systemdump<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p><code>systemdump</code> 커맨드는 코어 덤프 파일을 생성합니다. 덤프 디바이스와 <code>savecore</code> 디렉토리는 여전히 <code>dumpadm</code> 의 영향을 받습니다. </p><p>종종 시스템이 <code>kmdb</code> 혹은 OBP 를 사용하더라도 아무런 응답없이 정지하는 경우가 있습니다.이러한 경우에는 "deadman timer." 를 사용 합니다. deadman timer 는 OS가 시스템 정지시에 커널panic 을 강제하도록 허락 합니다. 이 기능은 x86 과 SPARC 시스템에서 사용 가능합니다. 다음의 라인을 <code>/etc/system</code> 에 추가하고 재부팅하여 deadman timer 가 활성화 되도록 합니다.</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>set snooping=1<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>활성화된 deadman timer 는 1초에 한번씩 레벨 15 인터럽트를 발생시킵니다. 이것은 커널 <code>lbolt</code> 변수가 업데이트 됐는지 확인할 것입니다. 만약 deadman timer 가 특정 시간동안 <code>lbolt</code> 변수가 증가되지 않았음을 감지 한다면(기본은 50초) panic 을 유발 시킵니다. 시간 간격은 <code>/etc/system</code> 에서 설정 가능합니다. 다음의 예는 deadman timer 가 120초 동안 <code>lbolt</code> 변수의 업데이트를 기다립니다:</p><!-- BEGIN VCD7 CODE SAMPLE COMPONENT  --><table class="grey4" border="0" cellpadding="10" cellspacing="0" width="100%"><tbody><tr><td><pre>set snoop_interval=120000000<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><div><b>시스템 코어 덤프 파일을 분석하는 방법</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><p>이 글에서는 시스템 코어 덤프 파일을 수정하는 방법에 대한 해결책을 제시할 수 없습니다. 왜냐하면 이러한 분석은 OS커널과 하드뒈어에 대한 매우 저-수준의 컴퓨팅 지식을 요구하기 때문입니다. 아래에는 여러분의 참고를 위해 몇가지 기본적인가이드라인을 제시해 드립니다:</p><ol><li>시스템 콘솔과 <code>/var/adm/messages</code> 파일을 확인한다. 왜냐하면 이것들이 시스템이 처한 문제점들을 발견하는데에 필요한 정보들을 포함하고 있기 때문이다. </li><li><code>strings(1)</code> 커맨드를 이용해서 코어 덤프 파일을 처리한다. 이 커맨드는 어떠한 바이너리 파일도 ASCII 문자열로 출력해 준다. 여러분은 이러한 ASCII 문자열들을 볼 필요가 있다. </li><li>여러분이 겪은 에러들을 <a href="http://www.sunsolve.sun.com/">SunSolve web site</a> 사이트에서 찾아보거나 Solaris Crash Analysis Tool (CAT) 을 이용한다. </li></ol><div><b>참고자료</b></div><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" border="0" height="4" width="1"></td></tr></tbody></table></div><ul><li>Man pages for <code>signal</code>(3HEAD) (base signals), <code>coredmp</code>(1M), <code>dumpadm</code>(1M), and <code>proc</code>(1) </li><li><a href="http://docs.sun.com/app/docs/doc/819-3683">Sun Studio 11: Debugging a Program With dbx</a>, on docs.sun.com </li><li><a href="http://sunsolve.sun.com/search/document.do?assetkey=1-9-13258-1">Sun Info Doc number 13258</a> and <a href="http://sunsolve.sun.com/search/document.do?assetkey=1-9-15553-1">Sun Info Doc number 15553</a> <i>(Note: This content is available to registered SunSolve users with a valid Sun Service Plan.)</i> </li><li><a href="http://www.sun.com/download/products.xml?id=3fce7df0">Solaris Crash Analysis Tool download</a> </li></ul></div><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

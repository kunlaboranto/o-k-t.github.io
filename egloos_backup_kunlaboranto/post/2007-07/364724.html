<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[RAID] 초보</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2007-07-02 10:37:54</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[RAID] 초보</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">From : <a href="http://www.zdnet.co.kr/reviews/digital/hw/0,39031899,10052845,00.htm">http://www.zdnet.co.kr/reviews/digital/hw/0,39031899,10052845,00.htm</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.zdnet.co.kr/builder/system/server/0,39031667,39146265,00.htm">http://www.zdnet.co.kr/builder/system/server/0,39031667,39146265,00.htm</a><br><br><table style="MARGIN-BOTTOM: 8px" cellspacing="0" cellpadding="0" width="568" border="0"><tbody><tr><td id="story_body[author]"><font class="list18_b">RAID 1-6 레벨 이해하기</font><br><span style="COLOR: #000000"></span><br><font class="t11_99" color="#818181">Scott Lowe ( TechRepublic ) &nbsp; 2006/04/06</font> &nbsp; <a href="http://techrepublic.com.com/5100-10880_11-6056489.html?tag=fdlead2" target="_blank"><img height="17" src="http://www.zdnet.co.kr/i/ui/common/story_ori.gif" width="60" align="absMiddle" border="0"></a></td></tr></tbody></table><table style="MARGIN-BOTTOM: 8px" cellspacing="0" cellpadding="0" width="568" border="0"><tbody><tr><td align="right"><table cellspacing="1" cellpadding="2" border="0"><tbody><tr><td><a href="javascript:void(0)"><img id="csi_39146265" onclick="addMyStory(39146265,'/builder/system/server/0,39031667,39146265,00.htm','RAID 1-6 레벨 이해하기')" src="http://www.zdnet.co.kr/i/ui/common/b_save.gif" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="articleFont('-');" height="3" src="http://www.zdnet.co.kr/i/ui/common/story_icon_size1.gif" width="8" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="articleFont();" height="10" src="http://www.zdnet.co.kr/i/ui/common/story_icon_size.gif" width="41" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="articleFont('+');" height="9" src="http://www.zdnet.co.kr/i/ui/common/story_icon_size2.gif" width="9" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="printThis(39146265);" src="http://www.zdnet.co.kr/i/ui/common/story_icon_print.gif" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="emailkorThis(39146265);" src="http://www.zdnet.co.kr/i/ui/common/story_icon_email.gif" border="0"></a></td></tr></tbody></table></td></tr></tbody></table><table style="MARGIN-BOTTOM: 12px" cellspacing="0" cellpadding="0" width="568" border="0"><tbody><tr><td class="body14_2b" valign="top"><table cellspacing="0" cellpadding="0" width="160" align="right" border="0"><tbody></tbody></table><div id="story_body[content]"><b>1부터 6까지의 RAID 레벨의 장단점을 알아보고, 스토리지를 구성할 때 목적에 맞는 최적의 레벨을 찾아보자. </b><br><br>데이터는 많은 조직에서 가장 중요하고 요즘 같은 인터넷 시대에는 데이터를 빠르고 믿을 수 있게 접근하는 것이 매우 중요하다. 그렇게 조직은 대부분 데이터를 무결하게 유지하기 위해 RAID의 어떤 레벨을 사용한다. <br><br>요즘은 대부분 그렇지만 RAID 5가 쉽고 최선일 것 같기 때문에 얼마나 많은 서버에 RAID 5를 적용하고 있을까? 대부분의 경우 RAID 5가 옳은 선택이지만 쓰기 성능을 고려한다면 다른 RAID 레벨이 최선일지도 모른다. <br><br>지금 얼마나 많은 사람들이 RAID 10과 50를 즉석해서 설명할 수 있을까? 새로 발명된 RAID 레벨이 RAID 5의 단점을 보완할 수 있고 아직도 스토리지 시스템에서는 많은 것을 예비용으로 사용한다. 이 글에서 기본적인 RAID 레벨의 장단점을 소개하고 다음 글에서 나는 RAID 10같이 네스티드(nested)라고 불리는 좀 더 복잡한 RAID 레벨을 소개하려고 한다. (주: http://www.acnc.com/04_00.html에서 각 RAID 레벨의 그림을 볼 수 있다.)<br><br><b>RAID 0(디스크 스트라이핑)</b><br>* 최소 드라이브 개수 : 2<br>* 최대 용량 : 디스크의 수 x 디스크의 용량<br>* 설명 : 데이터를 블럭으로 쪼개서 저장하는데 각 블럭은 다른 디스크로 나뉘어 저장된다. <br><br>* 장점 : 매우 빠르다. 데이터는 여러 개의 "모터(spindles)"로 스토리지에서 읽고 쓴다. 즉, I/O 로드가 분산되는 것을 의미하기 때문에 매우 빠르다. 이론적으로 디스크를 추가하는 족족 성능은 향상된다. 보통 엄청난 성능이 필요할 때 사용하는데 성능이 정말 좋은지 알아 보기 위해 스토리지를 아이오미터(IOmeter)같은 도구를 사용하여 확인한다.<br>* 단점 : 드라이브 하나가 고장 나면 이 RAID 레벨은 어떤 안전장치도 없기 때문에 천체 어레이가 고장 날 수 있고 디스크를 추가할 수록 위험이 증가한다.(주: 어레이는 여러 개의 디스크 배열을 의미)<br><br><b>RAID 1 (디스크 미러링)</b><br>* 최소 드라이브 개수 : 2<br>* 최대 용량 : (디스크의 수/2) x 디스크의 용량<br>* 설명 : 스토리지에 저장되는 모든 데이터는 두 개의 물리적인 디스크에 각각 저장되고 모든 데이터는 중복된다.<br><br>* 장점 : 드라이브 하나가 고장 나면 똑같은 내용의 다른 드라이브가 하나 더 있기 때문에 매우 안전하다. RAID 1은 읽기 성능이 단일 드라이브에서의 성능과 같거나 훨씬 좋다. <br>* 단점 : 각 드라이브는 미러링되기 때문에 전체 용량의 절반밖에 사용하지 못한다. 드라이브 두 개에 동일한 데이터를 써야 하기 때문에 쓰기 성능이 나빠질 수 있지만 아직 다른 RAID 레벨의 쓰기 성능보다는 훨씬 낫다. <br><br><b>RAID 2: 이 레벨은 더 이상 사용되지 않는다</b><br><br><b>RAID 3(패리티를 사용하고 디스크를 병렬로 처리한다)</b><br>* 최소 드라이브 개수 : 3 <br>* 최대 용량 : (디스크의 수 - 1) x 각 디스크의 용량<br>* 설명 : 데이터는 바이트 단위로 쪼개져서 모든 디스크에 균등하게 나뉘어 저장되고 패리티 정보는 별도의 전용 디스크에 저장된다.<br><br>* 장점 : 한 개의 드라이브가 고장 나는 것을 허용하며 순차적 쓰기(sequential write) 성능과 순차적 읽기(sequential read) 성능이 우수하다. <br>* 단점 : 잘 사용되지 않고 문제를 해결하는 것이 어려울 수 있다. 하드웨어 RAID가 되어야 실제로 쓸만하다. RAID 3은 보통 매우 효율적이지만 임의 쓰기(random write) 성능이 나쁘고 임의 읽기(random read) 성능은 꽤 좋다. . <br><br><b>RAID 4 (각 디스크는 패리티 블럭을 공유한다)</b><br>* 최소 드라이브 개수 : 3<br>* 최대 용량 : (디스크의 수 - 1) x 디스크의 용량<br>* 설명 : 모든 파일은 블럭으로 쪼개지고 각 블럭은 여러 디스크에 저장되지만 균등하진 않다. RAID 3처럼 RAID 4도 패리티를 처리하기 위해 별도의 디스크를 사용한다. 동시 트랜잭션 사용량이 많은 시스템에서 읽기 속도는 매우 중요한데 이런 시스템에 적합하다. <br>* 장점 : 드라이브 하나가 고장 나는 것을 허용하고 읽기 성능이 매우 좋다. <br>* 단점 : 쓰기 성능이 나쁘지만 블럭 읽기(block read) 성능은 괜찮다. <br><br><b>RAID 5(패리티를 순환시키는 것 없이 각 어레이에 접근한다)</b><br>* 최소 드라이브 개수 : 3<br>* 최대 용량 : (디스크의 수 - 1) x 디스크의 용량<br>* 설명 : RAID 4처럼 데이터의 블럭은 모든 디스크에 나뉘어 저장되지만 항상 균등하진 않고 패리티 정보도 모든 디스크에 나뉘어 저장된다. <br>* 장점 : 지원하는 회사가 많고 한 개의 드라이브가 고장 나는 것을 허용한다. <br>* 단점 : 디스크 재구성(rebuild)이 매우 느리고 쓰기 성능은 패리티 정보를 끊임없이 갱신해야 하기 때문에 우수하다고 할 수는 없다. <br><br><b>RAID 6(각 디스크에 패리티 정보가 두 번 독립적으로 분산된다) </b><br>* 최소 드라이브 개수 : 3<br>* 최대 용량 : (디스크의 수 - 2) x 디스크의 용량<br>* 설명 : RAID 4처럼 데이터의 블럭은 모든 디스크에 나뉘어 저장되지만 항상 균등하진 않고 패리티 정보도 모든 디스크에 나뉘어 저장된다. <br><br>* 장점 : 두 개의 드라이브까지 고장 나는 것을 허용하고 읽기 성능이 우수하고 매우 중요한 경우에 적합하다. <br>* 단점 : 쓰기 성능은 패리티를 여러 번 갱신해야 하기 때문에 RAID 5보다 매우 나쁘다. 디스크를 재구성하는 동안에 성능이 매우 나빠질 수 있다. @</div></td></tr></tbody></table><br><br>-------------<br><table style="MARGIN-BOTTOM: 8px" cellspacing="0" cellpadding="0" width="568" border="0"><tbody><tr><td id="story_body[author]"><font class="list18_b">RAID 제대로 활용하기</font><br><span style="COLOR: #000000"></span><br><font class="t11_99" color="#818181"><a class="gray" href="http://www.zdnet.co.kr/services/story/email/?email=0VmbuwWZ0lGaAtmcvdXY0FGZ" target="hiddenSendTo">문성욱</a> ( ZDNet Korea ) &nbsp; 2002/10/11</font> </td></tr></tbody></table><table style="MARGIN-BOTTOM: 8px" cellspacing="0" cellpadding="0" width="568" border="0"><tbody><tr><td align="right"><table cellspacing="1" cellpadding="2" border="0"><tbody><tr><td><a href="javascript:void(0)"><img id="csi_10052845" onclick="addMyStory(10052845,'/reviews/etc/0,39040530,10052845,00.htm','RAID 제대로 활용하기')" src="http://www.zdnet.co.kr/i/ui/common/b_save.gif" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="articleFont('-');" height="3" src="http://www.zdnet.co.kr/i/ui/common/story_icon_size1.gif" width="8" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="articleFont();" height="10" src="http://www.zdnet.co.kr/i/ui/common/story_icon_size.gif" width="41" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="articleFont('+');" height="9" src="http://www.zdnet.co.kr/i/ui/common/story_icon_size2.gif" width="9" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="printThis(10052845);" src="http://www.zdnet.co.kr/i/ui/common/story_icon_print.gif" border="0"></a></td><td><a href="javascript:void(0)"><img onclick="emailkorThis(10052845);" src="http://www.zdnet.co.kr/i/ui/common/story_icon_email.gif" border="0"></a></td></tr></tbody></table></td></tr></tbody></table><table style="MARGIN-BOTTOM: 12px" cellspacing="0" cellpadding="0" width="568" border="0"><tbody><tr><td class="body14_2b" valign="top"><table cellspacing="0" cellpadding="0" width="160" align="right" border="0"><tbody></tbody></table><div id="story_body[content]">메 인보드를 구입할 때 유심히 스펙을 보면 RAID란 기능이 추가된 제품을 종종 볼 수 있다. RAID는 불과 몇 년 전까지만 해도 서버에서나 볼 수 있었던 기술로서 데스크탑 PC의 용도가 다양화되면서 일반 PC에서도 RAID를 기능을 이용할 수 있는 메인보드 등이 여럿 출시되었다. 하지만 많은 사용자들이 RAID 기능의 용도에 대해 정확히 알지 못하고 이를 구입하는 실수를 범하기도 한다. 물론 사용하지 않으면 그만이지만 제대로 사용하면 PC의 한계를 쉽게 극복할 수 있는 것이 RAID이다.<br><br><b>RAID의 용도</b><br>RAID(redundant array of independent disks)는 사실 일반 PC사용자라면 거의 필요 없는 장치이다. RAID가 가장 많이 적용되는 부분은 서버와 같은 대용량 데이터나 중요한 데이터를 저장하는 디스크이다. RAID는 하드디스크에 적용되는 기술로 여러 개의 하드디스크를 묶어서 쓸 수 있도록 만들어진 방법이다. 만약 500GB의 용량을 하나의 디스크로 인식시키고자 한다면 한 개의 드라이브로는 아직까지 불가능 할 것이다. 또한 여러 개의 하드디스크를 묶어서 용량을 채울 수는 있겠지만 한 개의 드라이브 명이 아닌 여러 개의 드라이브로 인식 시켜야 한다. <br><br>RAID기술은 이러한 여러 개의 하드디스크를 하나로 묶어 한 개의 드라이브 명으로 만들 수 있다. 또한 기록방법을 개선하거나 여러 개의 드라이브에 같은 데이터를 분산시키는 방법으로 특정 하드디스크에 문제가 생길 때에도 데이터가 손상되는 것을 막아주기도 한다. 또한 PC의 한계 때문에 IDE 드라이브를 4개 이상 장착할 수 없지만 일부 제품은 두개의 RAID를 이용하면 그 이상의 하드디스크를 장착할 수 있다.<br><br><b>RAID를 사용하기 위한 장비</b><br>RAID를 사용하기 위해서는 이를 사용하기 위한 특별한 컨트롤러가 필요하다. 초기의 RAID 컨트롤러는 여러 개의 하드디스크를 연결해야 하기 때문에 SCSI 방식의 하드디스크에 한정되었다. 하지만 기술적인 진보와 더불어 IDE 방식의 하드디스크에서도 RAID를 사용할 수 있는 컨트롤러가 출시되기 시작했다. 일부 메인보드에는 RAID의 기능을 수행하기 위한 칩셋과 커넥터가 붙어 있어 특별한 부가 장치 없이도 RAID의 사용할 수 있다. <br><br>하지만 그렇지 못한 대부분의 PC에서 RAID 기능을 사용하고자 한다면 별도의 RAID 컨트롤러를 구입해야 한다. RAID 컨트롤러는 대부분 PCI 카드 형태로 카드만 꼽으면 사용할 수 있다. 다만 컨트롤러에 사용된 칩셋에 따라 일부 메인보드나 다른 하드웨어와 충돌의 가능성이 있기 때문에 구입시 이러한 충돌 상황에 대한 사전조사가 필요하다. RAID 컨트롤러의 다양한 기능과 드라이브 자체를 인식시키는 방법은 마치 SCSI 컨트롤러와 비슷하다. 컨트롤러에 내장된 바이오스에서 이러한 다양한 기능을 간단히 세팅할 수 있다.<br><br><b>안전을 위한 RAID</b><br>RAID는 그 방법에 따라 몇 가지로 구별이 된다. 그중 RAID 1은 안전을 위한 RAID 기술이다. 연결된 하드디스크에 같은 데이터를 중복 저장하므로 서 데이터의 특정 하드디스크에 이상이 발생할 때에도 데이터가 손실되는 것을 최소화 시킬 수 있는 방법이다. RAID 1은 안전은 하지만 데이터를 단순히 중복해서 저장하는 것에 불과하기 때문에 용량의 낭비가 심하며 기록속도에서도 큰 향상을 기대하기 어렵다. <br><br>하지만 같은 데이터를 두개의 하드디스크에 저장하고 있기 때문에 필요한 데이터를 두개의 하드디스크에서 한꺼번에 읽어 올수 있어서 읽기 속도가 향상되는 장점이 있다. 이러한 특성 때문에 일반 PC에서 사용하기 보다는 서버와 같은 중요한 데이터를 자주 읽어 들이는 용도에 적용하는 것이 적합하다.<br><br><b>속도를 위한 RAID</b><br>속도를 증가시키기 위한 RAID 기술은 RAID 0으로서 여러 개의 하드디스크를 병렬로 연결해 하나의 데이터를 한꺼번에 쪼개서 동시에 여러 개의 하드디스크에 저장하는 기법이다. 그래서 기록속도뿐만 아니라 읽기 속도도 매우 빠르다는 장점이 있다. 하지만 이 방법은 하나의 데이터를 쪼개서 기록하기 때문에 하드디스크 중 한개만 에러가 발생해도 치명적인 문제를 일으키게 된다. <br><br>실질적인 속도의 향상에 있어 가장 좋은 조건을 가지고 있는 방법이기에 PC 사용자들이 가장 선호하는 방법이지만 서버와 같은 중요한 데이터를 자정하고자 하는 용도에는 적합하지 않다.<br><br><b>속도와 용량을 모두를 위한 RAID</b><br>RAID 0과 RAID 1의 단점을 보안하기 위한 방법이 RAID 0+1이다. 4개의 하드디스크를 이용하는 RAID 0+1은 두개씩 묶어진 하드디스크에 RAID 0의 방법을 통해 하드디스크의 내용을 두개의 하드디스크에 분산 기록하고 이것은 또다시 RAID 1의 방법을 동일하게 기록하는 방법이다. <br><br>결국 RAID 1과 RAID 0의 단점을 모두 보안할 수 있기 때문에 속도와 안정성 모두를 얻을 수 있다. 하지만 이 방법은 반드시 4개 이상의 하드디스크를 이용해야 하기에 일반 사용자에게는 이러한 방법을 구현하는 것이 어렵다. 그래서 서버와 같은 안정성과 속도를 모두 필요로 하는 환경에 어울릴만한 RAID 기술이다. @</div></td></tr></tbody></table><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

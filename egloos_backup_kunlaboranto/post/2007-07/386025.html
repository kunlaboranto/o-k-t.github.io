<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] minicom 사용법 - 리눅스 serial 통신</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2007-07-07 19:17:57</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] minicom 사용법 - 리눅스 serial 통신</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content"><p>From : <a href="http://www.linuxlab.co.kr/docs/minicom.htm">http://www.linuxlab.co.kr/docs/minicom.htm</a><br><br><span style="FONT-SIZE: 170%; COLOR: #929292">Minicom으로 배우는 피시통신</span><span style="FONT-FAMILY: 굴림"></span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">미니컴은 윈95의 하이퍼터미널과 유사한 리눅스용 통신 프로그램이다. (UNIX 버전도 있다)<br>비록 텍스트 방식이지만 모뎀 제어, 파일 업로드 다운로드, 다이얼링 디렉토리 등 통신에 필요한 중요한 기능은 거의 포함되어있는 좋은 프로그램이다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">미니컴의 용도는 다양하지만 우선 리눅스에서 하이텔이나 천리안 등의 BBS를 연결할 때 가장 좋다.<br>콘솔에서 한글을 쓰려면 han 같은 콘솔용 한글을 뛰우거나 한글 X-window를 뛰우면 된다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">윈95에서 리눅스로 login하여 minicom을 가동해도 한글이 지원된다. 따라서 랜에 연결된 리눅스 서버에 모뎀과 전화선을 연결하면 그 랜의 모든 피시에서 리눅스에 login해서 minicom을 가동해서 통신을 할수 있으므로 가장 손쉬운 모뎀 공유 방법이기도 하다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">다른 용도로는 PPP 연결에서 사용한다. 보통 PPP 연결은 쉘스크립트를 쓰지만 쉘스크립트를 쓸 경우 PPP 연결이 잘 안되어도 어느 부분이 문제인지 파악이 어렵다. 이 경우는 일단 minicom으로 먼저 상대 모뎀과 연결을 한 후 통신 연결을 유지한채 minicom을 빠져나와 ppp 데몬을 실행하는 방법으로 접근하면 쉽게 어느 부분에서 문제가 있는지 파악이 가능하다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">1. 통신을 하기 전에 알아야 할 사항 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">1.1 장치명 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">우선 시리얼 통신을 하려면 시리얼포트와 모뎀이 필수적이다.<br>피시는 4개의 시리얼포트를 지원하므로 이 네개의 시리얼 포트 중 어디에 모뎀이 연결되어 있는지를 알아야한다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">아래 예를 우선 보자 </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Serial driver version 4.13 with no serial options enabled</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">tty00 at 0x03f8 (irq = 4) is a 16550A</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">tty01 at 0x02f8 (irq = 3) is a 16550A</span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위는 dmesg 명령으로 출력한 내용 중 일부이다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위에서는 시리얼 포트가 두개가 인식되었다. com1과 com2이다. 즉 tty00 옆에 0x03f8은 IO Address 이고 irq= 옆의 4는 인터럽트이다. 그 옆의 16550A 는 UART 칩을 표시한다. 아래는 com 포트 별 IO Address와 IRQ 번호이다. </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com1 3f8 4</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com2 2f8 3</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com3 3e8 4</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com4 2e8 3</span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">내장 모뎀을 사용한다면 com3나 com4가 나올수도 있다. 또 CMOS 셋업에서도 com 포트 IO address를 변경할수 있으므로 피시의 마더보드에 내장된 com 포트가 항상 com1 과 com2 로만 설정되지 않는다는걸 알아야한다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">왜 위의 지식이 필요한가하면 시리얼포트 를 사용하려면 시리얼포트 장치명을 알아야하기 때문이다. 아래는 각 com 포트 별 리눅스의 장치명이다. </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com1 : /dev/ttyS0</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com2 : /dev/ttyS1</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com3 : /dev/ttyS2</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com4 : /dev/ttyS3</span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">예를들어 minicom에서 셋업에 아래 부분이 있다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">A - Serial Device : /dev/ttyS1 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">여기에 /dev/ttyS1 은 com2를 가르킨다. 가끔 시리얼 디바이스명에 /dev/modem이라고 넣어야 하지 않느냐는 질문을 받는데 /dev/modem 이란 장치는 없다. 단지 리눅스 설치시 모뎀 포트를 묻는 부분이 있는데 이 대답에 따라 /dev/ttyS?를 /dev/modem 이란 장치에 링크 해 놓았기 때문이다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">따라서 만약에 설치 후에 모뎀이 연결된 포트가 바뀌면 /dev/modem이란 장치는 인식이 되지 않으므로 ttyS? 장치명을 쓰는게 좋다. <br>(리눅스 커널 2.0에서는 dial-in 과 dial-out에 따라 ttyS? 장치명과 cua? 장치명을 구분해 썼으나 2.2부터는 ttyS? 장치로 통일되었다.) </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">1.2 통신속도 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">요즘 나오는 56k 모뎀을 사용하려면 피시의 시리얼 포트 속도가 115,200bps는 되야한다. 이는 모뎀에 데이터 압축 기능이 있어 시리얼포트 속도(DTE 속도라고도 함)는 선로속도(DCE 속도라고도 함)의 2배 내지 4배를 잡아주는게 좋기 때문이다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">통신 프로그램에서 포트에 지정하는 속도는 선로속도가 아니고 시리얼포트 속도이다. 선로속도는 통신프로그램에서는 지정할 수 없고 두 모뎀이 처음 연결될때 두 모뎀간의 핸드쉐이킹(handshaking) 과정에서 결정된다.<br>(모뎀으로 처음 접속시 나는 이상한 소리가 바로 두 모뎀의 핸드쉐이킹 과정이다. ) </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com2의 시리얼 포트 속도를 115,200bps롤 주고 싶으면 setserial 명령을 써야한다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">/bin/setserial /dev/ttyS1 spd_vhi </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위의 명령을 주면 com2의 시리얼포트 속도가 115,200bps로 바뀐다.(57,600 bps라면 spd_hi 를 쓴다)<br>다음에 이를 확인하려면 setserial -a /dev/ttyS1 명령을 주라.<br>아래는 출력 결과이다. </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">churlsu:~$ setserial -a /dev/ttyS1<br></span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">/dev/ttyS1, Line 1, UART: 16550A, Port: 0x02f8, IRQ: 3<br></span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">           Baud_base: 115200, close_delay: 50, divisor: 0<br>           </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Flags: spd_vhi skip_test auto_irq session_lockout</span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위에서 Flags가 spd_vhi 로 바뀌었으므로 이제 시리얼포트 속도는 115200bps를 지원한다.<br>(물론 통신프로그램에서 지정해야 효력이 있다) </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">setserial 명령은 리눅스 시스템을 리부팅하면 효력이 사라진다. 따라서 부팅과 동시에 이 명령을 실행하려면 rc.local 스크립트나 rc.boot 디렉토리에 넣으면 된다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">1.3 com 포트의 IRQ를 비표준 irq로 쓰려면 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">com포트는 보통은 2개 밖에 쓸수 없다. 이유는 com포트에 할당된 irq가 4와 3 2개 이기 때문이다.<br>일부 내장모뎀은 irq를 바꿀수 있다. 따라서 irq만 여유가 있으면 4개의 모뎀을 리눅스에서 동시에 사용할수 있다. 이때는 setserial에서 수동으로 해당 포트의 irq를 지정해야한다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">1.4 시리얼포트의 FIFO 버퍼 문제 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">피시의 시리얼 포트 UART 칩에는 여러 종류가 있다. 8250, 16450, 16550 등이다.<br>그런데 UART 칩이 8250이나 16450일 경우 버퍼의 문제로 인해 시리얼 포트 속도를 19,200bps 이상으로 올리기 힘들다. 이른바 데이터 오버론 현상(또는 CRC 에러)이 발생할수 있기 때문이다. 그러나 16550칩은 버퍼가 16바이트이므로 적절한 플로우 컨트롤을 사용하면 115,200bps에서도 별로 문제가 없다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">하지만 요즘 고속의 시리얼 데이터 전송이 등장하므로서 피시의 시리얼 포트는 16바이트 버퍼로도 부족할수 있어 새로 16650, 16750 UART 칩이 등장하였다. 16650은 32바이트 16750은 64바이트 버퍼를 갖고 있다. 리눅스에서 시리얼 포트의 UART 칩을 확인하려면 dmesg 명령을 써서 부트 때의 메시지를 보면 된다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">1.5 230k , 460k 시리얼 포트 속도 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">모뎀통신을 하는 경우 피시의 시리얼포트 속도를 115.2k 이상으로 할 필요는 없다. 56k 모뎀이라 할지라도 실제 선로 속도는 50k 수준으로서 극히 일부 데이터를 제외하고는 2배 이상의 압축이 이루지지 않으므로 115.2k 로 충분하다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">그러나 ISDN의 경우는 다르다. ISDN 라인은 선로 속도가 128k이다. 그런데 ISDN 외장형 TA나 ISDN 모뎀을 쓸 경우 128k 속도를 피시의 시리얼 포트가 지원하지 못하므로 이를 115.2k로 낮추어 피시의 시리얼 포트로 보낸다. 즉 10% 가량의 속도를 손해보고 있다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">일부 업체서 230.4k를 지원하는 시리얼포트 및 멀트포트를 생산하고 있다. 460k 심지어는 920k를 지원하는 멀티포트도 있다. 그러나 이런 속도를 피시의 시리얼포트에서 사용하려면 업체서 제공하는 드라이버나 프로그램을 사용하여야한다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">ISDN에서 피시와 연결하는 포트 속도를 230k로 하려면 ISDN 장비 자체도 이에 맞게 조정해야하고 피시의 시리얼포트, 드라이버 및 통신 프로그램도 230k를 지원하도록 바꾸어야한다. 리눅스에서 시리얼 포트에서 230k를 쓰려면 setserial 명령으로 가능하다. (물론 시리얼포트가 230.4k를 지원해야한다) </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">1.6 플로우컨트롤 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">고속모뎀에서는 시리얼포트 속도와 선로속도가 다르므로 모뎀에 버퍼를 사용하여 데이터를 임시로 저장한다. 따라서 피시에서 모뎀으로 데이터를 넘겨 줄 때 모뎀의 버퍼가 다 차면 모뎀은 피시로부터 데이터를 받는걸 중단해야한다. 이를 제어하는 방식에는 두 가지가 있는데 xon/xoff 와 rts/cts 이다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">xon/xoff 흐름제어를 소프트웨어 플로우컨트롤이라고도 하는데 데이터 내에 애스키 콘트롤캐릭터를 넣어 데이터 흐름을 제어하는 방식이므로 모뎀에서 바이너리 데이터를 전송하는 경우 즉 파일 업로드 다운로드시에는 데이터 송수신이 중단된다.<br>(바이너리 데이터에는 xon/xoff 문자가 들어 있으므로 이를 데이터로 인식하지 않고 흐름제어로 인식하여 송수신을 중단한다)</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">rts/cts는 하드웨어 플로우 컨트롤이라고도 하는데 rs-232 포트의 rts/cts 라인을 흐름제어로 사용하므로 바이너리 데이터 전송시에도 문제가 발생하지 않는다. 따라서 고속모뎀에서는 무조건 RTS/CTS 를 사용해야한다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">그러면 xon/xoff는 어떤 경우에 사용하는가?<br>예를들면 단말기를 RX, TX, Ground 3개의 선으로 연결하여 연결하는 경우는 rts와 cts 신호는 사용할 수 없으므로 이 경우 흐름제어를 하려면 Xon/Xoff를 쓸 수밖에 없다. 또는 통신 프로그램에서 RTS/CTS 를 지원하지 않는 경우도 마찬가지다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">리눅스 통신에서 흐름제어에 rts/cts를 쓰려면 stty 명령을 주어야한다. 물론 통신프로그램에서도 지정할수 있다. 그러나 양쪽에 모두 주는게 보다 확실하다. <br>아래는 stty 명령으로 com2포트의 특성을 확인한 결과이다. </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">churlsu:~$ stty -a &lt; /dev/ttyS1<br></span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">speed 9600 baud; rows 24; columns 80; line = 0;</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>;</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">eol2 = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W;</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">lnext = ^V; flush = ^O; min = 1; time = 0;</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">-parenb -parodd cs8 hupcl -cstopb cread clocal crtscts</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">-iuclc -ixany -imaxbel</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">echoctl echoke</span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">이부분은 현재 com2 포트의 특성을 보여주고 있다. 너무 복잡해 설명하기가 힘드나 위에서 6번째 줄 끝에 crtscts라고 나와있다. 이는 이 포트에 현재 rts/cts 플로우컨트롤이 사용된다는 뜻이다. 여기에 -crtscts라고 나오면 rts/cts 플로우컨트롤이 사용되지 않는다는 뜻이다. 이포트에 rts/cts를 쓰려면 아래 명령을 준다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">stty crtscts &lt; /dev/ttyS1 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">이부분도 시스템 부팅시마다 가동되야하므로 rc.local이나 rc.boot 디렉토리에 넣는다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2. 미니컴 환경설정(configuration) </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">미니컴은 가동시 옵션을 붙일수 있는데 형식은 아래와 같다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">minicom [-somlz] [-c on|off] [-d entry] [-a on|off] [-t term] [configuration] </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">미니컴을 처음 사용할 때는 사용 환경을 맞추어야한다. 우선 가동시 -s 옵션을 주어 configuration 메뉴를 가동해 환경 설정부터 해야한다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">minicom -s 명령을 주면 아래 화면이 뜬다. </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">[configuration]</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Filenames and paths </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">File transfer protocols </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Serial port setup </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Modem and dialing </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Screen and keyboard </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Save setup as dfl </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Save setup as.. </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Exit </span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위의 메뉴에서 상하 화살표키를 이용해서 메뉴를 선택하면 다음메뉴가 나온다. 여기에서 우선 가장 필수적으로 지정해야하는 부분을 위주로 아래에 설명한다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2.1 Filenames and paths </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">파일 업로드와 다운로드에서 사용하는 디렉토리를 지정한다. 별도 지정이 없으면 현행 디렉토리가 사용된다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2.2 Serial port setup </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">가장 중요한 부분이다. 아래에 서브메뉴를 보면 다음과같다. </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">A - Serial Device : /dev/ttyS1 </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">B - Lockfile Location : /var/lock</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">C - Callin Program : </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">D - Callout Program : </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">E - Baud/Par/Bits : 115200 8N1 </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">F - Hardware Flow Control : Yes </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">G - Software Flow Control : No </span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2.2.1 serial device </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위의 1.1을 참고 </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2.2.2 Lockfile Location : /var/lock </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">리눅스는 멀티유저 시스템이므로 한 개의 통신포트를 다른 프로그램에서 동시에 사용을 시도할수 있다. 이를 예방하기위해 통신포트를 특정 프로그램이 사용하면 특정 디렉토리에 파일을 만들어 그 포트가 사용중임을 표시한다. 파일 이름은 보통 LCK..tty?? 이다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">이 파일 내에는 그 포트를 사용중인 프로그램의 PID가 ascii 또는 바이너리로 저장되므로 다른 프로그램은 이 파일을 체크해서 그 포트가 사용 가능한지를 알수 있다. LCK..tty?? 파일을 lock 파일이라 부르는데 이 파일의 위치가 통일되야 포트 사용여부를 다른 프로그램에서 파악이 가능하다. 리눅스에서는 /var/lock 디렉토리를 사용한다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2.2.3 Baud/Par/Bits : 115200 8N1 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">이부분은 위의 1.2를 참조 </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2.2.4 Hardware Flow Control : Yes <br>2.2.5 Software Flow Control : No </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위의 1.6를 참조 </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2.3 Modem and dialing </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">이부분에서 중요한건 모뎀초기화 스트링을 넣는 부분이다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">A - Init string ......... ~atz^M~ </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">여기서 tilde(~)은 1초 정도 지연을 발생시킨다. ^M은 리턴키를 누른다는 뜻임. 어느 경우든 모뎀의 초기값은 모뎀에 내장될수 있으므로 여기에 모뎀 초기화 스트링을 넣을 필요성은 없으나 혹시 다른 사람이 모뎀을 사용하면서 모뎀 설정 값을 바꾸어 놓을수 있으므로 여러 사람이 모뎀을 사용하는 경우라면 초기화 스트링에 e1q0v1&amp;c1&amp;d2 정도를 넣어주는게 좋다. 혼자서만 쓴다면 atz면 충분하다.(뒤에 꼭 ^M을 넣어야한다.) </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">P - Auto baud detect .... No </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">이부분은 특별한 경우가 아니면 no로 해야한다. Auto baud 란 선로속도와 시리얼포트를 자동으로 일치시킨다는 의미인데 데이터 압축이 지원되는 모뎀(9600bps 이상의 모든 모뎀)은 시리얼 포트 속도가 선로속도보다 높아야하므로 auto baud를 지정하면 안된다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">대충 이정도만 지정하고 configuration 메뉴로 돌아와(서브메뉴에서 ESC키를 누른다) " Save setup as dfl" 를 선택하고(enter를 누른다) "Exit from Minicom"을 선택하면 환경 설정이 완료되었다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">*. 혹시 미니컴 사용 도중 위의 환경 설정을 바꾸려면 ctrl+a o 를 누른다. <br>(ctll 키와 a 키를 동시에 누른후 o 키를 누른다.) </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">2.4 가동시에 사용되는 다른 옵션 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">-l <br>한글을 사용하려면 필히 지정해야한다. 이는 미니컴이 확장아스키코드를 그래픽문자로 표시하지 않게 하는 옵션이다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">-d <br>전화번호부를 지정한다. 즉 미니컴에서 ctrl+a d 를 눌러 설정한 전화번호부( 상대전화번호 터미널 타입 등이 저장돼 있다) 의 디폴트네임은 홈디렉토리의 .dialdir 인데 이를 사용하지 않고 다른 파일을 쓸 때 사용한다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">3. 명령어(키) </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위의 절차를 마치고 미니컴을 가동하면 (minicom -l) "Initializing Modem.." 이란 메시지가 뜨고 텅빈 화면이 나온다. 그리고 25번째 라인에는 아래의 상태라인이 나온다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">CTRL-A Z for help |115200 8N1 | NOR | Minicom 1.75 1996 | VT102 | Offline </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">이글의 의미는 사용법을 알려면 ctrl+a z 를 누르고 통신속도(시리얼포트 속도)는 115200 터미널 타입은 vt-102 라는 뜻이다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">한글을 사용하려면 필히 ctrl+a t 키를 눌러 터미널 타입을 ansi로 바꾸어야한다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Ctrl+a z 를 누르면 아래 화면이 나온다. </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Commands can be called by CTRL-A <key></span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림"></span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Main Functions Other Functions </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림"></span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Dialing directory..D run script (Go)....G Clear Screen.......C </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Send files.........S Receive files......R cOnfigure Minicom..O </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">comm Parameters....P Add linefeed.......A Suspend minicom....J </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Capture on/off.....L Hangup.............H eXit and reset.....X </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Send break.........F initialize Modem...M Quit with no reset.Q </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Terminal settings..T run Kermit.........K Cursor key mode....I </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">lineWrap on/off....W local Echo on/off..E Help screen........Z </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">scroll Back........B </span><span style="FONT-SIZE: 100%">&nbsp;</span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">위에서 D S P L .. 등으로만 표시했는데 반드시 ctrl+a를 먼저 누르고 해당 문자를 눌러야한다. <br>여기에서 중요한 메뉴를 보면 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">S<br>하이텔같은곳에 파일을 업로드 할 때 저쪽에서 zmodem을 가동하시오 라고 나왔을 때 이 키를 누른후 zmodem을 선택한다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">P<br>전송속도, 패리티 비트등을 고칠수 있다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">L<br>화면 내용을 파일로 저장할 때 쓴다. 토글키이다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">F<br>중단 신호를 모뎀으로 보낸다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">T<br>터미널 타입을 선택할수 있다.(한글을 쓸려면 ansi로 지정하시오.) </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">W<br>linewrap on/off </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">G<br>스크립트 구동 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">R<br>파일을 다운로드 할 때 쓴다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">A<br>라인 피드 on/off </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">H<br>전화를 끊는다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">M<br>모뎀을 초기화 한다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">E<br>local echo on/off, 1:1 통신에서 씀. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">C<br>화면을 지움. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">O<br>Configuration 메뉴가 나옴 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">X<br>모뎀을 리셋하고 종료 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Q<br>모뎀의 리셋없이 종료한다. 즉 전화 연결이 끊기지 않는다. PPP 연결시 모뎀 연결을 종료하지 않고 PPP 데몬을 가동할 때 사용한다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">J<br>잠시 쉘프롬프트 상태로 빠질 때 사용한다. 다시 돌아 올 때는 쉘에서 fg 명령을 쓴다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Z<br>도움말 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">4. 전화 걸기 </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">전화를 걸려면 두가지 방법이 있다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">4.1 수동 연결 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">미니컴 가동후 텅빈 터미널 화면에서 atdt014XX <enter>하면 된다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">4.2 전화번호부 사용 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">미니컴 가동후 ctrl+a d 키를 누르면 전화번호부 메뉴가 나온다. 이 메뉴에서 좌우 화살표키를 눌러 아래를 선택한다. </span></p><pre><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Dial : 지금 선택한 번호로 전화를 건다.</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Add : 전화 번호 등록</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Edit : 항목 수정</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">Remove : 항목 제거</span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">한글을 쓰려면 터미널 타입을 필히 ansi로 지정하기 바람. 전화번호 등록후 해당 전화번호에 커서를 위치하고 (상하 화살표) 좌우 화살표를 사용 dial을 선택후 <enter>하면 전화가 걸린다. 전화번호부 내용은 사용자 홈디렉토리에 .dialdir 파일에 저장된다. </span></p><h3><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">5. 기타 </span></h3><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">minicom을 root외의 사용자가 사용할수 있으려면 minicom 파일의 허가모드를 setuid root 즉 4555로 해야한다. 그러면 누구나 minicom을 사용할수 있으나 특정 사용자만 사용을 허가하려면 minicom.users에 사용자를 지정한다.</span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">minicom.users를 위치시킬 디렉토리를 알려면 minicom -h 를 준다. 그러면 마지막 줄에 디렉토리 위치를 알려준다. <br>아래는 minicom -h 의 출력이다. 디폴트 디렉토리가 /etc이다. </span></p><pre><span style="FONT-SIZE: 100%">&nbsp;</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">These options can also be specified in the MINICOM environment variable.</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">This variable is currently unset.</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">The LIBDIR to find the configuration files and the</span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">access file minicom.users is compiled as /etc.</span><span style="FONT-SIZE: 100%">&nbsp;</span></pre><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">미니컴의 명령키를 ctrl+a 대신 alt 키를 쓰려면(즉 ctrl+a d 대신 alt+d) 가동시 -m 옵션을 준다. 그러나 이 옵션은 콘솔에서 미니컴을 쓰는 경우에만 가능하다. 다른 통신 프로그램이나 telnet으로 login 한 경우 alt 키를 누르면 그 프로그램에서 alt키를 가로채어 minicom으로 전달되지 않기 때문이다. </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">미니컴의 디폴트 셋업 즉 "save setup as dfl" 로 저장한 내용은 디폴트 디렉토리에 minirc.dfl로 저장된다.(위의 경우 /etc) </span></p><p><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">글쓴 이 : 배철수 &lt;</span><a href="http://www.linuxlab.co.kr/~bae"><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">bae@linuxlab.co.kr</span></a><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림">&gt; </span><span style="FONT-SIZE: 100%; FONT-FAMILY: 굴림"><br>이글은 리눅스 월드 1999년 4월호에 실려 있습니다. </span></p></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] [Solaris] 32-비트 stdio 의 256 파일 디스크립터 제한에 대한 해결책</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2008-06-06 18:12:13</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] [Solaris] 32-비트 stdio 의 256 파일 디스크립터 제한에 대한 해결책</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">From : http://kyiimn.tistory.com/49<br><br><div class="titleWrap"><h1><b><a href="http://kyiimn.tistory.com/49">32-비트 stdio 의 256 파일 디스크립터 제한에 대한 해결책</a></b></h1><span class="category"><a href="http://kyiimn.tistory.com/category/Open%20Source/Open%20Solaris">Open Source/Open Solaris</a> </span><span class="date">2007/12/26 06:57</span></div><!-- titleWrap close --><div class="article"><p><strong>Giri Mandalika</strong> <br><br>역사적으로 32-비트 어플리케이션은 솔라리스 운영체제에서 C 라이브러리의 표준 I/O 함수들을 사용할때 파일 디스크립터를 오직 0 에서 255 까지만을 사용할 수 있도록 제한되었었습니다. 솔라리스10의 확장된 <code>FILE</code> 은 잘-동작하는 32-비트 어플리케이션이 표준 I/O 함수들을 이용해서 어떠한 유효한 파일 디스크립터도 사용할 수 있도록 합니다.</p><p>여기서 잘-동작하는 어플리케이션이란 다음의 3가지 요구조건을 만족하는 것을 의미합니다:</p><ul><li>표준 I/O 스트림과 연관되어 있는 <code>FILE</code> 포인터에 의해 가르켜지고 있는 <code>FILE</code> 구조체의 어떠한 멤버 필드에도 직접적으로 접근하지 않는다 </li><li>에러 상황에 대비해 표준 I/O 함수의 어떠한 리턴값들도 체크한다 </li><li>에러 상황이 보고되었을때 적절한 동작을 한다 </li></ul><p>이 글은 확장된 <code>FILE</code> 설비 하에서 소개된 런타임 및 프로그래밍 해결책에 대해 자세히 설명 합니다. 아래의 내용은 전부 32-비트 어플리케이션에 관계된 이야기 이므로 64-비트 어플리케이션들은 256 파일 디스크립터 제한에 전혀 상관이 없습니다.</p><div><b>역사적 배경</b></div><p>키워드 <a href="http://www.google.com/search?q=solaris+stdio+open+file+descriptors&amp;hl=en&amp;lr=&amp;start=0&amp;sa=N" target="_blank">Solaris <code>stdio</code> open file descriptors</a> 로 간단하게 찾아 본 결과 솔라리스 <code>stdio</code> 의 256 파일 디스크립터 제한에 대한 많은 자료들이 있었습니다. <a href="http://bugs.opensolaris.org/bugdatabase/printableBug.do?bug_id=1085341" target="_blank">1992 request for enhancement (RFE)</a> 가 문제를 설명하고 있습니다: "32-비트 stdio 루틴들은 반드시 255 이상의 파일 디스크립터를 지원해야 한다." 버그 리포트 링크가 몇가지 다른 <code>stdio</code> 의 256 파일 디스크립터 제한에 대한 다른 버그들에 대한 링크를 포함하고 있습니다.</p><p>솔라리스의 이러한 제한은 표준 I/O 스트림과 연관된 파일 디스크립터의 값 이 <code>unsigned char</code> 형태로 저장되기 때문입니다. 어떠한 솔라리스 시스템에서도 찾을 수 있는 헤더 <code>/usr/include/stdio_impl.h</code> 에서 <code>FILE</code> 구조체의 정의를 보면 이 글에서 다루고 있는 해결책 을 다루고 있지 않음을 알 수 있습니다:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>struct __FILE_TAG       <br>{<br>#ifdef _STDIO_REVERSE<br>        unsigned char   *_ptr;<br>        int             _cnt;   <br>#else<br>        int             _cnt;  <br>        unsigned char   *_ptr;  <br>#endif<br>        unsigned char   *_base;<br>        unsigned char   _flag;<br>        <b>unsigned char   _file;  <br>/* UNIX System file descriptor */</b><br>        unsigned        __orientation:2; <br>        unsigned        __ionolock:1;   <br>        unsigned        __seekable:1;<br>        unsigned        __filler:4;<br>};<br></pre></td></tr></tbody></table><br><p>이름 <code>__FILE_TAG</code> 는 단지 <code>FILE</code> 의 alias 입니다. <code><a href="http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/head/stdio_tag.h#36" target="_blank">/usr/include/stdio_tag.h</a></code> 을 보시기 바랍니다. </p><p>멤버 필드 <code>_file</code> 는 파일 디스크립터를 저장하고 있고 <code>unsigned char</code> 타입으로 정의되어 있습니다. <code>unsigned char</code> 는 메모리에서 8비트의 공간을 차지 합니다. 그러므로 <code>_file</code> 은 최고 2^8 즉 256 의 값을 가질 수 있습니다. 다시 말해서 <code>_file</code> 은 32-비트 프로세스당 256개의 파일 디스크립터 만을 가질 수 있도록 제한하고 있습니다. 이러한 제한은 명확하게 <a href="http://docs.sun.com/app/docs/doc/816-5168/6mbb3hrt7?a=view" target="_blank"><code>stdio(3C)</code></a> 에 명시되어 있습니다. </p><p>썬은 더 많은 파일 디스크립터를 수용하도록 하려고 8-비트 <code>unsigned char</code> 를 16-비트 <code>int</code> 로 변경하지는 않았습니다. 왜냐하면 <code>FILE</code> 구조체의 사이즈를 변경 시키는 것이 솔라리스 이전 버전과의 바이너리 호환성을 망가뜨리는 일이기 때문입니다. </p><div><b>해결책</b></div><p>2007년 7월 버전의 솔라리스10 부터 썬은 <code>stdio</code> 의 256 파일 디스크립터 제한을 완화 시킬 수 있는 확장 <code>FILE</code> 설비의 형태로 런타임 그리고 프로그래밍적인 해결책을 제공합니다. <a href="http://www.sun.com/software/solaris/solaris-express/get.jsp" target="_blank">솔라리스 익스프레스</a> 배포판 혹은 <a href="http://www.opensolaris.org/os/downloads/" target="_blank">빌드 39 이후의 오픈솔라리스 배포판</a> 은 이 해결책을 가질 것입니다. 이 글의 <a href="http://developers.sun.com/solaris/articles/stdio_256.html#patchesbugs" target="_blank">패치와 버그</a> 섹션에서는 확장 <code>FILE</code> 설비를 솔라리스10 3/05 에서 11/06 까지의 배포판에 설치하는 법을 포함하고 있습니다.</p><div><b>런타임 해결책</b></div><p>섹션의 제목에서 제안하는 대로 런타임 해결책은 어떠한 종류의 소스코드 변경이나 오브젝트의 재컴파일도 필요로하지 않습니다. 그러나 확장 <code>FILE</code> 설비를 명시적으로 활성화 시키더라도 기존에 존재하는 32-비트 어플리케이션의 기본 동작에는 변함이 없을 것입니다. 이 기능을 활성화 시킨 어플리케이션은 어떠한 유효한 파일 디스크립터라도 표준 I/O 혹은 <code>stdio</code> -- 스트림 과 연관시킬 수 있을 것입니다. 파일 디스크립터는 0, 1 그리고 2 가 기본적으로 <code>stdin</code>, <code>stdout</code>, <code>stderr</code> I/O 스트림들을 위해 예약되어 있습니다.</p><p>여러분은 프로세스-당 최대 파일 디스크립터 숫자를 쉘에서 아래의 커맨드가 리턴하는 값의 이하 혹은 동일한 값으로 설정할 수 있습니다.</p>&lt; <table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>echo 'rlim_fd_max/D' | mdb -k | awk '{ print $2 }'<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p>쉘에서 파일-디스크립터를 조정하기 위해서 <code>sh/ksh/bash</code> 에서는 <code>ulimit -n &lt;max_file_descriptors&gt;</code> 그리고<code> csh</code> 에서는 <code>limit descriptors &lt;max_file_descriptors&gt; </code>를 실행 합니다. 여기서 <code>max_file_descriptors</code> 는 여러분이 원하는 최대 파일 디스크립터 갯수 입니다.</p><p>프로세스가 한번에 열 수 있는 기본적인 파일 갯수의 제한은 65,536 개입니다. 여러분은 이 제한을 <a href="http://docs.sun.com/app/docs/doc/817-0404/6mg74vs9p?a=view#chapter2-31" target="_blank"><code>rlim_fd_max</code></a> 를 통해 조정할 수 있습니다. 비록 <code>rlim_fd_max</code> 파라미터를 조정함으로써 좀 더 많은 파일을 열 수 있지만, 파일을 수백개 열었을때에는 32-비트 프로세스의 가상메모리 공간이 문제가 될 수 있습니다. 프로세스가 가상 메모리의 한계에 다달았을때 <code>stdio</code> 는 <code>Not enough space</code> 에러 를 발생시킵니다. </p><p>32-비트 어플리케이션을 실행하기 전에 다음의 두 단계를 거쳐서 확장 <code>FILE</code> 설비를 활성화 시킵니다:</p><ol><li>쉘에서 파일 디스크립터의 최대 갯수를 증가시킴. </li><li>확장 <code>FILE</code> 설비를 Preload 시킴, <code>/usr/lib/extendedFILE.so.1</code>. </li></ol><p><code>extendedFILE.so.1</code> 은 라이브러리가 아니라 단순히 확장 <code>FILE</code> 설비를 활성화 시켜주는 공유 오브젝트 입니다.</p><p>아래에 <code>ksh</code> 에서 확장 <code>FILE</code> 설비를 활성화 하는 방법이 나와 있습니다:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% ulimit -n<br>256<br><br>% echo 'rlim_fd_max/D' | mdb -k | awk '{ print $2 }'<br>65536<br><br>% ulimit -n 65537<br>ksh: ulimit: exceeds allowable limit<br><br>% <b>ulimit -n 65536</b><br><br>% ulimit -n<br>65536<br><br>% <b>export LD_PRELOAD_32=/usr/lib/extendedFILE.so.1</b><br>% <b>application [arg1 arg2 .. arg<i>n</i>]</b><br></pre></td></tr></tbody></table><br><p>아래의 예제는 간단한 32-비트 프로세스가 확장 <code>FILE</code> 설비를 활성화 혹은 비활성화 시켰을때의 동작에 대해서 보여 줍니다. 테스트 케이스는 간단한 C 프로그램으로 <code>fopen()</code> 인터페이스를 통해서 65,536 개의 파일을 읽도록 시도 합니다.</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% cat fopentestcase.c<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>#define NoOfFILES 65536<br><br>int main()<br>{<br>        char filename[10];<br>        FILE *fds[NoOfFILES];<br>        int i;<br><br>        for (i = 0; i &lt; NoOfFILES; ++i)<br>        {<br>                sprintf (filename, "/tmp/%d.log", i);<br>                fds[i] = fopen(filename, "w");<br><br>                if (fds[i] == NULL)<br>                {<br>                        printf("\nNumber of open files = %d. " \<br>   "fopen() failed with error:  ", i);<br>                        perror("");<br>                        exit(1);<br>                }<br>                else<br>                {<br>                        fprintf (fds[i], "some string");<br>                }<br>        }<br>        return (0);<br>}<br></pre></td></tr></tbody></table><br><p>기본 최대 갯수에 따른 오류를 볼 수 있습니다:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% cc -o fopentestcase fopentestcase.c<br><br>% ulimit -a | grep descriptors<br>nofiles(descriptors) 256<br><br>% ./fopentestcase<br>Number of open files = 253. fopen() failed with error: <br>Too many open files<br></pre></td></tr></tbody></table><br><p>파일 디스크립터 한계를 증가 시키고 확장 <code>FILE</code> 설비를 활성화 시킨 다음 테스트 케이스를 다시 실행 시켜서 해결책이 잘 적용되는지 확인합니다. </p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% <b>ulimit -n 5000</b><br><br>% ulimit -a | grep descriptors<br>nofiles(descriptors) 5000<br><br>% <b>export LD_PRELOAD_32=/usr/lib/extendedFILE.so.1</b><br><br>% ./fopentestcase<br>Number of open files = 4996. fopen() failed with error:  <br>Too many open files<br><br>% <b>ulimit -n 65536</b><br><br>% ulimit -a | grep descriptors<br>nofiles(descriptors) 65536<br><br>% ./fopentestcase<br>Number of open files = 65532. fopen() failed with error:<br>Too many open files<br></pre></td></tr></tbody></table><br><p>파일 디스크팁터가 하나가 부족함을 관찰할 수 있습니다 -- <code>stdin</code>, <code>stdout</code>, <code>stderr</code> 의 0, 1, 2 를 제외한. 확장 <code>FILE</code> 설비가 활성화 되면 파일 디스크립터 196은 예측불가능한 data 훼손을 최소화 하기 위해 기본적으로 비할당 됩니다. 다음 섹션 <a href="http://developers.sun.com/solaris/articles/stdio_256.html#envvar" target="_blank">환경 변수</a> 에서 좀 더 자세한 정보를 확인하시기 바랍니다.</p><p><code>pfiles</code> 의 출력이 위의 설명을 증명하고 있습니다:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% pfiles `pgrep fopentestcase` | egrep "log|:"<br> ...<br> 195: S_IFREG mode:0644 dev:102,7 ino:7380 uid:209044 ...<br>      /tmp/192.log<br> 197: S_IFREG mode:0644 dev:102,7 ino:7381 uid:209044 ...<br>      /tmp/193.log<br> ...<br></pre></td></tr></tbody></table><br><div><b>환경 변수</b></div><p>두가지 환경 변수가 확장 <code>FILE</code> 설비를 조정하는데 사용됩니다: <code>_STDIO_BADFD</code>, <code>_STDIO_BADFD_SIGNAL</code>.</p><ul><li><b><a name="envbadfd"><code>_STDIO_BADFD</code></a></b> -- 이 변수는 3에서 255 사이의 어떠한 종류의 정수 값도 지정될 수 있고 파일 디스크립터에서 비할당됩니다. 이 환경 변수를 설정하는 것은소스 코드가 없는 써드 파티 라이브러리 같은 소프트웨어들의 예측할 수 없는 오류에 대한 보호 메카니즘을 제공하는 것입니다.그럼으로써 예측불가능한 데이타 훼손을 방지할 수 있습니다. 이 환경변수가 없다면 기본적으로 196 이 사용되게 됩니다. <p>여러분이 알다 시피 솔라리스 내의 오브젝트 코드들은 확장 <code>FILE</code> 설비가 존재하기 전에 빌드 된 것으로 8-비트 <code>unsigned char</code> 가 아닌 값을 받아 들이는 것을 기대하지 않을 것이고 확장 <code>FILE</code> 포인터를 다루는 법도 모릅니다. 이러한 이유로 이 값의 범위는 3에서 255 사이로 제한 됩니다. 그럼으로써 코드가 파일 디스크립터를 <code>fileno(3C)</code> 함수 대신 <code>FILE -&gt; _file</code> 을 이용함으로써 실제로 확장 파일 디스크립터가 사용될때 <code>fileno</code> 함수의 에러를 방지할 수 있습니다.</p></li><li><b><a name="envbadfdsignal"><code>_STDIO_BADFD_SIGNAL</code></a></b> -- 이 환경 변수는 특정 코드가 비할당된 파일 디스크립터를 수정하려고 시도할때 발생할 시그널을 지정합니다. 이 환경변수는 유효한 시그널의 정수 혹은 문자열을 가지고 있습니다 <a href="http://docs.sun.com/app/docs/doc/816-5173/6mbb8ae1t?a=view" target="_blank"><code>signal.h(3HEAD)</code></a> 를 통해서 유효한 시그널들을 확인하시기 바랍니다. 이 변수는 만약 확장 <code>FILE</code> 설비의 사용 도중에 어떠한 예외적인 케이스가 발생했을 경우 해달 시그널을 발생시키게 됩니다.기본 시그널은 <code>SIGABRT</code> 입니다. </li></ul><div><b>이 해결책을 쓰지 말아야 할 때</b></div><p>만약 어플리케이션이 다음과 같은 작업을 할때 확장 <code>FILE</code> 설비를 활성화시키지 마시기 바랍니다:</p><ul><li><code>FILE</code> 구조체의 <code>_file</code> 멤버에 직접적으로 접근할때 </li><li>솔라리스 2.7 버전에서 부터 제거된 <code>fileno()</code> 매크로를 <code>fileno(FILE)</code> 함 수 대신 파일 디스크립터를 얻기 위해 사용할때 </li></ul><p>이 기능이 활성화 되면 255 이상의 파일 디스크립터는 어플리케이션의 임시 공간에 저장될 것입니다. 그리고 환경변수 <code>_STDIO_BADFD</code> 가 가지고 있는 비할당되거나 잘못된 파일 디스크립터는 <code>FILE -&gt; _file</code> 멤버 필드에 저장될 것입니다. 어플리케이션의 부적절한 <code>FILE -&gt; _file</code> 접근은 255 이상의 비할당된 잘못된 파일 디스크립터를 돌려 줄 것이고 이것은 예측불가능한 데이타 오류를 유발합니다.</p><p>또한 데이타 오류는 프로세스가 <code>fileno(FILE)</code> 함수에서 리턴 되는 값을 짤라버림으로써 발생할 수도 있습니다. 예를 들어 만약 16-비트 혹은 32-비트 <code>int</code> 값이 <code>fileno()</code> 함수에 의해 리턴 되서 8-비트 <code>unsigned char</code> 변수에 저장되면 짤림 현상이 발생하게 됩니다. 짤려져 버린 파일 디스크립터에 접근하게 되면 에러를 유발할 것입니다.</p><p>다음의 에러 메세지는 어플리케이션이 런타임시에 <code>stdio</code> 를 이용해 <code>FILE</code> 구조체의 파일 디스크립터 멤버 필드를 수정하고자 할때 발생합니다.</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>Application violated extended FILE safety mechanism.<br>Please read the man page for extendedFILE.<br>Aborting<br></pre></td></tr></tbody></table><br><p>이러한 메세지를 만나게 되면 어플리케이션에서 확장 <code>FILE</code> 설비의 사용을 중단해야 합니다. 만약 가능하다면 소스의 <code>FILE -&gt; _file</code> 로직 대신에 <code>fileno(FILE)</code> 을 사용하도록 수정 합니다. 이 런타임 에러를 무시하는 것인 데이타 오류를 유발시킬 수 있습니다.</p><div><b>예제</b></div><p>다음의 간단한 예제는 두 환경 변수 <code>_STDIO_BADFD</code>, <code>_STDIO_BADFD_SIGNAL</code> 의 사용 법을 나타내고 있습니다. 또한 확장 <code>FILE</code> 설비의 안전 메카니즘을 위반함으로써 프로그램이 크래쉬 되는 것도 보여주고 있습니다.</p><p>확장 <code>FILE</code> 해결책이 적용되지 않은 솔라리스 시스템에서 다음의 코드를 컴파일 하고 라이브러리를 빌드 합니다. 주의: 패치 되지 않은 솔라리스10 3/05 버전에서 부터 11/06 버전의 배포판은 확장 <code>FILE</code> 해결책을 포함하고 있지 않습니다. 그러나 최신 커널 패치와 <code>libc</code> 패치를 적용함으로써 설치 할 수 있습니다. <a href="http://developers.sun.com/solaris/articles/stdio_256.html#patchesbugs" target="_blank">패치와 버그</a> 섹션을 참고하시기 바랍니다.</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% cat thirdpartysrc.c<br><br>#include &lt;stdio.h&gt;<br><br>void manipulatefd (FILE *fptr)<br>{<br>        ;<br>        ;<br>        fprintf(stdout, "\n%s : manipulatefd(): " \<br>"underlying file descriptor = %d\n", \<br>__FILE__, fptr -&gt; _file);<br>        <b>fptr -&gt; _file = 123;<br>        fprintf(fptr, "This call is gonna fail!\n");</b><br>        ;<br>        ;<br>}<br><br>% cc -G -o /tmp/libthirdparty.so thirdpartysrc.c<br></pre></td></tr></tbody></table><br><p>아래의 코드를 확장 <code>FILE</code> 설비가 설치 되어 있는 솔라리스에서 이전에 생성한 라이브러리를 이용해서 컴파일 하고 빌드합니다. :</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% cat enableextfile.c<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>#define NoOfFiles 500<br><br>void manipulatefd(FILE *);<br><br>int main ()<br>{<br>        FILE *fptr;<br>        int i;<br><br>        for (i = 0; i &lt; NoOfFiles; i++)<br>        {<br>                fptr = fopen("/tmp/enable_test.txt", "w");<br><br>                if (fptr == NULL)<br>                {<br>                        perror("fopen failed. ");<br>                        exit(1);<br>                }<br><br>                printf("\nfd = %d", fileno(fptr));<br><br>                if (fileno(fptr) % 400 == 0)<br>                {<br>                        manipulatefd(fptr);<br>                }<br>        }<br><br>        return(0);<br>}<br><br>% export LD_LIBRARY_PATH=/tmp:$LD_LIBRARY_PATH<br>% cc -o enableextfile -lthirdparty enableextfile.c<br></pre></td></tr></tbody></table><br><p>프로세스당 파일 디스크립터의 최대 갯수를 255 이상으로 증가시키고, 환경변수 <code>_STDIO_BADFD</code> 와 <code>_STDIO_BADFD_SIGNAL</code> 를 설정하고 확장 <code>FILE</code> 설비를 <code>/usr/lib/extendedFILE.so.1</code> 을 reloading 시킴으로써 활성화 시킨 다음 실행파일을 실행시킵니다:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% ulimit -n<br>256<br><br>% <b>ulimit -n 500</b><br><br>% ulimit -n<br>500<br><br>% <b>export _STDIO_BADFD=196</b><br>% <b>export _STDIO_BADFD_SIGNAL=SIGABRT</b><br>% <b>export LD_PRELOAD_32=/usr/lib/extendedFILE.so.1</b><br><br>% ./enableextfile<br>fd = 3<br>fd = 4<br>fd = 5<br>...<br>...<br>fd = 398<br>fd = 399<br>fd = 400<br>thirdpartysrc.c : manipulatefd(): <br>underlying file descriptor = 196<br><b>Application violated extended FILE safety mechanism.<br>Please read the man page for extendedFILE.<br>Aborting</b><br>Abort(coredump)<br><br>% /usr/bin/pstack core<br>core 'core' of 10172:   ./enableextfile<br> d1f28e65 _lwp_kill (1, 6) + 15<br> d1ee2102 raise    (6) + 22<br> d1ec0dad abort    (0, 80677e0, d1f60000, ...) + cd<br> d1f01d54 _file_get (80677e0) + b4<br> d1efeb21 _findbuf (80677e0) + 31<br> d1ef2f16 _ndoprnt (d1f70344, 80471d4, 80677e0, 0) + 46<br> d1ef669f <b>fprintf</b>  (80677e0, d1f70344) + 9f<br> d1f702cb <b>manipulatefd</b> (80677e0) + 3b<br> 0805097f main     (1, 8047214, 804721c) + 9f<br> 0805084a _start   (1, 8047360, 0, 8047370, ... ) + 7a<br></pre></td></tr></tbody></table><br><p>만약 어플리케이션이 이전에 언급했던 패턴을 보여주지 않는 다면 위의 런타임 해결책의 장점을 취할 수 있습니다. 즉 솔라리스 7 혹은 그 이전 버전의 어플리케이션이라도 문제 없이 동작할 수 있습니다.</p><p><a href="http://docs.sun.com/app/docs/doc/819-2252/6n4i8rtpo?a=view" target="_blank"><code>extendedFILE(5)</code></a> 의 멘 페이지에서 좀 더 많은 예제를 보실 수 있습니다.</p><div><b>프로그래밍 해결책</b></div><p>이 섹션은 개발자가 손쉽게 수정할 수 있는 새로운 어플리케이션들을 위해 작성되었습니다.</p><p>두개의 프로그래밍 인터페이스가 256 파일 디스크립터 접근을 지원합니다. 주의할 점은 최대 파일 디스크립터의 갯수는 여전히 256이라는 것입니다.</p><div><b>향상된 표준 I/O Open 함수들: <code>fopen(3C)</code>, <code>fdopen(3C)</code>, <code>popen(3C)</code></b></div><p>현존하고 있는 소스들을 수정하는 수고를 덜기 위해서 확장<code> FILE </code>기능의 장점을 이용합니다. <code>stdio</code> open 함수의 mode 문자열이 새로운 플래그 F 에 의해 확장 됩니다. 예를 들어:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>FILE *fptr = fopen("dummy.txt", "r<b>F</b>");<br><br>int fd = creat("dummy2.txt", S_IWUSR);<br>FILE *stream = fdopen(fd, "w<b>F</b>");<br><br>FILE *ptr = popen("/usr/bin/ls *.txt", "r<b>F</b>");<br></pre></td></tr></tbody></table><br><p>만약 mode 문자열의 마지막 문자가 F 라면 32-비트 프로세스들은 스트림을 255 이상의 파일 디스크립터와 연관시키는것이 허용 됩니다. 64-비트 어플리케이션에서 어플리케이션은 F 문자를 조용히 무시해 버립니다. 이러한 마이너한 변경을 제외하고기존에 존재하는 <code>stdio</code> open 함수의 구문에는 전혀 변화가 없습니다.</p><p><code>stdio</code> open 함수의 F mode 문자열은 아래의 작업을 실행하지 않는 코드들을 위해서만 사용됩니다:</p><ul><li><code>FILE</code> 구조체의 멤버필드에 직접 접근하지 않음 </li><li><code>FILE</code> 포인터를 호출자에게 돌려줌 </li></ul><p>만약 어플리케이션이 이전에 언급되었던 패턴을 보여 준다면 문자열 F 는 확장 <code>FILE</code> 기능을 사용하기 위해 mode 문자열에 추가되어서는 안됩니다. 데이타 오류가 발생할 수 있기 때문입니다.</p><o>데이타 오류는 확장 <code>FILE</code> 포인터가 유저가 알 수 없는 바이너리 코드를 가르키도록 할 수 있습니다 -- 그럼으로서 호출자는 이것을 어떻게 처리해야 할지 모르게 됩니다. 이 인터페이스는 확장 <code>FILE</code> 포인터의 잘못된 사용을 막아 줄수 있는 안정장치를 제공하지 않습니다. 만약 <code>FILE</code> 포인터가 특정 코드에 반드시 리턴되어야 한다면 <code>enable_extended_FILE_stdio(3C)</code> 을 사용 할 것을 권장합니다. <p>위의 예제에서 아래의 라인을 수정한 후에 재빌드 합니다</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>fds[i] = fopen(filename, "w");<br></pre></td></tr></tbody></table><br><p>이렇게:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>fds[i] = fopen(filename, "wF");<br></pre></td></tr></tbody></table><br><p>이제 파일 디스크립터의 제한을 증가시킨후에 테스트 케이스를 실행시키면 다음과 같은 결과를 얻을 수 있습니다:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% cc -o fopentestcaseF fopentestcase.c<br><br>% ulimit -n 10000<br><br>% ulimit -a | grep descriptors<br>nofiles(descriptors) 10000<br><br>% ./fopentestcaseF<br>Number of open files = 9996. fopen() failed with error:  <br>Too many open files<br></pre></td></tr></tbody></table><br><p>작동을 위한 어떠한 특수 라이브러리들도 지정되지 않은채 링크 되었음을 주의하시기 바랍니다. 모든 <code>stdio</code> 루틴들은 여전히 <code>libc</code> 의 일부입니다. </p><p><a href="http://docs.sun.com/app/docs/doc/819-2243/6n4i098vg?a=view" target="_blank"><code>fopen(3C)</code></a>, <a href="http://docs.sun.com/app/docs/doc/819-2243/6n4i098ug?a=view" target="_blank"><code>fdopen(3C)</code></a>, <a href="http://docs.sun.com/app/docs/doc/819-2243/6n4i09981?a=view" target="_blank"><code>popen(3C)</code></a> 의 멘페이지를 참고하시기 바랍니다. </p><div><b>새로운 프로그래밍 인터페이스: <code>enable_extended_FILE_stdio(3C)</code></b></div><p>만약 <code>FILE</code> 포인터가 계속적으로 하나의 함수 문맥에서만 사용되도록 제한되지 않는 다면 새로운 프로그래밍 인터페이스 <code>enable_extended_FILE_stdio(<font color="green">3C</font>)</code> 를 이용해서 확장 <code>FILE</code> 설비를 활성화 할 수 있습니다. 이 인터페이스는 몇몇 보호 메카니즘을 제공함으로써 데이타의 오류를 최소화 시켜 줍니다. 예를 들어 인터페이스를 사용함으로써 사용자는 어플리케이션이 런타임시에 <code>FILE -&gt; _file</code> 을 부적절하게 접근했을때 프로세스에게 전달될 시그널을 선택할 수 있습니다.</p><p><code>/usr/include/stdio_ext.h</code> 헤더에 정의된 새로운 인터페이스는 다음과 같습니다:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>int enable_extended_FILE_stdio(int, int);<br></pre></td></tr></tbody></table><br><p>첫번째 정수 매개변수는 비할당 파일 디스크립터로 선택할 3 에서 355 사이즤 파일 디스크립터를 가르킵니다. -1 을 설정하게 되면 <code>enable_extended_FILE_stdio(3C)</code> 가 적절한 비할당 파일 디스크립트를 선택 할 수 있도록 합니다. 이것은 환경변수 <code><a href="http://developers.sun.com/solaris/articles/stdio_256.html#envbadfd" target="_blank">_STDIO_BADFD</a></code> 을 설정했을때와 비슷합니다.</p><p>두번째 정수 매개변수는 비할당 파일 디스크립터가 <code>close(2)</code> 혹은 <code>closefrom(3C)</code> 이외의 시스템 콜에 의해서 사용되었을때 발생할 시그널을 가르킵니다. 몇몇 어플리케이션들은 열지도 않은 파일 디스크립터를 닫으려고 시도할 것입니다. 이 예외는 어플리케이션이 비정상적으로 크래쉬 되는 것을 방지해 줍니다.</p><p>만약 -1 이 전달되면 기본 시그 <code>SIGABRT</code> 가 프로세스에 전달 됩니다. 값 0 은 시그널을 보내는 것을 비활성화 함으로써 <code>FILE -&gt; _file</code> 참고 작업을 무시해 버립니다. 이외의 경우에는 지정된 시그널이 프로세스로 전달 됩니다 <a href="http://docs.sun.com/app/docs/doc/816-5173/6mbb8ae1t?a=view" target="_blank"><code>signal.h(3HEAD)</code></a> 멘 페이지를 통해서 솔라리스의 전체 시그널 리스트를 참고하시기 바랍니다. 이것은 환경 변수 <code><a href="http://developers.sun.com/solaris/articles/stdio_256.html#envbadfdsignal" target="_blank">_STDIO_BADFD_SIGNAL</a></code> 을 설정하는 것과 유사합니다.</p><p><code>enable_extended_FILE_stdio(3C)</code> 함수는 오직 32-비트 컴파일 환경에서만 사용 가능합니다.</p><p>확장 <code>FILE</code> 설비가 유효하면 프로세스의 파일 디스크립터 제한을 256 이상으로 증가시켜도 언제든지 프로세스가 파일을 열 수 있습니다. <a href="http://docs.sun.com/app/docs/doc/817-0404/6mg74vs9p?a=view#chapter2-31" target="_blank"><code>rlim_fd_max</code></a> 커널 파라미터의 정보를 확인하시기 바랍니다. 여러분은 <code>ulimit/limit</code> 커맨드를 이용하거나 프로그래밍 적으로<code>/usr/include/sys/resource.h</code> 에서 정의된 <code>getrlimit(2)/setrlimit(2)</code> 함수를 사용할 수 있습니다. functions defined in the <code>/usr/include/sys/resource.h</code> header.</p><p>아래에는 다음의 3가지를 보여주는 간단한 프로그래밍 예제가 있습니다:</p><ul><li>파일 디스크립터 제한을 <code>getrlimit(2)/setrlimit(2)</code> 인터페이스를 통해 설정 </li><li>확장 <code>FILE</code> 설비 를 활성화 하기 위한 새로운 함수의 사용 예 </li><li><code>FILE -&gt; _file</code> 의 값을 직접 변경함으로써 어플리케이션의 크래쉬를 유도 </li></ul><p>아래의 코드를 컴파일하고 <a href="http://developers.sun.com/solaris/articles/stdio_256.html#rtsolution" target="_blank">런타임 해결책</a> 섹션에서 만들었었던 <code>libthirdparty.so</code> 라이브러리를 이용해 링크 합니다.</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>% cat enableextfilestdio.c<br><br>#include &lt;stdio.h&gt;<br><b>#include &lt;stdio_ext.h&gt;</b><br>#include &lt;stdlib.h&gt;<br>#include &lt;sys/resource.h&gt;<br><br>#define NoOfFiles 500<br><br>void manipulatefd(FILE *);<br><br>int main ()<br>{<br>        FILE *fptr;<br>        struct rlimit rlp;<br>        int i;<br><br>        <b>(void) getrlimit (RLIMIT_NOFILE, &amp;rlp);</b><br>/* set the desired number of file descriptors */<br>        <b>rlp.rlim_cur = NoOfFiles;</b><br><br>        if (<b>setrlimit (RLIMIT_NOFILE, &amp;rlp)</b> == -1)<br>        {<br>                perror ("setrlimit(): ");<br>                exit (1);<br>        }<br><br>        if (<b>enable_extended_FILE_stdio (-1, -1)</b> == -1)<br>        {<br>                perror ("enable_extended_FILE_stdio(3C): ");<br>                exit (1);<br>        }<br><br>        for (i = 0; i &lt; NoOfFiles; i++)<br>        {<br>                fptr = fopen ("/tmp/enable_test.txt", "w");<br><br>                if (fptr == NULL)<br>                {<br>perror("\nfopen failed. ");<br>                        exit (1);<br>                }<br><br>                printf ("\nfd = %d", fileno(fptr));<br><br>                if (fileno (fptr) % 400 == 0)<br>                {<br>                        manipulatefd (fptr);<br>                }<br>        }<br><br>        return (0);<br>}<br><br>% export LD_LIBRARY_PATH=/tmp:$LD_LIBRARY_PATH<br>% cc -o enableextfilestdio -lthirdparty enableextfilestdio.c<br><br>% ./enableextfilestdio<br>fd = 3<br>fd = 4<br>fd = 5<br>...<br>...<br>fd = 398<br>fd = 399<br>fd = 400<br>thirdpartysrc.c : manipulatefd(): <br>underlying file descriptor = 196<br><b>Application violated extended FILE safety mechanism.<br>Please read the man page for extendedFILE.<br>Aborting<br>Abort</b> (core dumped)<br></pre></td></tr></tbody></table><br><!-- END VCD7 CODE SAMPLE COMPONENT  --><p><a href="http://docs.sun.com/app/docs/doc/819-2243/6n4i098tj?a=view" target="_blank"><code>enable_extended_FILE_stdio(3C)</code></a> 의 멘페이지에서 더 자세한 정보를 확인하시기 바랍니다.</p><div><b>경고: 솔라리스의 다음 메이저 고객 버전에서 <code>_file</code> 은 <code>_magic</code> 으로 변경됨</b></div><div class="contentdivider"><table class="grey4" width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img alt=" " src="file:///D:/im/a.gif" width="1" border="0" height="4"></td></tr></tbody></table><br></div><p>확장 <code>FILE</code> 메카니즘을 사용하는데에 안정성을 보장하기 위해 <code>FILE</code> 구조체의 <code>_file</code> 멤버 필드는 완전히 <code>_magic</code> 으로 <a href="http://www.sun.com/software/solaris/solaris-express/" target="_blank">솔라리스 익스프레스, </a>빌드 39 이후의 <a href="http://opensolaris.org/os/downloads/" target="_blank">오픈솔라리스</a> 소스 코드에서 완전히 바뀌게 됩니다. 이러한 변경은 <code>FILE -&gt; _file</code> 를 참조로 하는 모든 소스 코드의 컴파일에 영향을 미치게 됩니다. 주의: 이 경고는 업데이트를 포함한 솔라리스10 에는 적용되지 않습니다.</p><p>다음의 <code>diff</code> 출력이 <code>FILE</code> 구조체에서 확장 <code>FILE</code> 설비를 수용하도록 정의가 변경된 것을 보여 줍니다:</p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>- unsigned char _file;  /* UNIX system file descriptor */<br><b>+ unsigned char _magic; /*Old home of the file descriptor*/<br>+          /* Only fileno(3C) can retrieve the value now */</b><br><br>- unsigned  __filler:4;<br><b>+ unsigned  __extendedfd:1; /* enable extended FILE */<br>+ unsigned  __xf_nocheck:1; /*no extended FILE runtime check*/</b><br>+ unsigned  __filler:10;<br></pre></td></tr></tbody></table><br><p>그러므로 <code>FILE -&gt; _file</code> 참조를 사용하는 프로그램은 <a href="http://www.sun.com/software/solaris/solaris-express/get.jsp" target="_blank">솔라리스 익스프레스</a> 혹은 빌드 39 이후의 <a href="http://www.opensolaris.org/os/downloads/" target="_blank">오픈솔라리스</a> 에서 아래의 오류와 함께 실패할 것입니다. </p><table class="grey4" width="100%" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td><pre>"filename.c", line xx: <b>undefined struct/union member: _file</b><br>cc: acomp failed for filename.c<br></pre></td></tr></tbody></table><br><p><code>_file</code> 는 더이상 <code>FILE</code> 의 파일 디스크립터 내에 존재하지 않습니다. 만약 코드가 단순히 <code>_file</code> 을 읽어 오는 것이라면 모든 소스코드를 적절한 <code>fileno(FILE)</code> 를 사용하는 것으로 교체해 주면 됩니다. <a href="http://docs.sun.com/app/docs/doc/816-5168/6mbb3hr96?a=view" target="_blank"><code>fileno(3C)</code></a> 의 멘페이지를 참고하시기 바랍니다. 이제 더이상 <code>_file</code> 에 새로운 값을 대입해 주면 안됩니다. </p><div><b>런타임 퍼포먼스의 영향</b></div><p>확장 <code>FILE</code> 설비가 활성화 되도 255 보다 작거나 같은 파일디스크립터를 접근하는데에는 어떠한퍼포먼스 영향도 없습니다. 그러나 256 이상에서는 약간의 퍼포먼스 저하가 생길 수 있습니다. 파일 디스크립터를 임시 장소에저장하고 읽어와야 하기 때문입니다.</p><div><b>패치와 버그</b></div><p>만약 여러분의 시스템이 솔라리스10 3/05 버전에서 11/06 버전 사이를 운용하고 있다면 확장 <code>FILE</code> 설비를 다음의 패치들을 설치 함으로써 사용 할 수 있습니다.:</p><p><i>SPARC 플랫폼:</i></p><ul><li><a href="http://sunsolve.sun.com/search/document.do?assetkey=urn:cds:docid:1-21-125100-04-1" target="_blank">125100-04 Kernel Update Patch</a> </li><li><a href="http://sunsolve.sun.com/search/document.do?assetkey=urn:cds:docid:1-21-120473-05-1" target="_blank">120473-05 <code>libc nss ldap PAM zfs</code> Patch </a></li><li><a href="http://sunsolve.sun.com/search/document.do?assetkey=urn:cds:docid:1-21-125800-01-1" target="_blank">125800-01 Fault Manager Patch</a> </li></ul><p><i>x86/x64 플랫폼:</i></p><ul><li><a href="http://sunsolve.sun.com/search/document.do?assetkey=urn:cds:docid:1-21-125101-04-1" target="_blank">125101-04 Kernel Update Patch</a> </li><li><a href="http://sunsolve.sun.com/search/document.do?assetkey=urn:cds:docid:1-21-120037-15-1" target="_blank">120037-15 <code>libc nss ldap PAM zfs</code> Patch</a> </li><li><a href="http://sunsolve.sun.com/search/document.do?assetkey=urn:cds:docid:1-21-125801-01-1" target="_blank">125801-01 Fault Manager Patch</a> </li></ul><p>만약 어플리케이션 코드가 썬 스튜디오 소프트웨어 컴파일러에 기본적으로 제공되는 <a href="http://www.stlport.org/" target="_blank"><code>STLport</code></a> 에 의해 링크되었다면 <code>-library=stlport4</code> 컴파일러 옵션을 사용하고 썬 스튜디오 11 소프트웨어를 SPARC 에서 <a href="http://sunsolve.sun.com/search/document.do?assetkey=urn:cds:docid:1-21-121017-07-1" target="_blank">121017-07</a> 혹은 그 이후 그리고 x86 플랫폼에서 <a href="http://sunsolve.sun.com/search/document.do?assetkey=urn:cds:docid:1-21-121018-07-1" target="_blank">121018-07</a> 이후 버전의 패치를 설치 해서 확장 <code>FILE</code>설비를 사용할 수 있도록 합니다.</p><p>확장 <code>FILE</code> 설비의 버그는 <a href="http://bugs.opensolaris.org/" target="_blank">오픈솔라리스 버그 페이지</a> 에 신고해주시거나 오픈솔라리스 <a href="http://www.opensolaris.org/os/discussions/" target="_blank">토론 포럼</a> 에 신고해주시기 바랍니다.</p><div><b>참고자료</b></div><p>PSARC/2006/162: <a href="http://www.opensolaris.org/os/community/arc/caselog/2006/162/" target="_blank">Extended <code>FILE</code> Space for 32-Bit Solaris Processes</a> </p><p>메뉴얼 페이지:</p><ul><li><a href="http://docs.sun.com/app/docs/doc/816-5168/6mbb3hrt7?a=view" target="_blank"><code>stdio(3C)</code></a> </li><li><a href="http://docs.sun.com/app/docs/doc/819-2252/6n4i8rtpo?a=view" target="_blank"><code>extendedFILE(5)</code></a> </li><li><a href="http://docs.sun.com/app/docs/doc/819-2243/6n4i098tj?a=view" target="_blank"><code>enable_extended_FILE_stdio(3C)</code></a> </li><li><a href="http://docs.sun.com/app/docs/doc/816-5168/6mbb3hr96?a=view" target="_blank"><code>fileno(3C)</code></a> </li><li><a href="http://docs.sun.com/app/docs/doc/819-2243/6n4i098vg?a=view" target="_blank"><code>fopen(3C)</code></a> </li><li><a href="http://docs.sun.com/app/docs/doc/819-2243/6n4i098ug?a=view" target="_blank"><code>fdopen(3C)</code></a> </li><li><a href="http://docs.sun.com/app/docs/doc/819-2243/6n4i09981?a=view" target="_blank"><code>popen(3C)</code></a> </li><li><a href="http://docs.sun.com/app/docs/doc/817-0404/6mg74vs9p?a=view#chapter2-31" target="_blank"><code>rlim_fd_max</code></a> </li><li><a href="http://docs.sun.com/app/docs/doc/816-5173/6mbb8ae1t?a=view" target="_blank"><code>signal.h(3HEAD)</code></a> </li></ul><div><b>저자에 관하여 </b></div><p><b>Giri Mandalika</b> 은 썬 마이크로시스템즈 ISV-엔지니어링 그룹의 소프트웨어 엔지니어로 썬이엔터프라이즈 어플리케이션을 실행하는데에 있어서 선호되는 기업이 되도록 노력하고 있습니다. Giri 는 텍사스 대학에서 컴퓨터공학 박사 학위를 가지고 있습니다.<br></p></o></div><div class="author"><span class="text">Posted by </span>인이</div><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] 메모리 체크, purify, ZeroFault, 아이락(Airac)</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2007-11-30 16:08:31</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] 메모리 체크, purify, ZeroFault, 아이락(Airac)</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">실행하지 않고, 소스만으로 오류를 찾아낸다, 과연??<br>아무튼 기존 상용제품에 비해 어느정도의 기능만 갖춰도 대단한 것. 평가판을 받을수 없나??<br><br>From : http://ropas.snu.ac.kr/2004/airac/<br><br><br><br><span style="font-size: 4.3em; color: rgb(153, 51, 204);">Airac</span> <br><span style="font-size: 1.6em; color: rgb(153, 51, 204);">Static Analyzer for Automatic Verification of Array Index Ranges in C Programs</span> <p class="subtitle"><font color="#9933cc" size="2"><a href="http://ropas.snu.ac.kr/">Programming Research Laboratory</a>/ <a href="http://www.snu.ac.kr/">Seoul National University</a></font> </p><h3><a id="newest" name="introduction"><font color="black">Introduction</font></a> </h3><p>Airac은 C 프로그램에 있을 수 있는 배열 인덱스 에러를 미리 모두 찾아준다. C 프로그램에서 배열의 접근은 항상 배열의 내부에 국한되야 한다. Airac은 주어진 C 프로그램의 모든 실행 상황을 분석해서, 배열 외부로 접근하는 경우가 있으면 빠뜨림없이 찾아준다. <!--       <ul>         <li> &quot;미리&quot;: 프로그램을 돌리지 않고 찾는다.</li>         <li>&quot;모두&quot;: 있을 수 있는 인덱스 에러를 모두 찾는다.</li>         <li>&quot;C&quot;: ANSI C로 짜여진 모든 C 프로그램. 단, 변수의      타입이 실행중에 임의로 바뀌는 프로그램은 제외.</li>      </ul>--></p><p>예를 들어, 아래의 파란색 식들은 모두 배열 a를 건드리는 경우인데, 이것들 중에서 a의 범위를 벗어나는 것이 있는 지를 검증해 준다.</p><ul><address>int *a = (int *)malloc(sizeof(int)*10); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* int array of size 10 */<br><font color="#0033ff">a[i] </font>= 1; <font color="#0033ff">a[i + f()]</font><font color="#00ff99"> </font>= 1; <font color="#0033ff">a[*k + (*g)()] </font>= 1; /* accesses to a */ <br>x = a; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0033ff">x[1] </font>= <font color="#0033ff">*(x+1)</font>+1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* a and x are aliases */<br>y = a + f(); &nbsp;&nbsp;&nbsp;<font color="#0033ff">y[*(y+1)] </font>= 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* some of a and y are aliases */ <br>z-&gt;v = a; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0033ff">(z-&gt;v)+i</font><font color="#00ff99"> </font>= 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* a is pointed to by a struct */ <br></address></ul><p></p><p>Airac statically detects all the array index errors in C programs. Array index error occurs when the index number is outside the array's size. Airac statically finds all such errors that can happen at run-time. </p><p>For example, in the above C expressions where blue-colored expressions access array <it>a</it>, Airac checks if the accesses can overrun the target array. </p><h5>Keywords</h5><ul><li><font color="orange">C</font>: Airac analyzes any typeful C program. <br>Airac supports the full set of typeful ANSI C. Typeful C programs are those whose variables' types remain the same as at their initializations. </li><li><font color="orange">statically</font>: Airac does not execute the input programs. <br>Airac analyzes the input C programs at their compile-time. </li><li><font color="orange">all</font>: Airac is exhaustive. <br>Airac does not miss noticing any array index overrun in the input C programs. Airac considers the input program's all run-time behavior. </li><li><font color="orange">automatic</font>: Airac does not need any help from the user. <br>Airac does not ask for any annotation about the input C programs. </li><li><font color="orange">always stops</font>: Airac always terminates even for non-terminating programs. </li><li><font color="orange">modular</font>: Airac accepts separate C files that constitute a C program. </li><li><font color="orange">correct</font>: Airac's design is proven correct. </li><li><font color="orange">nML</font>: Airac is implemented completely in <a href="http://ropas.snu.ac.kr/n">nML</a> (Korean ML), a higher-order and typed programming language system. </li></ul><h3><a name="perf">Performance</a></h3><ul><li><a href="performance">Analysis Cost, Accuracy &amp; Scalability</a> </li><li><a href="vs-coverity">Comparison</a> against <a href="http://www.coverity.com/">Coverity.com's SWAT</a> </li><li><a href="demo.cgi">On-Line Demo</a> </li><li><a href="false_alarm">False Alarms</a> </li></ul><h3><a name="releases">Releases</a> </h3>External releases of the binary executable and its <a href="http://ropas.snu.ac.kr/n">nML</a> source is available only to the contractor (Samsung Electronics Co.). <ul><li><a href="airac-2.0.zip">airac-2.0.zip</a>, <a href="airac-2.0-src.zip">airac-2.0-src.zip</a> (2.0 release) 2005-01-20 <img class="inline" alt="New" src="new-icon.bmp"> </li><li><a href="airac-1.0.zip">airac-1.0.zip</a> (1.0 release) 2004-12-06 <!--          <li><a href="airac-1.1.zip">airac-1.1.zip</a> (1.1 release) 2004-12-15          </li>          <li><a href="airac-1.0rc3.tar.gz">airac-1.0rc3.tar.gz</a> (1.0 rc3)          </li>          <li><a href="airac-20041102.zip">airac-20041102.zip</a> (1.0 rc2)          </li>          <li><a href="airac-20041025.zip">airac-20041025.zip</a> (1.0 rc)          </li>          <li><a href="airac-20040925.zip">airac-20040925.zip</a> (alpha 0.9)          </li>          <li><a href="airac-20040922.zip">airac-20040922.zip</a> (alpha 0.7)          </li>--></li></ul><h3><a id="newest" name="technology">Technology</a> </h3><p></p><p>Airac은 정적 프로그램 분석(static program analysis) 기술로 가능하다. 정적 프로그램 분석기술은 프로그램의 실행중에 발생할 수 있는 모든 상황을 실행전에 자동으로 유한시간내에 예측해내는 기술이다. Airac은 이 기술을 이용해서 C 프로그램에서 배열에 접근하는 모든 경우가 항상 배열의 내부에 머무는 지를 확인해 준다. 그렇지 못하게 되는 경우는 빠뜨림없이 보고해준다. Airac의 모든 것은 <a href="/n/">nML</a>로 구현되어 있다. </p><p></p><p>Airac is based on the static program analysis technology. Static program analysis is a technique for compile-time, safe, and automatic estimation of program's run-time behavior. Airac safely estimates all the input C program's run-time behavior and detects every array index error. Airac is implemented completely in <a href="/n/">nML</a>, a Korean ML. <!--      <h3><a id="newest" name="limitation">Limitation</a> </h3>      <p>      <p>Airac의 분석결과는 실제 발생할 수 있는 인덱스 에러를       모두 찾아주는데, 실제에서는 발생할 수 없는 인덱스 에러를      포함하는 경우도 있다. 진짜를 모두 포함하지만 가짜 정보가 낄 수 있는      것이다. 이는 유한한 시간안에 무한할 수 있는 실제 상황을 모두 예측해야      하기 때문이다. Airac은 가짜가 끼는 경우가 최소가 되도록 분석의 정확도가      높으면서 분석의 비용은 작다.      <p>      <p>Though Airac finds all the array index errors, the analysis      result can contain some errors that are impossible at      run-time. Airac sometimes reports some spurious errors, which is,      in priciple, inevitable because Airac is a static analyzer that finitely      estimates possibly infinite run-time behaviors of C programs.       Airac minimizes such false alarms while maintaining the analysis      cost low. --></p><h3><a id="newest" name="whitepaper">Documents</a> </h3><ul><li><a href="/%7Ekwang/paper/05-sas-jukishyi.pdf">Taming False Alarms from a Domain-Unaware C Analyzer by a Bayesian Statistical Post Analysis</a>, <br><a href="http://www.doc.ic.ac.uk/%7Esas2005">SAS'05: International Static Analysis Symposium</a>, London, 2005 </li><li><a href="/%7Ekwang/paper/05-bugs-jukishyi.pdf">Soundness by Static Analysis and False-alarm Removal by Statistical Analysis: Our Airac Experience</a>, <br><a href="http://www.cs.umd.edu/%7Epugh/BugWorkshop05/">Bugs 2005 Workshop on the Evaluation of Software Defect Detection Tools</a>, Chicago, 2005 </li><li><a href="/%7Ekwang/paper/05-maso-jukishyi.pdf">자동 오류 검출을 위한 프로그램 분석기 - 아이락</a>, <font size="1">[마이크로 소프트웨어], 2005년 6월호</font> </li><li><a href="airac.pdf">White paper</a> <!--           (<small><a href="airac.pdf">for Samsung Electronics</a></small>)--></li><li><a href="/%7Ekwang/papers.html">Foundational/background research papers</a> </li></ul><h3><a href="media.html">Media Coverage</a></h3><h3><a id="newest" name="contact">Contact</a> </h3><a href="/%7Ekwang/">Prof. Kwangkeun Yi</a> (이광근 교수)<br>+82 2 880 1857<br>kwang at ropas.snu.ac.kr<br>Rm 428, Bldg 302<br><a href="http://ropas.snu.ac.kr/">Programming Research Laboratory</a><br><a href="http://www.snu.ac.kr/">Seoul National University</a> <h3><a id="newest" name="copyright">Copyright</a></h3><font size="1">All Rights Reserved Under the Copyright Laws and the Contract Between the Institute of Computer Technology, Seoul National University and the Software Center, Samsung Electronics Co. </font><h3><a id="newest" name="ack">Acknowledgment</a></h3><font size="1">This work has been supported by <a href="http://www.samsung.com/">Samsung Electronics Co.(2004)</a>, <a href="/">National Creative Research Initiatives Grant (1998-2003)</a> of Korean Ministry of Science and Technology, and Brain Korea 21 (2003-2004) of Korean Ministry of Education and Human Resource Development. </font><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

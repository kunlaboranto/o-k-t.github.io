<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] Red Hat Enterprise Linux 4: 시스템 관리 안내서 (2장. 자원 모니터링)</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2007-12-11 19:57:36</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] Red Hat Enterprise Linux 4: 시스템 관리 안내서 (2장. 자원 모니터링)</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">From : http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-rhlspec.html<br><br><table summary="Header navigation table" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><th colspan="3" align="center">Red Hat Enterprise Linux 4: 시스템 관리 안내서</th></tr><tr><td align="left" valign="bottom" width="10%"><a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-what-to-monitor.html" accesskey="P">이전</a></td><td align="center" valign="bottom" width="80%">2장. 자원 모니터링</td><td align="right" valign="bottom" width="10%"><a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-addres.html" accesskey="N">다음</a></td></tr></tbody></table><hr align="left" width="100%"><div class="SECT1"><h1 class="SECT1"><a name="S1-RESOURCE-RHLSPEC"></a>2.5. Red Hat Enterprise Linux 관련 정보</h1><p>Red Hat Enterprise Linux에는 다양한 자원 모니터링 도구가 포함되어 있습니다. 다음에 설명된 도구는 일부에 불과하지만 가장 대표적인 예시입니다:</p><ul><li><p><tt class="COMMAND">free</tt></p></li><li><p><tt class="COMMAND">top</tt> (그리고 <tt class="COMMAND">top</tt>의 그래픽 버전인 <b class="APPLICATION">GNOME 시스템 감시기</b>)</p></li><li><p><tt class="COMMAND">vmstat</tt></p></li><li><p>Sysstat 자원 감시 도구 모음</p></li><li><p>OProfile 시스템 전체 성능 감시 도구</p></li></ul><p>한 도구씩 보다 상세히 설명해보겠습니다.</p><div class="SECT2"><h2 class="SECT2"><a name="S2-RESOURCE-TOOLS-FREE"></a>2.5.1. <tt class="COMMAND">free</tt></h2><p><tt class="COMMAND">free</tt> 명령은 시스템 메모리 활용 상태를 보여줍니다. 다음은 출력 결과의 예시입니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">             total       used       free     shared    buffers     cached<br>Mem:        255508     240268      15240          0       7592      86188<br>-/+ buffers/cache:     146488     109020<br>Swap:       530136      26268     503868</tt></pre></td></tr></tbody></table><p><tt class="COMPUTEROUTPUT">Mem:</tt> 줄은 물리적 메모리 활용량을 보여주며, <tt class="COMPUTEROUTPUT">Swap:</tt> 줄은 시스템 스왑 공간의 이용량을 보여줍니다. 그리고 <tt class="COMPUTEROUTPUT">-/+ buffers/cache:</tt> 줄은 현재 시스템 버퍼에 사용된 물리적 메모리 용량을 나타냅니다.</p><p><tt class="COMMAND">free</tt>는 기본적으로 메모리 활용량 정보를 한번만 보여주기 때문에 매우 짧은 모니터링이나 현재 메모리 관련 문제가 있는지 빨리 확인하는데 유용하게 사용됩니다. 비록 <tt class="COMMAND">free</tt>에 <tt class="OPTION">-s</tt> 옵션을 함께 사용하여 반복적으로 메모리 활용량 정보를 보는 것은 가능하지만, 출력 정보가 화면에서 빨리 지나가버리기 때문에 메모리 활용량의 변화를 쉽게 판독하기가 쉽지 않습니다.</p><div class="TIP"><table class="TIP" border="0" width="100%"><tbody><tr><td align="center" valign="top" width="25"><img src="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/stylesheet-images/tip.png" alt="힌트" hspace="5"></td><th align="left" valign="CENTER"><b>힌트</b></th></tr><tr><td>&nbsp;</td><td align="left" valign="top"><p><tt class="COMMAND">free</tt>를 <tt class="COMMAND">watch</tt> 명령과 함께 사용하는 것이 <tt class="COMMAND">free -s</tt> 보다 나은 해결책이 될 수 있습니다. 예를 들어 매 2초(<tt class="COMMAND">watch</tt> 명령의 기본 값)마다 메모리 활용량 정보를 보시려면 다음과 같은 명령을 입력하십시오:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMMAND">watch free</tt></pre></td></tr></tbody></table><p><tt class="COMMAND">watch</tt> 명령은 <tt class="COMMAND">free</tt> 명령을 매 2초마다 실행하면서, 이전 화면을 지우고 새 출력 결과를 동일한 화면에 업데이트합니다. <tt class="COMMAND">watch</tt> 명령은 스크롤링할 필요가 없이 업데이트된 화면으로 결과를 출력해주기 때문에 메모리 활용량 변화를 보다 쉽게 확인 가능합니다. <tt class="COMMAND">-n</tt> 옵션을 사용하여 업데이트 시간을 변경할 수 있으며, <tt class="COMMAND">-d</tt> 옵션을 사용하여 업데이트마다 변경된 사항을 강조하여 나타나게 할 수도 있습니다. 예:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMMAND">watch -n 1 -d free</tt></pre></td></tr></tbody></table><p>보다 자세한 정보는 <tt class="COMMAND">watch</tt> 맨페이지를 참조하시기 바랍니다.</p><p><tt class="COMMAND">watch</tt> 명령은 <span class="KEYCAP"><keycap>[Ctrl]</keycap></span>-<span class="KEYCAP"><keycap>[C]</keycap></span> 키를 눌러 멈출 때까지 계속 실행됩니다. <tt class="COMMAND">watch</tt>을 꼭 기억해두십시오. 많은 경우에 유용하게 사용하실 수 있습니다.</p></td></tr></tbody></table></div></div><div class="SECT2"><h2 class="SECT2"><a name="S2-RESOURCE-TOOLS-TOP"></a>2.5.2. <tt class="COMMAND">top</tt></h2><p><tt class="COMMAND">free</tt> 명령은 오직 메모리 관련 정보만 보여주는 반면, <tt class="COMMAND">top</tt> 명령은 CPU 활용량, 프로세스 상태, 메모리 활용량과 같이 거의 모든 정보를 보여줍니다. 또한 <tt class="COMMAND">free</tt> 명령과는 달리 <tt class="COMMAND">top</tt> 명령은 계속적으로 실행되도록 기본 설정되어 있습니다. 따라서 <tt class="COMMAND">watch</tt> 명령을 함께 사용할 필요가 없습니다. 다음은 출력 결과의 예시입니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT"> 14:06:32  up 4 days, 21:20,  4 users,  load average: 0.00, 0.00, 0.00<br>77 processes: 76 sleeping, 1 running, 0 zombie, 0 stopped<br>CPU states:  cpu    user    nice  system    irq  softirq  iowait    idle<br>           total   19.6%    0.0%    0.0%   0.0%     0.0%    0.0%  180.2%<br>           cpu00    0.0%    0.0%    0.0%   0.0%     0.0%    0.0%  100.0%<br>           cpu01   19.6%    0.0%    0.0%   0.0%     0.0%    0.0%   80.3%<br>Mem:  1028548k av,  716604k used,  311944k free,       0k shrd,  131056k buff<br>                    324996k actv,  108692k in_d,   13988k in_c<br>Swap: 1020116k av,    5276k used, 1014840k free                  382228k cached<br>                                                                                <br>  PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME CPU COMMAND<br>17578 root      15   0 13456  13M  9020 S    18.5  1.3  26:35   1 rhn-applet-gu<br>19154 root      20   0  1176 1176   892 R     0.9  0.1   0:00   1 top<br>    1 root      15   0   168  160   108 S     0.0  0.0   0:09   0 init<br>    2 root      RT   0     0    0     0 SW    0.0  0.0   0:00   0 migration/0<br>    3 root      RT   0     0    0     0 SW    0.0  0.0   0:00   1 migration/1<br>    4 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 keventd<br>    5 root      34  19     0    0     0 SWN   0.0  0.0   0:00   0 ksoftirqd/0<br>    6 root      35  19     0    0     0 SWN   0.0  0.0   0:00   1 ksoftirqd/1<br>    9 root      15   0     0    0     0 SW    0.0  0.0   0:07   1 bdflush<br>    7 root      15   0     0    0     0 SW    0.0  0.0   1:19   0 kswapd<br>    8 root      15   0     0    0     0 SW    0.0  0.0   0:14   1 kscand<br>   10 root      15   0     0    0     0 SW    0.0  0.0   0:03   1 kupdated<br>   11 root      25   0     0    0     0 SW    0.0  0.0   0:00   0 mdrecoveryd</tt></pre></td></tr></tbody></table><p>이예시는 두 부분으로 나뉘어져 있습니다. 윗부분에는 시스템 전체 상태와 관련된 정보 — 가동 시간, 평균 작업 부하, 프로세스계수, CPU 상태 및 메모리와 스왑 공간의 활용량 상태를 보여줍니다. 밑부분을 보시면 프로세스 수준 통계 정보가 나타납니다. <tt class="COMMAND">top</tt> 명령이 실행되는 도중에 나타나는 정보를 변경 가능합니다. 예를 들자면 <tt class="COMMAND">top</tt>은 기본적으로 휴지 상태의 프로세스와 현재 활동중인 프로세스를 모두 보여줍니다. 그러나 휴지 상태의 프로세스만 보시려면 <span class="KEYCAP"><keycap>[i]</keycap></span> 키를 누르시면 됩니다. 다시 기본 화면 모드로 돌아가기 위해서는 키를 한번 더 눌러주십시오.</p><div class="WARNING"><table class="WARNING" border="0" width="100%"><tbody><tr><td align="center" valign="top" width="25"><img src="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/stylesheet-images/warning.png" alt="경고" hspace="5"></td><th align="left" valign="CENTER"><b>경고</b></th></tr><tr><td>&nbsp;</td><td align="left" valign="top"><p><tt class="COMMAND">top</tt> 명령은 단순한 보기 프로그램처럼 보이지만 전혀 그렇지 않습니다. <tt class="COMMAND">top</tt>은 한단어를 이용하여 다양한 작업을 수행 가능합니다. 예를 들어 로그로 로그인하신 경우 시스템 상 프로세스의 우선 순위를 변경하거나 심지어는 프로세스를 삭제(kill)하는 것도 가능합니다. 따라서 <tt class="COMMAND">top</tt>의 도움말 화면을 <span class="KEYCAP"><keycap>[?]</keycap></span> 키를 이용하여 먼저 읽어보시기 바랍니다. 아직 도움말을 읽어보시지 않으셨다면 바로 <span class="KEYCAP"><keycap>[q]</keycap></span>를 입력하여 <tt class="COMMAND">top</tt>에서 빠져나오는 것이 가장 안전한 방법입니다.</p></td></tr></tbody></table></div><div class="SECT3"><h3 class="SECT3"><a name="S2-RESOURCE-TOOLS-TOP-GSM"></a>2.5.2.1. <b class="APPLICATION">GNOME 시스템 감시기</b> — <tt class="COMMAND">top</tt>의 그래픽 버전</h3><p>그래픽 사용자 인터페이스를 선호하신다면 <b class="APPLICATION">GNOME 시스템 감시기</b>가 더 마음에 드실 것입니다. <tt class="COMMAND">top</tt>과 마찬가지로 <b class="APPLICATION">GNOME 시스템 감시기</b>는 시스템 전체 상태, 프로세스 계수, 메모리 및 스왑 활용량, 프로세스 수준 상태 정보를 보여줍니다.</p><p>그러나 <b class="APPLICATION">GNOME 시스템 감시기</b>는 한단계 더 나아가서 디스크 공간 활용량을 표로 나타낼 뿐만 아니라 CPU, 메모리, 스왑 활용량을 그래픽으로 보여줍니다. <b class="APPLICATION">GNOME 시스템 감시기</b>의 <b class="GUILABEL">프로세스 목록</b> 창의 예시는 <a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-rhlspec.html#FIG-RESOURCE-G-S-M-PROC">그림 2-1</a>에서 보여줍니다.</p><div class="FIGURE"><a name="FIG-RESOURCE-G-S-M-PROC"></a><div class="MEDIAOBJECT"><p><img src="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/figs/resource/g-s-m-proc.png"></p></div><p><b>그림 2-1. <b class="APPLICATION">GNOME 시스템 감시기</b> <b class="GUILABEL">프로세스 목록</b> 창</b></p></div><p>특정 프로세스에 대한 추가 정보를 보시려면 원하는 프로세스에 먼저 클릭하신 후 <b class="GUIBUTTON">자세한 정보</b> 버튼을 클릭하시면 됩니다.</p><p>CPU, 메모리, 디스크 사용량 정보를 보시려면 <b class="GUILABEL">시스템 감시기</b> 탭을 클릭하십시오.</p></div></div><div class="SECT2"><h2 class="SECT2"><a name="S2-RESOURCE-TOOLS-VMSTAT"></a>2.5.3. <tt class="COMMAND">vmstat</tt></h2><p>시스템 성능에 대한 보다 자세한 정보를 얻고 싶다면, <tt class="COMMAND">vmstat</tt> 명령을 사용해보십시오. <tt class="COMMAND">vmstat</tt>을 사용하여 프로세스, 메모리, 스왑, 입출력, 시스템 및 CPU 활동 상황에 대한 정보를 다음과 같이 한줄로 볼 수 있습니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">procs                      memory      swap          io     system         cpu<br> r  b   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id wa<br> 0  0   5276 315000 130744 380184    1    1     2    24   14    50  1  1 47  0</tt><br>        </pre></td></tr></tbody></table><p>첫번째 줄은 프로세스, 메모리, 스왑, 입출력, 시스템 및 CPU 관련 통계인 6 부분으로 나뉘어있습니다. 두번째 줄은 각 항목을 보다 상세하게 구분하여 특정 통계에 대한 데이터를 빠르게 감시할 수 있게 해줍니다.</p><p>프로세스 관련 항목:</p><ul><li><p><tt class="COMPUTEROUTPUT">r</tt> — CPU 접근 대기 중인 실행 가능 프로세스 수</p></li><li><p><tt class="COMPUTEROUTPUT">b</tt> — 인터럽트 불가능한 수면 상태인 프로세스 수</p></li></ul><p>메모리 관련 항목:</p><ul><li><p><tt class="COMPUTEROUTPUT">swpd</tt> — 사용된 가상 메모리 용량</p></li><li><p><tt class="COMPUTEROUTPUT">free</tt> — 여유 메모리 용량</p></li><li><p><tt class="COMPUTEROUTPUT">buff</tt> — 버퍼에 사용된 메모리 용량</p></li><li><p><tt class="COMPUTEROUTPUT">cache</tt> — 페이지 캐시에 사용된 메모리 용량</p></li></ul><p>스왑 관련 항목:</p><ul><li><p><tt class="COMPUTEROUTPUT">si</tt> — 디스크에서 스왑된 메모리 용량</p></li><li><p><tt class="COMPUTEROUTPUT">so</tt> — 디스크로 스왑되어 나간 메모리 용량</p></li></ul><p>입출력 관련 항목:</p><ul><li><p><tt class="COMPUTEROUTPUT">bi</tt> — 블록 장치로 보내진 블록</p></li><li><p><tt class="COMPUTEROUTPUT">bo</tt> — 블록 장치에서 받아온 블록</p></li></ul><p>시스템 관련 항목:</p><ul><li><p><tt class="COMPUTEROUTPUT">in</tt> — 일초당 인터럽트 수</p></li><li><p><tt class="COMPUTEROUTPUT">cs</tt> — 일초당 문맥 전환 작업수</p></li></ul><p>CPU 관련 항목:</p><ul><li><p><tt class="COMPUTEROUTPUT">us</tt> — CPU가 사용자 수준 코드를 실행한 시간 (백분율 단위)</p></li><li><p><tt class="COMPUTEROUTPUT">sy</tt> — CPU가 시스템 수준 코드를 실행한 시간 (백분율 단위)</p></li><li><p><tt class="COMPUTEROUTPUT">id</tt> — CPU가 아무런 작업을 수행하지 않은 시간 (백분율)</p></li><li><p><tt class="COMPUTEROUTPUT">wa</tt> — 입출력 대기</p></li></ul><p><tt class="COMMAND">vmstat</tt> 명령을 아무런 옵션 없이 입력한 경우 한 줄만 출력됩니다. 이 줄에는 시스템이 마지막으로 부팅된 이후 평균값을 보여줍니다.</p><p>그러나 시간이 지남에 따라 정보가 변경되므로 대부분의 시스템 관리자는 한줄로 나타난 자료에 의존하지 않습니다. 대신 <tt class="COMMAND">vmstat</tt>는 정해진 간격에 자원 활용량 정보를 반복적으로 보여주는 장점이 있으며, 많은 시스템 관리자 분들은 이 점을 활용할 수 있습니다. 예를 들어 <tt class="COMMAND">vmstat 1</tt>라고 입력하면 매초마다 활용 정보를 새 줄에 표시합니다. 만일 <tt class="COMMAND">vmstat 1 10</tt>이라고 입력하시면 오직 10초 동안 매초마다 정보를 화면에 표시합니다.</p><p>숙련된 관리자라면 <tt class="COMMAND">vmstat</tt>를 사용하여 자원 활용 정보 및 성능 관련 문제점을 재빠르게 알아낼 수 있습니다. 그러나 이러한 사항에 대한 보다 자세한 정보를 알아내기 위해서는 보다 심층깊은 자료를 모으고 분석 가능한 도구가 필요합니다.</p></div><div class="SECT2"><h2 class="SECT2"><a name="S2-RESOURCE-TOOLS-SAR"></a>2.5.4. Sysstat 자원 감시 도구 모음</h2><p>앞서 설명된 도구들은 단기간 시스템 성능에 대한 정보를 확인하는데 유용하지만, 간단한 시스템 자원 활용량에 대한 정보를 제공하는것 이상의 역할을 하지는 못합니다. 시스템 성능을 감시하는데 있어서 이러한 단순한 도구로는 알아낼 수 없는 경우도 있습니다.</p><p>따라서 Sysstat과 같은 보다 정교한 도구가 필요합니다.</p><p>Sysstat의 입출력 통계와 CPU 통계 자료를 수집 도구는 다음과 같습니다:</p><div class="VARIABLELIST"><dl><dt><tt class="COMMAND">iostat</tt></dt><dd><p>한개 이상의 디스크 드라이브에 대한 입출력 통계와 함께 전체 CPU 활용량을 보여줍니다.</p></dd><dt><tt class="COMMAND">mpstat</tt></dt><dd><p>보다 상세한 CPU 활용량 정보를 보여줍니다.</p></dd></dl></div><p>Sysstat은 시스템 자원 활용 정보를 수집 후 이 자료를 바탕으로 매일 리포트를 생성하는 도구도 포함합니다. 이러한 도구는 다음과 같습니다:</p><div class="VARIABLELIST"><dl><dt><tt class="COMMAND">sadc</tt></dt><dd><p><tt class="COMMAND">sadc</tt>는 system activity data collector의 줄임말로서 시스템 자원 활용 정보를 모은 후 파일에 기록합니다.</p></dd><dt><tt class="COMMAND">sar</tt></dt><dd><p><tt class="COMMAND">sadc</tt>가 생성한 파일에서 리포트를 작성합니다. <tt class="COMMAND">sar</tt> 리포트는 상호대화식으로 생성하거나 보다 철저한 분석을 위하여 파일에 기록 가능합니다.</p></dd></dl></div><p>다음에서는 이 도구들에 대하여 보다 자세하게 설명해보겠습니다.</p><div class="SECT3"><h3 class="SECT3"><a name="S3-RESOURCE-TOOLS-SAR-IOSTAT"></a>2.5.4.1. <tt class="COMMAND">iostat</tt> 명령</h3><p>가장 기본적인 <tt class="COMMAND">iostat</tt> 명령은 CPU 및 디스크 입출력 통계에 대한 기본 정보를 보여줍니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">Linux 2.4.20-1.1931.2.231.2.10.ent (pigdog.example.com)      07/11/2003<br><br>avg-cpu:  %user   %nice    %sys   %idle<br>           6.11    2.56    2.15   89.18<br><br>Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn<br>dev3-0            1.68        15.69        22.42   31175836   44543290</tt><br>          </pre></td></tr></tbody></table><p>시스템 커널 버전, 호스트명, 날짜가 보이는 첫번째 줄 바로 아래에 <tt class="COMMAND">iostat</tt>는 마지막으로 재부팅 후 시스템 평균 CPU 활용률을 보여줍니다. CPU 활용률 정보는 다음과 같이 구분되어 백분율로 표시됩니다:</p><ul><li><p>사용자 모드 (어플리케이션 실행하기 등)에 소모된 시간 (백분율)</p></li><li><p>사용자 모드 (<tt class="COMMAND">nice(2)</tt>를 사용하여 스케쥴링 우선 순위가 바뀐 프로세스)에 소모된 시간 (백분율)</p></li><li><p>커널 모드에 소모된 시간 (백분율)</p></li><li><p>휴지 상태 시간 (백분율)</p></li></ul><p>다음에 나온 CPU 활용량 리포트는 장치 활용량 리포트입니다. 이 리포트에는 시스템 상에서 활성화된 각 디스크 장치에 대한 활용량 정보 한줄에 보여주며, 다음과 같은 정보도 포함합니다:</p><ul><li><p>장치 설명, <tt class="COMPUTEROUTPUT">dev<tt class="REPLACEABLE"><i>&lt;major-number&gt;</i></tt>-<tt class="REPLACEABLE"><i>sequence-number</i></tt></tt>라고 나타나며 여기서 <tt class="COMPUTEROUTPUT"><tt class="REPLACEABLE"><i>&lt;major-number&gt;</i></tt></tt>는 장치의 major 번호<a name="AEN1562" href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-rhlspec.html#FTN.AEN1562">[1]</a>를 의미하며, <tt class="COMPUTEROUTPUT"><tt class="REPLACEABLE"><i>&lt;sequence-number&gt;</i></tt></tt>는 0으로 시작하는 장치 순서 번호를 말합니다.</p></li><li><p>일초당 전송 (입출력 작업) 수</p></li><li><p>일초당 읽혀진 512 바이트 블록수</p></li><li><p>일초당 쓰여진 512 바이트 블록수</p></li><li><p>지금까지 읽혀진 총 512 바이트 블록수</p></li><li><p>지금까지 쓰여진 총 512 바이트 블록수</p></li></ul><p>이것은 <tt class="COMMAND">iostat</tt> 사용하여 얻을 수 있는 정보의 일부에 불과합니다. 보다 자세한 정보를 원하신다면 <tt class="COMMAND">iostat(1)</tt> 맨페이지를 참조하시기 바랍니다.</p></div><div class="SECT3"><h3 class="SECT3"><a name="S3-RESOURCE-TOOLS-SAR-MPSTAT"></a>2.5.4.2. <tt class="COMMAND">mpstat</tt> 명령</h3><p>처음 보기에 <tt class="COMMAND">mpstat</tt> 명령은 <tt class="COMMAND">iostat</tt>이 생성한 CPU 활용량 리포트와 별반 다를바가 없다고 느끼실 수도 있습니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">Linux 2.4.20-1.1931.2.231.2.10.ent (pigdog.example.com)      07/11/2003<br><br>07:09:26 PM  CPU   %user   %nice %system   %idle    intr/s<br>07:09:26 PM  all    6.40    5.84    3.29   84.47    542.47</tt><br>          </pre></td></tr></tbody></table><p>일초당 CPU에 의해 처리된 인터럽트수를 보여주는 행이 추가된 것을 제외하면, 실제로 별 차이는 없습니다. 그러나 만일 <tt class="COMMAND">mpstat</tt> 명령을 <tt class="COMMAND">-P ALL</tt> 옵션과 함께 사용하시면 다른 결과를 보실 수 있습니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">Linux 2.4.20-1.1931.2.231.2.10.ent (pigdog.example.com)      07/11/2003<br><br>07:13:03 PM  CPU   %user   %nice %system   %idle    intr/s<br>07:13:03 PM  all    6.40    5.84    3.29   84.47    542.47<br>07:13:03 PM    0    6.36    5.80    3.29   84.54    542.47<br>07:13:03 PM    1    6.43    5.87    3.29   84.40    542.47</tt><br>          </pre></td></tr></tbody></table><p><tt class="COMMAND">mpstat</tt>은 멀티프로세서 시스템에서 각 CPU에 대한 활용량 정보를 개별적으로 보여주기 때문에 각 CPU의 사용 현황을 보다 효율적으로 확인하실 수 있습니다.</p></div><div class="SECT3"><h3 class="SECT3"><a name="S3-RESOURCE-TOOLS-SAR-SADC"></a>2.5.4.3. <tt class="COMMAND">sadc</tt> 명령</h3><p>앞서 언급했듯이 <tt class="COMMAND">sadc</tt> 명령은 시스템 활용량 정보를 수집하여 향후 분석을 위해 파일에 기록합니다. 이 정보는 <tt class="FILENAME">/var/log/sa/</tt> 디렉토리에 <tt class="FILENAME">sa<tt class="REPLACEABLE"><i>&lt;dd&gt;</i></tt></tt>라는 파일명으로 저장됩니다. 여기서 <tt class="FILENAME"><tt class="REPLACEABLE"><i>&lt;dd&gt;</i></tt></tt> 부분은 파일이 생성된 날짜를 의미합니다.</p><p><tt class="COMMAND">sadc</tt>는 보통 <tt class="COMMAND">sa1</tt> 스크립트에 의해 실행됩니다. 이 스크립트는 <tt class="FILENAME">/etc/cron.d/</tt>에 위치한 <tt class="FILENAME">sysstat</tt> 파일을 통해 주기적 <tt class="COMMAND">cron</tt> 작업으로 실행됩니다. <tt class="COMMAND">sa1</tt> 스크립트는 <tt class="COMMAND">sadc</tt>를 일초간 한번 실행하지만, <tt class="COMMAND">cron</tt>은 매 10분마다 <tt class="COMMAND">sa1</tt>를 실행하도록 기본 설정되어 있습니다. 이렇게 수집된 자료는 <tt class="FILENAME">/var/log/sa/sa<tt class="REPLACEABLE"><i>&lt;dd&gt;</i></tt></tt> 파일로 저장됩니다.</p></div><div class="SECT3"><h3 class="SECT3"><a name="S3-RESOURCE-TOOLS-SAR-SAR"></a>2.5.4.4. <tt class="COMMAND">sar</tt> 명령</h3><p>그 후 <tt class="COMMAND">sar</tt> 명령은 <tt class="COMMAND">sadc</tt>에 의해 수집된 자료를 기초로 시스템 활용량 리포트를 작성합니다. Red Hat Enterprise Linux는 <tt class="COMMAND">sadc</tt>에 의해 수집된 파일을 <tt class="COMMAND">sar</tt>가 자동으로 처리하도록 설정되었습니다. 이 리포트 파일은 <tt class="FILENAME">/var/log/sa/</tt> 디렉토리에 <tt class="FILENAME">sar<tt class="REPLACEABLE"><i>&lt;dd&gt;</i></tt></tt>이라는 파일명으로 저장됩니다. 여기서 <tt class="FILENAME"><tt class="REPLACEABLE"><i>&lt;dd&gt;</i></tt></tt>는 하루전 날짜를 나타냅니다.</p><p><tt class="COMMAND">sar</tt>는 보통 <tt class="COMMAND">sa2</tt> 스크립트에 의 해 실행되며, 이 스크립트는 <tt class="FILENAME">/etc/cron.d/</tt> 디렉토리에 위치한 <tt class="FILENAME">sysstat</tt>에서 <tt class="COMMAND">cron</tt>에 의해 실행됩니다. <tt class="COMMAND">cron</tt>은 <tt class="COMMAND">sa2</tt>를 하루에 한번 23:53에 실행하여 하루 동안 수집한 자료에 대한 리포트를 작성합니다.</p><div class="SECT4"><h4 class="SECT4"><a name="S4-RESOURCE-TOOLS-SAR-READING"></a>2.5.4.4.1. <tt class="COMMAND">sar</tt> 리포트 읽기</h4><p>Red Hat Enterprise Linux의 기본 설정을 사용하여 작성된 <tt class="COMMAND">sar</tt> 리포트 형식은 여러 부분으로 나누어집니다. 각 부분은 데이터 유형에 따라 구분되어 있으며 데이터를 수집한 시간 순서대로 정렬됩니다. <tt class="COMMAND">sadc</tt>는 매 10분마다 1초간 실행되도록 설정되어 있으므로, 기본 <tt class="COMMAND">sar</tt> 리포트는 00:00부터 23:50분 사이에 매 10분마다 수집된 자료를 포함합니다<a name="AEN1663" href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-rhlspec.html#FTN.AEN1663">[2]</a>.</p><p>리포트는 각 부분에 대한 설명을 담은 제목으로 시작합니다. 페이지에 걸쳐 읽기 편하게 제목은 페이지마다 반복됩니다. 각 부분의 마지막 줄에는 그 부분에 기록된 자료의 평균값이 나타납니다.</p><p>다음은 <tt class="COMMAND">sar</tt> 리포트의 일부분 예시입니다. 공간을 아끼기 위하여 00:30 부터 23:40 사이의 자료는 생략하였습니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">00:00:01          CPU     %user     %nice   %system     %idle<br>00:10:00          all      6.39      1.96      0.66     90.98<br>00:20:01          all      1.61      3.16      1.09     94.14<br>…<br>23:50:01          all     44.07      0.02      0.77     55.14<br>Average:          all      5.80      4.99      2.87     86.34</tt><br>            </pre></td></tr></tbody></table><p>이곳에서 나타난 CPU 활용량 정보는 <tt class="COMMAND">iostat</tt> 명령의 출력 결과과 매우 유사합니다.</p><p>다른 부분에서는 시간 당 한줄 이상의 자료가 나타날 경우도 있습니다. 다음 예시에서처럼 이중 프로세서 시스템의 경우 각 CPU당 활용량 정보가 두줄로 나타납니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">00:00:01          CPU     %user     %nice   %system     %idle<br>00:10:00            0      4.19      1.75      0.70     93.37<br>00:10:00            1      8.59      2.18      0.63     88.60<br>00:20:01            0      1.87      3.21      1.14     93.78<br>00:20:01            1      1.35      3.12      1.04     94.49<br>…<br>23:50:01            0     42.84      0.03      0.80     56.33<br>23:50:01            1     45.29      0.01      0.74     53.95<br>Average:            0      6.00      5.01      2.74     86.25<br>Average:            1      5.61      4.97      2.99     86.43</tt><br>            </pre></td></tr></tbody></table><p>기본 Red Hat Enterprise Linux <tt class="COMMAND">sar</tt> 설정을 이용하여 생성된 리포트는 총 17 부분으로 나뉘어집니다. 일부 부분에 대해서는 이후 여러 장에서 성명될 것입니다. 각 부분에 속한 자료에 대한 자세한 정보를 원하신다면, <tt class="COMMAND">sar(1)</tt> 메뉴얼 페이지를 참조하시기 바랍니다.</p></div></div></div><div class="SECT2"><h2 class="SECT2"><a name="S2-RESOURCE-TOOLS-OPROFILE"></a>2.5.5. OProfile</h2><p>OProfile 시스템 전체 프로파일러는 작업 부하가 낮은 성능 감시 도구입니다. OProfile은 프로세서의 성능 감시 하드웨어<a name="AEN1691" href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-rhlspec.html#FTN.AEN1691">[3]</a>를 사용하여 성능 관련 문제점을 찾아냅니다.</p><p>성능 감시 하드웨어는 프로세서 자체의 일부로서, 어떠한 상황(예, 프로세서가 휴지 상태가 아니거나 요청된 데이터가 캐시에 없을경우)이 발생할 때마다 숫자가 하나씩 증가되는 특수 계수기(counter)입니다. 일부 프로세서에서는 이러한 계수기가 한개 이상존재하기 때문에, 여러 다른 상황에 따라 다른 계수기를 선택할 수 있게 해줍니다.</p><p>계수기는 초기값으로 로딩된 후계수기 값이 한계에 이를때(overflow)마다 인터럽트 신호를 내보냅니다. 서로 다른 초기값으로 계수기를 로딩하여 인터럽트가다른 시각에 발생하게 할 수 있습니다. 이렇게 함으로서 보다 정확한 속도 샘플을 찾을 수 있으며, 따라서 보다 상세한 정보를수집 가능해집니다.</p><p>극단적인 경우에는 매번 오버플로우 인터럽트를 발생하도록 계수기를 설정함으로서 매우 상세한 성능정보를 수집할 수 있지만, 그만큼 작업 부하가 높아집니다. 또 다른 극단적인 예로서 계수기가 인터럽트를 최소한 발생하도록설정하시면 가장 기본적인 시스템 성능 정보만 생성하게 되며, 이러한 경우 작업 부하는 거의 0에 가깝습니다. 가장 효율적인모니터링을 위해서는 원하는 자료를 충분히 수집할 수 있도록 속도를 선택하되, 성능 모니터링으로 인한 시스템 작업 부하가 너무높지 않도록 설정하셔야 합니다.</p><div class="WARNING"><table class="WARNING" border="0" width="100%"><tbody><tr><td align="center" valign="top" width="25"><img src="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/stylesheet-images/warning.png" alt="경고" hspace="5"></td><th align="left" valign="CENTER"><b>경고</b></th></tr><tr><td>&nbsp;</td><td align="left" valign="top"><p>OProfile이 높은 작업 부하를 초래하도록 설정하시면 시스템을 사용하지 못하게 될 상황이 발생할 수도 있습니다. 따라서 계수기 값은 신중하게 선택하셔야합니다. 이러한 이유로 <tt class="COMMAND">opcontrol</tt> 명령은 <tt class="COMMAND">--list-events</tt> 옵션을 지원합니다. 이 옵션을 함께 입력하시면 현재 설치된 프로세서에 사용 가능한 이벤트 유형 및 각 유형마다 최소 계수기 권장값을 보여줍니다.</p></td></tr></tbody></table></div><p>OProfile을 사용하실때는 샘플 속도와 작업 부하간의 장단점을 꼭 염두하시기 바랍니다.</p><div class="SECT3"><h3 class="SECT3"><a name="S3-RESOURCE-TOOLS-OPROFILE-COMPS"></a>2.5.5.1. OProfile 구성 요소</h3><p>OProfile은 다음과 같은 요소로 구성됩니다:</p><ul><li><p>정보 수집 소프트웨어</p></li><li><p>정보 분석 소프트웨어</p></li><li><p>관리자 인터페이스 소프트웨어</p></li></ul><p><tt class="FILENAME">oprofile.o</tt> 커널 모듈과 <tt class="COMMAND">oprofiled</tt> 데몬으로 구성된 정보 수집 소프트웨어.</p><p>다음과 같은 프로그램을 포함한 정보 분석 소프트웨어:</p><div class="VARIABLELIST"><dl><dt><tt class="COMMAND">op_time</tt></dt><dd><p>각 실행 파일에 대한 샘플수와 상대적 퍼센트 비율을 보여줌</p></dd><dt><tt class="COMMAND">oprofpp</tt></dt><dd><p>함수나 개별 명령어를 이용하여 수집한 샘플수와 상대적 퍼센트 비율을 보여주거나, <tt class="COMMAND">gprof</tt> 명령 형식의 결과로 출력함</p></dd><dt><tt class="COMMAND">op_to_source</tt></dt><dd><p>주석이 포함된 소스 코드 및 어셈블리 목록을 보여줌</p></dd><dt><tt class="COMMAND">op_visualise</tt></dt><dd><p>수집된 자료를 그래픽으로 보여줌</p></dd></dl></div><p>이러한 프로그램을 이용하여 수집된 정보를 여러가지 방식으로 보기 가능합니다.</p><p>관리자 인터페이스 소프트웨어를 이용하여 어떠한 이벤트를 모니터할 것인지부터 수집 작업의 시작에서 완료하기에 이르기까지 정보 수집에 대한 모든 측면을 설정 가능합니다. 이러한 작업에는 <tt class="COMMAND">opcontrol</tt> 명령이 사용됩니다.</p></div><div class="SECT3"><h3 class="SECT3"><a name="S3-RESOURCE-TOOLS-OPROFILE-EXAMPLE"></a>2.5.5.2. OProfile 세션 예시</h3><p>여기서는 초기 설정부터 마지막 자료 분석에 이르기까지의 OProfile 모니터링 및 자료 분석 세션을 보여줍니다. 이곳에 설명된 내용은 기본적인 소개에 불과하며, 보다 자세한 정보를 보시려면 <i class="CITETITLE">Red Hat Enterprise Linux 시스템 관리 가이드</i>를 참조하시기 바랍니다.</p><p>다음과 같이 <tt class="COMMAND">opcontrol</tt>를 사용하여 수집할 자료의 유형을 설정 가능합니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMMAND">opcontrol \<br>    --vmlinux=/boot/vmlinux-`uname -r` \<br>    --ctr0-event=CPU_CLK_UNHALTED \<br>    --ctr0-count=6000</tt></pre></td></tr></tbody></table><p>여기서 사용된 옵션은 <tt class="COMMAND">opcontrol</tt>에게 다음과 같은 사항을 지시합니다:</p><ul><li><p>OProfile에게 현재 실행 중인 커널의 복사본을 알려줌 (<tt class="COMMAND">--vmlinux=/boot/vmlinux-`uname -r`</tt>) </p></li><li><p>프로세서의 계수값을 0로 지정하고 감시할 이벤트는 CPU가 명령을 실행할 경우로 지시함 (<tt class="COMMAND">--ctr0-event=CPU_CLK_UNHALTED</tt>)</p></li><li><p>OProfile이 지정된 이벤트가 6000번째 발생할때마다 정보를 수집하도록 지시함 (<tt class="COMMAND">--ctr0-count=6000</tt>)</p></li></ul><p>다음으로 <tt class="COMMAND">lsmod</tt> 명령을 사용하여 <tt class="FILENAME">oprofile</tt> 커널 모듈이 로딩되었는지 확인해보십시오:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">Module                  Size  Used by    Not tainted<br>oprofile               75616   1<br>…</tt></pre></td></tr></tbody></table><p><tt class="COMMAND">ls /dev/oprofile/</tt> 명령을 사용하여 <tt class="FILENAME">/dev/oprofile/</tt>에 위치한 OProfile 파일 시스템이 마운트되었는지 확인합니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">0  buffer       buffer_watershed  cpu_type  enable       stats<br>1  buffer_size  cpu_buffer_size   dump      kernel_only</tt></pre></td></tr></tbody></table><p>(정확한 파일수는 프로세서 유형에 따라 다를 수 있습니다)</p><p>이제 <tt class="FILENAME">/root/.oprofile/daemonrc</tt> 파일은 정보 수집 소프트웨어를 위한 설정이 포함됩니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">CTR_EVENT[0]=CPU_CLK_UNHALTED<br>CTR_COUNT[0]=6000<br>CTR_KERNEL[0]=1<br>CTR_USER[0]=1<br>CTR_UM[0]=0<br>CTR_EVENT_VAL[0]=121<br>CTR_EVENT[1]=<br>CTR_COUNT[1]=<br>CTR_KERNEL[1]=1<br>CTR_USER[1]=1<br>CTR_UM[1]=0<br>CTR_EVENT_VAL[1]=<br>one_enabled=1<br>SEPARATE_LIB_SAMPLES=0<br>SEPARATE_KERNEL_SAMPLES=0<br>VMLINUX=/boot/vmlinux-2.4.21-1.1931.2.349.2.2.entsmp</tt></pre></td></tr></tbody></table><p>다음으로 <tt class="COMMAND">opcontrol --start</tt> 명령을 이용하여 <tt class="COMMAND">opcontrol</tt> 명령이 실제로 정보 수집을 시작하도록 지시합니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">Using log file /var/lib/oprofile/oprofiled.log<br>Daemon started.<br>Profiler running.</tt></pre></td></tr></tbody></table><p><tt class="COMMAND">ps x | grep -i oprofiled</tt> 명령을 사용하여 <tt class="COMMAND">oprofiled</tt> 데몬이 실행 중인지 확인해보십시오:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">32019 ?        S      0:00 /usr/bin/oprofiled --separate-lib-samples=0 …<br>32021 pts/0    S      0:00 grep -i oprofiled</tt></pre></td></tr></tbody></table><p>(실제 <tt class="COMMAND">ps</tt> 명령에 의해 출력된 <tt class="COMMAND">oprofiled</tt> 명령행은 이곳에 표시된 것보다 훨씬 길지만, 페이지에 맞도록 짧게 줄였습니다)</p><p>현재 시스템 상에서 실행되고 있는 모든 실행 프로세스에 대한 자료를 수집하고 있습니다. 이 자료는 <tt class="FILENAME">/var/lib/oprofile/samples/</tt> 디렉토리에 저장됩니다. 이 디렉토리에 속한 파일들은 특이한 방식의 이름을 사용합니다. 예를 들면:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">}usr}bin}less#0</tt></pre></td></tr></tbody></table><p>파일 이름은 실행 코드를 포함한 각 파일의 절대 경로에서 슬래시 (<tt class="COMPUTEROUTPUT">/</tt>)를 오른쪽 괄호 (<tt class="COMPUTEROUTPUT">}</tt>)로 바꾸고, 마지막 부분에 우물정자 (<tt class="COMPUTEROUTPUT">#</tt>)와 숫자 (이 예에서는 <tt class="COMPUTEROUTPUT">0</tt>)를 첨가합니다. 따라서 이 예시에서 사용된 파일은 <tt class="FILENAME">/usr/bin/less</tt> 파일을 실행하면서 수집된 자료를 담은 파일을 의미합니다.</p><p>일단 자료 수집을 마치면, 분석 도구를 이용하여 수집된 자료를 볼 수 있습니다. OProfile의 장점 중 하나는 자료를 수집하는동시에 자료 분석을 수행할 수 있다는 것입니다. 그러나 최소한 한세트의 샘플이 디스크에 기록될때까지 기다리셔야 합니다. 또는 <tt class="COMMAND">opcontrol --dump</tt> 명령을 이용하여 샘플을 디스크에 먼저 기록한 후 분석을 시작하셔야 합니다. </p><p>다음은 <tt class="COMMAND">op_time</tt> 명령을 이용하여 정보가 수집된 순서를 역순 (가장 높은 숫자에서 낮은 숫자 순서)로 보여줍니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="COMPUTEROUTPUT">3321080   48.8021  0.0000 /boot/vmlinux-2.4.21-1.1931.2.349.2.2.entsmp<br>761776    11.1940  0.0000 /usr/bin/oprofiled<br>368933     5.4213  0.0000 /lib/tls/libc-2.3.2.so<br>293570     4.3139  0.0000 /usr/lib/libgobject-2.0.so.0.200.2<br>205231     3.0158  0.0000 /usr/lib/libgdk-x11-2.0.so.0.200.2<br>167575     2.4625  0.0000 /usr/lib/libglib-2.0.so.0.200.2<br>123095     1.8088  0.0000 /lib/libcrypto.so.0.9.7a<br>105677     1.5529  0.0000 /usr/X11R6/bin/XFree86<br>…</tt></pre></td></tr></tbody></table><p>리포트를 상호대화식으로 생성하실때는 리포트가 몇백 줄에 걸쳐 매우 길어질 수가 있으므로 <tt class="COMMAND">less</tt> 명령을 함께 사용하시는 것이 좋습니다. 이 예시에서는 긴 리포트를 짧게 잘라서 보여주고 있습니다.</p><p>이 특정 리포트의 경우 한 줄마다 각 실행 파일에 대하여 수집한 정보를 보여줍니다. 각 줄은 다음과 같은 형식을 따르고 있습니다:</p><table class="SCREEN" bgcolor="#dcdcdc" width="100%"><tbody><tr><td><pre class="SCREEN"><tt class="REPLACEABLE"><i>&lt;sample-count&gt;</i></tt> <tt class="REPLACEABLE"><i>&lt;sample-percent&gt;</i></tt> <tt class="REPLACEABLE"><i>&lt;unused-field&gt;</i></tt> <tt class="REPLACEABLE"><i>&lt;executable-name&gt;</i></tt> </pre></td></tr></tbody></table><p>여기서:</p><ul><li><p><tt class="COMPUTEROUTPUT"><tt class="REPLACEABLE"><i>&lt;sample-count&gt;</i></tt></tt>는 수집된 샘플수를 나타냅니다.</p></li><li><p><tt class="COMPUTEROUTPUT"><tt class="REPLACEABLE"><i>&lt;sample-percent&gt;</i></tt></tt>는 이 특정 실행 파일에 대하여 수집한 모든 샘플의 퍼센트를 보여줍니다</p></li><li><p><tt class="COMPUTEROUTPUT"><tt class="REPLACEABLE"><i>&lt;unused-field&gt;</i></tt></tt>는 사용되지 않은 영역을 나타냅니다</p></li><li><p><tt class="COMPUTEROUTPUT"><tt class="REPLACEABLE"><i>&lt;executable-name&gt;</i></tt></tt>은 샘플을 수집한 실행 코드를 포함하는 파일의 이름입니다.</p></li></ul><p>이 리포트는 거의 반 이상의 샘플이 CPU가 커널 자체의 코드를 실행 중일때 수집된 것을 보여줍니다. 다음 줄에는 OProfile 자료 수집 데몬이 나타나며, 그 다음으로 다양한 라이브러리와 X 윈도우 시스템 서버, <tt class="COMMAND">XFree86</tt>를 볼 수 있습니다. 이 샘플 세션에서 실행 중이던 시스템에서 사용된 계수기 값 6000은 <tt class="COMMAND">opcontrol --list-events</tt>의 최소 권장값을 의미한다는 사실을 기억해두십시오. 즉 이 예시 시스템에서 OProfile의 작업 부하로 인한 최대 CPU 사용량이 11 퍼센트를 넘지 않는다는 것을 의미합니다.</p></div></div></div><h3 class="FOOTNOTES">주석</h3><table class="FOOTNOTES" border="0" width="100%"><tbody><tr><td align="left" valign="top" width="5%"><a name="FTN.AEN1562" href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-rhlspec.html#AEN1562">[1]</a></td><td align="left" valign="top" width="95%"><p>장치의 major 번호를 알아보시려면 <tt class="FILENAME">/dev/</tt> 디렉토리에서 원하는 장치에 <tt class="COMMAND">ls -l</tt> 명령을 입력하시면 됩니다. major 번호는 장치의 그룹 부분 다음에 나타납니다.</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="FTN.AEN1663" href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-rhlspec.html#AEN1663">[2]</a></td><td align="left" valign="top" width="95%"><p>시스템 로딩 시간에 차이가 있으므로, 실제로 자료가 수집된 시간은 1초에서 2초 정도 차이가 날 수도 있습니다.</p></td></tr><tr><td align="left" valign="top" width="5%"><a name="FTN.AEN1691" href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-rhlspec.html#AEN1691">[3]</a></td><td align="left" valign="top" width="95%"><p>성능 감시 하드웨어를 사용하지 않는 시스템 아키텍쳐의 경우 OProfile은 TIMER_INIT이라고 알려진 고장시 대체(fallback) 방식을 사용합니다.</p></td></tr></tbody></table><hr align="left" width="100%"><table summary="Footer navigation table" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" valign="top" width="33%"><a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-what-to-monitor.html" accesskey="P">이전</a></td><td align="center" valign="top" width="34%"><a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/index.html" accesskey="H">처음으로</a></td><td align="right" valign="top" width="33%"><a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-resource-addres.html" accesskey="N">다음</a></td></tr><tr><td align="left" valign="top" width="33%">무엇을 모니터링할것인가?</td><td align="center" valign="top" width="34%"><a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/ch-resource.html" accesskey="U">위로</a></td><td align="right" valign="top" width="33%">추가 자료</td></tr></tbody></table><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] Hierarchical Queries</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2008-07-25 17:12:53</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] Hierarchical Queries</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">From : http://scidb.tistory.com/tag/Connect%20By<br><br><br><img alt="" src="http://cfs.tistory.com/custom/blog/19/199499/skin/images/23.gif"><div class="article_title"><h2 class="title"><a style="" href="http://scidb.tistory.com/entry/Hierarchical-Queries">Hierarchical Queries</a></h2><div class="article_info"><span class="date">2008/06/23 21:15</span> in <a href="http://scidb.tistory.com/category/Oracle/SQL%20Pattern" class="category">Oracle/SQL Pattern</a><br><br></div></div><br><div class="clear"><img src="http://cfs.tistory.com/custom/blog/19/199499/skin/images/bg_clear.gif" alt=""></div><font face="'Dotum', 'Sans-serif'"><font size="2">Hierarchical Queries 는 Recursive Query 혹은 Tree SQL 이라고 부른다.<br>BOM, 조직도 등을 개발할때 Hierarchical Queries 는 필수이다.<br>하지만&nbsp; 이상하게도 Hierarchical Queries는 개발자들의 기피대상 1위이다.<br>Self 조인을 사용한다든지 아니면 Recursive Function 등을 사용하는 등등 어떻게든 &nbsp;Hierarchical Query 를<br>피해갈려고 애쓴다.<br>9I 및 10g 에서 Connect By Query 는 이미 피해갈수 없을 정도로 막강해졌다.<br>즉 예전과는 달리 Connect By 가 워낙 막강해져서 이젠 이기능을 모방하려면 엄청난 노가다(?) 를 해야만 할것이다.<br>여기서는 기본적인 Connect By 문법은 이야기 하지않고 &nbsp;9i , 10g 에서 추가된 문법과 수정된 Connect By 관련<br>Plan 에 대해서만 이야기 할 것이다.<br></font><br></font><font size="3" face="'Dotum', 'Sans-serif'"><strong>9i 신기능<br></strong></font><font size="2"><br><font face="'Dotum', 'Sans-serif'">Hierarchical Queries 관련하여 대표적인 미신이 2가지 있다.<br><strong>1) 조인관련 신기능</strong><br>첫번째는 조인을 할수가 없다는것이고 두번째는 조인이 포함된 뷰를 사용할수없다는 것이다.<br>이것은 8i 까지만 사실이고 9i 부터는 자유롭게 from 절을 이용하여 조인할수 있다. <br><br>SELECT&nbsp; LEVEL, <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LPAD('&nbsp; ',2*(LEVEL - 1)) || lname as ename,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A.emp_id, <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A.manager_emp_id, <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; B.name as deptname<br>FROM <strong><font color="#0000ff">employee A, department B<br></font></strong>WHERE A.dept_id = b.dept_id<br>START WITH A.emp_id = 7839<br>CONNECT BY PRIOR A.emp_id = A.manager_emp_id;<br><br>--결과<br><div class="imageblock left" style="float: left; margin-right: 10px;"><img src="http://cfs9.tistory.com/original/18/tistory/2008/06/23/20/40/485f8baed64cd" alt="사용자 삽입 이미지" width="386" height="261"></div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><strong>2) 향상된 order by<br></strong>Hierarchical Queries 의 문제는 order by 를 하면 계층구조가 깨진다는 것이다.<br>따라서 ORDER BY 를 하려면 인덱스 설계를 잘하는수 밖에 없었다. <br>하지만 9i 부터 <strong>ORDER</strong> <strong>SIBLINGS BY</strong> 절이 나오면서 그런 문제는 사라졌다.<br>다시말하면 계층구조가 다치지 않는 범위내에서 SORT 하는 기능이 추가 되었다.<br><br>SELECT LEVEL, LPAD('&nbsp; ',2*(LEVEL - 1)) || lname ename,<br>&nbsp; &nbsp; &nbsp;&nbsp; emp_id, manager_emp_id<br>FROM employee<br>START WITH manager_emp_id IS NULL<br>CONNECT BY PRIOR emp_id = manager_emp_id<br><font color="#0000ff">ORDER SIBLINGS BY</font> lname;<br><br>--결과<br><br><div class="imageblock left" style="float: left; margin-right: 10px;"><img src="http://cfs7.tistory.com/original/3/tistory/2008/06/23/20/48/485f8d7576f33" alt="사용자 삽입 이미지" width="306" height="263"></div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><strong>3) Path 나타내기</strong><br>계층구조를 한줄로 나타내는 기능이 9i 에서 추가 되었다.<br><br>SELECT <font color="#0000ff">SYS_CONNECT_BY_PATH</font>(lname, '#')<br>FROM employee<br>START WITH manager_emp_id IS NULL<br>CONNECT BY PRIOR emp_id = manager_emp_id;<br><br>--결과<br><br><div class="imageblock left" style="float: left; margin-right: 10px;"><img src="http://cfs9.tistory.com/original/22/tistory/2008/06/23/20/51/485f8e370eaa4" alt="사용자 삽입 이미지" width="227" height="263"></div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></font><strong><font size="3"><br><font face="'Dotum', 'Sans-serif'">10g 신기능</font></font></strong><br><br><font face="'Dotum', 'Sans-serif'"><strong>1) Root 노드와 Leaf 노드를 구분하는 기능</strong>이 추가되었다.<br>&nbsp;CONNECT_BY_ROOT 는 반드시 컬럼을 지정하여야 하고<br>CONNECT_BY_ISLEAF 는 여부(1 이면 Y 라는 뜻이다)이다.<br><br>SELECT lname "Employee", <br>&nbsp; &nbsp; &nbsp;&nbsp; <font color="#0000ff">CONNECT_BY_ROOT lname "Top Manager",&nbsp; <br>&nbsp; &nbsp; &nbsp;&nbsp; CONNECT_BY_ISLEAF <br></font>FROM employee<br>START WITH manager_emp_id = 7839<br>CONNECT BY PRIOR emp_id = manager_emp_id;<br><br>--결과<br><div class="imageblock left" style="float: left; margin-right: 10px;"><img src="http://cfs8.tistory.com/original/13/tistory/2008/06/23/21/00/485f906abfaa9" alt="사용자 삽입 이미지" style="cursor: pointer;" onclick="open_img('http://cfs8.tistory.com/original/13/tistory/2008/06/23/21/00/485f906abfaa9')" width="293" height="245"></div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><strong>2) CYCLE(무한루프) 방지 및 CYCLE 확인기능</strong><br>먼저 무한루프를 만들기 위하여 데이터를 수정한다.<br><br>UPDATE employee<br>SET manager_emp_id = 7654 --&gt; ROOT 노드(KING)의 매니져를 둠으로써 무한루프 발생<br>WHERE manager_emp_id IS NULL;<br><br>COMMIT;<br><br>SELECT LEVEL, LPAD('&nbsp; ',2*(LEVEL - 1)) || lname "EMPLOYEE", <br>&nbsp; &nbsp; &nbsp;&nbsp; emp_id, manager_emp_id<br>FROM employee<br>START WITH emp_id = 7839<br>CONNECT BY PRIOR emp_id = manager_emp_id;<br><br>ERROR:<br>ORA-01436: CONNECT BY loop in user data --&gt; 무한루프가 발생한다.<br><br>그럼 해결책은?<br>아래처럼 하면된다.<br>아래는 반복을 제거하고 결과를 리턴한다.<br>&nbsp;<br>SELECT LEVEL, LPAD('&nbsp; ',2*(LEVEL - 1)) || lname "EMPLOYEE", <br>&nbsp; &nbsp; &nbsp;&nbsp; </font><font face="'Dotum', 'Sans-serif'"><font color="#0000ff"><strong>CONNECT_BY_ISCYCLE,</strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <font style="background-color: rgb(255, 255, 255);" color="#000000">--&gt; CYCLE 에러의 발생지점을 알려준다.</font><br></font>&nbsp; &nbsp; &nbsp;&nbsp; emp_id, manager_emp_id<br>FROM employee<br>START WITH emp_id = 7839<br>CONNECT BY <strong><font color="#0000ff">NOCYCLE</font></strong> PRIOR emp_id = manager_emp_id; &nbsp; &nbsp;--&gt; 무한루프를 방지한다.<br><br>--결과<br><div class="imageblock left" style="float: left; margin-right: 10px;"><img src="http://cfs9.tistory.com/original/2/tistory/2008/06/23/21/09/485f925da7180" alt="사용자 삽입 이미지" width="454" height="263"></div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><strong>3) PLAN 상의 변경</strong><br>추가적으로 PLAN 에서의 변경사항을 살펴보면 <br>10.2.0.3 버젼까지 튜너들을 괴롭히던 원인을 알수없는 FULL SCAN 이 사라졌다.<br>--10.2.0.3 PLAN<br>Execution Plan<br>--------------------------------------------------------------------------------<br>&nbsp;&nbsp; 0 &nbsp; &nbsp;&nbsp; SELECT STATEMENT Optimizer=FIRST_ROWS (Cost=1 Card=2 Bytes=22)<br>&nbsp;&nbsp; 1 &nbsp;&nbsp; 0 &nbsp; CONNECT BY (WITH FILTERING)<br>&nbsp;&nbsp; 2 &nbsp;&nbsp; 1 &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'EMPLOYEE' (TABLE)<br>&nbsp;&nbsp; 3 &nbsp;&nbsp; 2 &nbsp; &nbsp; &nbsp; INDEX (UNIQUE SCAN) OF 'EMPLOYEE_PK' (INDEX (UNIQUE)) (Cost=1 Card=1 Bytes=3)<br>&nbsp;&nbsp; 4 &nbsp;&nbsp; 1 &nbsp; &nbsp; NESTED LOOPS<br>&nbsp;&nbsp; 5 &nbsp;&nbsp; 4 &nbsp; &nbsp; &nbsp; BUFFER (SORT)<br>&nbsp;&nbsp; 6 &nbsp;&nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; CONNECT BY PUMP<br>&nbsp;&nbsp; 7 &nbsp;&nbsp; 4 &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'EMPLOYEE' (TABLE) (Cost=1 Card=2 Bytes=22)<br>&nbsp;&nbsp; 8 &nbsp;&nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; INDEX (RANGE SCAN) OF 'IDX_EMPLOYEE_MGR' (INDEX) (Cost=1 Card=2)<br>&nbsp;&nbsp; 9 &nbsp;&nbsp; 1 &nbsp; &nbsp; </font><font face="'Dotum', 'Sans-serif'"><strong><font style="background-color: rgb(255, 255, 255);" color="#0000ff">TABLE ACCESS (FULL) OF 'EMPLOYEE' (TABLE) (Cost=1 Card=2 Bytes=22)<br></font></strong><br><br><br>위의 FULL SCAN(굵은글씨) 은 있을수 없는 정보(BUG)였는데 이는 10.2.0.4 에서&nbsp; PLAN 상에서 사라졌다.<br>--10.2.0.4 PLAN<br><br>Execution Plan<br>--------------------------------------------------------------------------------<br>&nbsp;&nbsp; 0 &nbsp; &nbsp;&nbsp; SELECT STATEMENT Optimizer=FIRST_ROWS (Cost=1 Card=2 Bytes=22)<br>&nbsp;&nbsp; 1 &nbsp;&nbsp; 0 &nbsp; CONNECT BY (WITH FILTERING)<br>&nbsp;&nbsp; 2 &nbsp;&nbsp; 1 &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'EMPLOYEE' (TABLE)<br>&nbsp;&nbsp; 3 &nbsp;&nbsp; 2 &nbsp; &nbsp; &nbsp; INDEX (UNIQUE SCAN) OF 'EMPLOYEE_PK' (INDEX (UNIQUE)) (Cost=1 Card=1 Bytes=3)<br>&nbsp;&nbsp; 4<span id="callbacknestscidbtistorycom218675" style="width: 1px; height: 1px; float: right;"><embed allowscriptaccess="always" id="bootstrapperscidbtistorycom218675" src="http://scidb.tistory.com/plugin/CallBack_bootstrapperSrc" wmode="transparent" type="application/x-shockwave-flash" enablecontextmenu="false" flashvars="&amp;callbackId=scidbtistorycom218675&amp;host=http://scidb.tistory.com&amp;embedCodeSrc=http%3A%2F%2Fscidb.tistory.com%2Fplugin%2FCallBack_bootstrapper%3F%26src%3Dhttp%3A%2F%2Fcfs.tistory.com%2Fblog%2Fplugins%2FCallBack%2Fcallback%26id%3D21%26callbackId%3Dscidbtistorycom218675%26destDocId%3Dcallbacknestscidbtistorycom218675%26host%3Dhttp%3A%2F%2Fscidb.tistory.com%26float%3Dleft" swliveconnect="true" width="1" height="1"></span> &nbsp;&nbsp; 1 &nbsp; &nbsp; NESTED LOOPS<br>&nbsp;&nbsp; 5 &nbsp;&nbsp; 4 &nbsp; &nbsp; &nbsp; BUFFER (SORT)<br>&nbsp;&nbsp; 6 &nbsp;&nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; CONNECT BY PUMP<br>&nbsp;&nbsp; 7 &nbsp;&nbsp; 4 &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'EMPLOYEE' (TABLE) (Cost=1 Card=2 Bytes=22)<br>&nbsp;&nbsp; 8 &nbsp;&nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; INDEX (RANGE SCAN) OF 'IDX_EMPLOYEE_MGR' (INDEX) (Cost=1 Card=2)<br><br><strong>4) 파라미터의 변화<br></strong><span style="color: blue;">_optimizer_connect_by_cost_based<font color="#000000"> 파라미터가 추가 되었다.</font></span><br>하지만 이파라미터는 버그가 보고되고 있어 사이트에서 수동으로 false 로 바꾸어 놓는 경우가 많다.<br>false 로 바꾸면 connect by 쿼리에서 조인하는 경우(&nbsp; 9i 의1) 조인관련 신기능 참조 ) FTS 로 PLAN 이 바뀌는 경향이 있으므로 주의 해야한다.<br>아례 예제를 보자.<br><br>SELECT &nbsp; LEVEL, <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LPAD('&nbsp; ',2*(LEVEL - 1)) || lname as ename,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A.emp_id, <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A.manager_emp_id, <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; B.name as deptname<br>FROM <strong>employee A, department B<br></strong>WHERE A.dept_id = b.dept_id<br>START WITH A.emp_id = 7839<br>CONNECT BY&nbsp; PRIOR A.emp_id = A.manager_emp_id;<br><br>Execution Plan : --&gt; <strong>alter session set "_optimizer_connect_by_cost_based" = true;&nbsp; 적용한 plan<br></strong>--------------------------------------------------------------------------------<br>&nbsp;&nbsp; 0 &nbsp; &nbsp;&nbsp; SELECT STATEMENT Optimizer=FIRST_ROWS (Cost=2 Card=2 Bytes=50)<br>&nbsp;&nbsp; 1 &nbsp;&nbsp; 0 &nbsp; CONNECT BY (WITH FILTERING)<br>&nbsp;&nbsp; 2 &nbsp;&nbsp; 1 &nbsp; &nbsp; NESTED LOOPS (Cost=2 Card=1 Bytes=34)<br>&nbsp;&nbsp; 3 &nbsp;&nbsp; 2 &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'EMPLOYEE' (TABLE) (Cost=1 Card=1 Bytes=22)<br>&nbsp;&nbsp; 4 &nbsp;&nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; INDEX (UNIQUE SCAN) OF 'EMPLOYEE_PK' (INDEX (UNIQUE)) (Cost=1 Card=1)<br>&nbsp;&nbsp; 5 &nbsp;&nbsp; 2 &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'DEPARTMENT' (TABLE) (Cost=1 Card=4 Bytes=48)<br>&nbsp;&nbsp; 6 &nbsp;&nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; INDEX (UNIQUE SCAN) OF 'DEPARTMENT_PK' (INDEX (UNIQUE)) (Cost=1 Card=1)<br>&nbsp;&nbsp; 7 &nbsp;&nbsp; 1 &nbsp; &nbsp; NESTED LOOPS (Cost=2 Card=2 Bytes=50)<br>&nbsp;&nbsp; 8 &nbsp;&nbsp; 7 &nbsp; &nbsp; &nbsp; NESTED LOOPS<br>&nbsp;&nbsp; 9 &nbsp;&nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; BUFFER (SORT)<br>&nbsp; 10 &nbsp;&nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CONNECT BY PUMP<br>&nbsp; 11 &nbsp;&nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'EMPLOYEE' (TABLE) (Cost=1 Card=2 Bytes=26)<br>&nbsp; 12 &nbsp; 11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX (RANGE SCAN) OF 'IDX_EMPLOYEE_MGR' (INDEX) (Cost=1 Card=2)<br>&nbsp; 13 &nbsp;&nbsp; 7 &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'DEPARTMENT' (TABLE) (Cost=1 Card=1 Bytes=12)<br>&nbsp; 14 &nbsp; 13 &nbsp; &nbsp; &nbsp; &nbsp; INDEX (UNIQUE SCAN) OF 'DEPARTMENT_PK' (INDEX (UNIQUE)) (Cost=1 Card=1)<br>&nbsp; 15 &nbsp;&nbsp; 1 &nbsp; &nbsp; MERGE JOIN (Cost=5 Card=14 Bytes=434)<br>&nbsp; 16 &nbsp; 15 &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'DEPARTMENT' (TABLE) (Cost=1 Card=4 Bytes=48)<br>&nbsp; 17 &nbsp; 16 &nbsp; &nbsp; &nbsp; &nbsp; INDEX (FULL SCAN) OF 'DEPARTMENT_PK' (INDEX (UNIQUE)) (Cost=1 Card=4)<br>&nbsp; 18 &nbsp; 15 &nbsp; &nbsp; &nbsp; SORT (JOIN) (Cost=4 Card=14 Bytes=266)<br>&nbsp; 19 &nbsp; 18 &nbsp; &nbsp; &nbsp; &nbsp; TABLE ACCESS (FULL) OF 'EMPLOYEE' (TABLE) (Cost=3 Card=14 Bytes=266)<br><br>&nbsp;<br>Execution Plan <strong>--&gt; alter session set "_optimizer_connect_by_cost_based" = false; 적용한 plan<br></strong>--------------------------------------------------------------------------------<br>&nbsp;&nbsp; 0 &nbsp; &nbsp;&nbsp; SELECT STATEMENT Optimizer=FIRST_ROWS (Cost=3 Card=1 Bytes=25)<br>&nbsp;&nbsp; 1 &nbsp;&nbsp; 0 &nbsp; CONNECT BY (WITH FILTERING)<br>&nbsp;&nbsp; 2 &nbsp;&nbsp; 1 &nbsp; &nbsp; FILTER<br>&nbsp;&nbsp; 3 &nbsp;&nbsp; 2 &nbsp; &nbsp; &nbsp; COUNT<br>&nbsp;&nbsp; 4 &nbsp;&nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; NESTED LOOPS (Cost=3 Card=1 Bytes=25)<br>&nbsp;&nbsp; 5 &nbsp;&nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong> TABLE ACCESS (FULL) OF 'EMPLOYEE' (TABLE) (Cost=2 Card=1 Bytes=13)<br></strong>&nbsp;&nbsp; 6 &nbsp;&nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'DEPARTMENT' (TABLE) (Cost=1 Card=1 Bytes=12)<br>&nbsp;&nbsp; 7 &nbsp;&nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX (UNIQUE SCAN) OF 'DEPARTMENT_PK' (INDEX (UNIQUE)) (Cost=1 Card=1)<br>&nbsp;&nbsp; 8 &nbsp;&nbsp; 1 &nbsp; &nbsp; HASH JOIN<br>&nbsp;&nbsp; 9 &nbsp;&nbsp; 8 &nbsp; &nbsp; &nbsp; CONNECT BY PUMP<br>&nbsp; 10 &nbsp;&nbsp; 8 &nbsp; &nbsp; &nbsp; COUNT<br>&nbsp; 11 &nbsp; 10 &nbsp; &nbsp; &nbsp; &nbsp; NESTED LOOPS (Cost=3 Card=1 Bytes=25)<br>&nbsp; 12 &nbsp; 11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>TABLE ACCESS (FULL) OF 'EMPLOYEE' (TABLE) (Cost=2 Card=1 Bytes=13)<br></strong>&nbsp; 13 &nbsp; 11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'DEPARTMENT' (TABLE) (Cost=1 Card=1 Bytes=12)<br>&nbsp; 14 &nbsp; 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX (UNIQUE SCAN) OF 'DEPARTMENT_PK' (INDEX (UNIQUE)) (Cost=1 Card=1)<br>&nbsp; 15 &nbsp;&nbsp; 1 &nbsp; &nbsp; COUNT<br>&nbsp; 16 &nbsp; 15 &nbsp; &nbsp; &nbsp; NESTED LOOPS (Cost=3 Card=1 Bytes=25)<br>&nbsp; 17 &nbsp; 16 &nbsp; &nbsp; &nbsp; &nbsp; TABLE ACCESS (FULL) OF 'EMPLOYEE' (TABLE) (Cost=2 Card=1 Bytes=13)<br>&nbsp; 18 &nbsp; 16 &nbsp; &nbsp; &nbsp; &nbsp; TABLE ACCESS (BY INDEX ROWID) OF 'DEPARTMENT' (TABLE) (Cost=1 Card=1 Bytes=12)<br>&nbsp; 19 &nbsp; 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX (UNIQUE SCAN) OF 'DEPARTMENT_PK' (INDEX (UNIQUE)) (Cost=1 Card=1)<br><br><strong>결론:</strong><br>Hierarchical Queries는 조직도나 tree 구조의 BOM 업무의 거의 모든 기능을 커버한다.<br>위의 문법은 아주 기초적인 것들이니 반드시 이해하고 업무에 활용하기 바란다.</font></font><fieldset style="margin: 20px 0px; padding: 5px;"><legend><span><strong>크리에이티브 커먼즈 라이선스</strong></span></legend><!--Creative Commons License--><div style="float: left; width: 88px; margin-top: 3px;"><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/kr/" target="_blank"><img alt="Creative Commons License" style="border-width: 0pt;" src="http://i.creativecommons.org/l/by-nc-sa/2.0/kr/88x31.png"></a></div><div style="margin-left: 92px; margin-top: 3px; text-align: justify;">이 저작물은 <a style="" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/kr/" target="_blank">크리에이티브 커먼즈 코리아 저작자표시-비영리-동일조건변경허락 2.0 대한민국 라이선스</a>에 따라 이용하실 수 있습니다.</div></fieldset><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

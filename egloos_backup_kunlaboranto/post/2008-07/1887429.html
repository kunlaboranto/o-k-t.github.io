<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] [SunOS] A Comparison of Memory Allocators in Multiprocessors</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2008-07-22 03:26:43</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] [SunOS] A Comparison of Memory Allocators in Multiprocessors</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">From : http://developers.sun.com/solaris/articles/multiproc/multiproc.html<br><br><div class="pagetitle2">Article</div><div id="sharepage" class="smallpagetitle"><h1>A Comparison of Memory Allocators in Multiprocessors</h1><div class="sharepage"><div class="sharepagew1 share-mailto"><table summary="layout" cellpadding="0" cellspacing="0"><tbody><tr><td id="share-mailto"><br></td><td id="share-technorati"><br></td><td id="share-delicious"><br></td><td id="share-digg"><br></td><td id="share-slashdot"><br></td><td id="share-blank"> <br></td></tr></tbody></table></div></div></div><!-- END PAGETITLE --><!-- BEGIN WRAPPER TABLE, 2 COLUMN, MAIN/RIGHT --><!-- BEGIN CENTRAL COLUMN COMPONENTS --><!--startindex--><!-- ============ --><!-- MAIN CONTENT --><!-- ============ --><a name="skip2content"></a><!--  BEGIN VCD4 PFV  --><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="smaller" valign="top"><em></em><br></td><td width="10">&nbsp;</td><td align="right" valign="bottom"><div class="sitelinks" style="padding: 0px;"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td align="right" valign="bottom">&nbsp;</td><td class="smaller" valign="bottom" nowrap="nowrap"><a href="http://developers.sun.com/jsp_utils/PrintPage.jsp" target="printFriendlyView" onclick="openPopup('','printFriendlyView',710,650,'no',1,1,0,0,0,0); return true;"><img src="http://developers.sun.com/im/ic_print.gif" alt="Print-friendly Version" border="0" width="14" height="12" hspace="4">Print-friendly Version</a><br></td></tr></tbody></table></div></td></tr></tbody></table><!--  END VCD4 PFV --><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="smaller" valign="top"><em>By <a href="http://developers.sun.com/solaris/articles/multiproc/multiproc.html#author">Joseph Attardi and Neelakanth Nadgir</a>, June 2003</em></td><td width="10">&nbsp;</td><td align="right" valign="bottom"><div class="sitelinks" style="padding: 0px;"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><!--<td valign="bottom" align="right"><img src="/im/ic_email.gif" width="14" height="12" border="0" hspace="4" vspace="1" alt=" " /></td><td valign="bottom" class="smaller" nowrap="nowrap"><a href="#{link placeholder}">E-mail</a></td><td>&nbsp;&nbsp;</td><td valign="bottom" align="right">&nbsp;</td><td valign="bottom" class="smaller" nowrap="nowrap"><a href="/jsp_utils/PrintPage.jsp" target="printFriendlyView" onclick="openPopup('','printFriendlyView',710,650,'no',1,1,0,0,0,0); return true;"><img src="/im/ic_print.gif" width="14" height="12" alt="Print-friendly Version" border="0" hspace="4" />Print-friendly Version</a></td><td>&nbsp;&nbsp;</td><td valign="bottom" align="right"><img src="/im/ic_download_thin.gif" width="9" height="14" hspace="4" border="0" alt=" " /></td><td valign="bottom" class="smaller" nowrap="nowrap"><a href="#{link placeholder}">Download</a></td>--></tr></tbody></table></div><br></td></tr></tbody></table><div class="contentdivider"><table class="grey4" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img src="http://developers.sun.com/im/a.gif" alt=" " border="0" width="1" height="4"></td></tr></tbody></table></div><!--  END VCD4 BYLINE AND TOOLS  --><p>Memory allocation performance in single and multithreaded environmentsis an important aspect of any application. Some allocators, such as <code>malloc</code>in the Solaris Operating System, work best with single-threadedapplications. However, a different approach must be taken whendesigning an allocator optimized for a multithreaded application.</p><p>Using a single-threaded <code>malloc</code> in a multithreadedapplication can degrade performance. As memory is being allocatedconcurrently in multiple threads, all the threads must wait in a queuewhile <code>malloc()</code> handles one request at a time. With a fewextra threads, this can slow down performance, causing a problem knownas heap contention. In other words, all the threads are competing foraccess to the same heap.</p><p>One indication of heap contention is that the application is making a considerably high number of calls to <code>malloc()</code>. To see these kinds of calls, use an application profiler or the Solaris OS <code>apptrace</code> command.</p><p>System library implementers take various approaches to alleviate the bottleneck of a singly threaded <code>malloc()</code>.One solution to this problem is to use multiple heaps. Here the term"heap" refers to blocks of memory that a process can allocate or freeat run time. A heap is private to the process it is in. In other words,heap memory is the memory that is allocated or deallocated with callsto <code>malloc()</code> and <code>free()</code>.</p><p>When there are multiple heaps, the threads do not need to wait for aheap's lock; instead each thread can use the one allocated to the CPUit is running on. Some modern memory allocators take this intoconsideration, and yield much greater performance with multithreadedcode than a traditional allocator. Even better performance can beyielded with these modern allocators by using them on a multiprocessorsystem.</p><p>A faster, multi-heap memory allocator can be implemented whilehiding the intricacies of the underlying memory operations withmultiple heaps. Whatever the implementation, access to the heap(s) ishandled by calls to <code>malloc()</code> and <code>free()</code> (in C), or <code>new</code> and <code>delete</code>(in C++). This makes it easy to switch memory allocators without muchchange to your program. These faster allocators can then be implementedinto shared libraries that can be linked at runtime. The developer needonly replace or override the library load path. However, for bestperformance, developers want to understand the underlyingimplementation of various allocators so they can choose the bestimplementation for their applications.</p><p>This article summarizes some performance tests that were run on various memory allocators. The allocators tested were Solaris <code>malloc</code>, Solaris <code>mtmalloc</code>, <code>ptmalloc</code>, <code>Hoard</code>, and <code>libumem</code>. <code>malloc</code> is the default memory allocator in the Solaris OS. Similarly, Solaris <code>mtmalloc</code> is a general-purpose allocator that is used with multithreaded applications. <code>ptmalloc</code> is the standard allocator used in the GNU <code>libc</code> library. <code>Hoard</code> is a fast, memory-efficient allocator that utilizes multiple processors. <code>libumem</code> is a port of the kernel memory allocator to the user level. </p><h4>The Tests</h4><p>Two test programs were run on these allocators. The first is <code>ThreadTest</code>, which is a program that comes with <code>Hoard</code>. <code>ThreadTest</code>generates one or more threads that allocate and free a large number ofchunks of memory, all of the same size. It then repeats this processover a fixed number of iterations. The other is <code>mtmalloctest</code>, written by Greg Nakhimovsky. <code>mtmalloctest</code>allocates and frees blocks of memory, of varying size. It then repeatsthe process, also over another fixed number of iterations.</p><p>It should be noted that these tests do not represent typicalallocation patterns. They are worst-case stress tests that rapidlyallocate and deallocate large chunks of memory. Therefore, keep in mindthat these numbers represent worst-case performance. Performance inreal-world applications varies with how those applications allocatememory.</p><p>These tests were run on a Sun Fire 4800 machine, with 12 750-MHzUltraSPARC III processors and 24 GB of RAM, running on the Solaris 9OS. The tests were built using the Sun ONE Studio Compiler Collection.The libraries were linked in various ways, using a combination ofstatic linking and <code>LD_PRELOAD</code>.Several trials were run for each allocator, each for a different numberof threads: 1, 2, 4, 6, 8, and 10. The results presented here are theaverage of all the runs. Two things were measured in these tests:First, the execution time was recorded. In these tests a shorterexecution time indicates faster performance. Second, the amount of heapusage was recorded. With the heap tests, a smaller heap usage indicatesless wasted memory and thus better efficiency. What follows is theresults of some of these tests, and conclusions we can draw from them.See the Analysis section for more explanation of these results.</p><p><b><code>ThreadTest</code> Average Time</b><br>Clearly, the slowest performer here is <code>malloc</code>on the Solaris OS. A smaller execution time means faster performance,and therefore represents a better result. All the other allocators getfaster as more threads are added, with Solaris <code>mtmalloc</code> and <code>Hoard</code> winning neck-in-neck. </p><table align="center" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td align="center"><img src="http://developers.sun.com/solaris/articles/multiproc/images/threadtest-time.gif" alt="ThreadTest Performance by Number of Threads" border="0" width="435" height="330"><br><br><span class="rtbtitle">Figure 1: ThreadTest Performance by Number of Threads</span></td></tr></tbody></table><p><b><code>mtmalloctest</code> Average Time</b><br>Again, <code>malloc</code> on the Solaris OS slows down more and more as the number of threads increases. Just as with the <code>ThreadTest</code> graph, a shorter execution time is better. The other allocators remain near constant, performing very well.</p><table align="center" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td align="center"><img src="http://developers.sun.com/solaris/articles/multiproc/images/mtmalloctest-time.gif" alt="mtmalloctest Performance by Number of Threads" border="0" width="425" height="324"><br><br><span class="rtbtitle">Figure 2: mtmalloctest Performance by Number of Threads</span></td></tr></tbody></table><p><b><code>ThreadTest</code> Heap Usage</b><br><code>libumem</code> uses the greatest amount of heap memory, as shownin the following figure. With the heap tests, a smaller number isbetter. The others follow about the same pattern, except for <code>ptmalloc</code>, which has very low numbers. See the <a href="http://developers.sun.com/solaris/articles/multiproc/multiproc.html#analysis">Analysis</a> section for more explanation.</p><table align="center" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td align="center"><img src="http://developers.sun.com/solaris/articles/multiproc/images/threadtest-heap.gif" alt="ThreadTest Heap Usage by Number of Threads" border="0" width="425" height="345"><br><br><span class="rtbtitle">Figure 3: ThreadTest Heap Usage by Number of Threads</span></td></tr></tbody></table><p><b><code>mtmalloctest</code> Heap Usage</b><br>Again, in this instance, smaller heap usage is better. In the trials of <code>mtmalloctest</code>, we see greatly increased heap usage by <code>mtmalloc</code> as more memory is allocated.</p><p>Once again, heap usage for <code>ptmalloc</code> is very low, barely showing up at all on the graph. See the <a href="http://developers.sun.com/solaris/articles/multiproc/multiproc.html#analysis">Analysis</a> section for further explanation on heap usage for <code>ptmalloc</code>.</p><table align="center" border="0" cellpadding="10" cellspacing="0"><tbody><tr><td align="center"><img src="http://developers.sun.com/solaris/articles/multiproc/images/mtmalloctest-heap.gif" alt="mtmalloctest Heap Usage by Number of Threads" border="0" width="430" height="344"><br><br><span class="rtbtitle">Figure 4: mtmalloctest Heap Usage by Number of Threads</span></td></tr></tbody></table><a name="analysis"></a><h4>Analysis</h4><p><b>Runtime Performance</b><br><code>malloc</code> on the Solaris OS performs well only insingle-threaded applications. Its performance is unsuitable formultithreaded applications, because its performance worsens as threadsare added. This is due to the fact that <code>malloc</code> maintainsa single heap, and thus only one thread can allocate/deallocate memoryat any given time. Therefore, with the addition of more threads, wefind more threads waiting, and the wait time grows longer, resulting inincreasingly slow execution times.</p><p><code>mtmalloc</code> and Hoard are extremely close, both giving very fast multithreaded performance. All of the allocators (except for Solaris <code>malloc</code>)showed performance gains with more threads, but these two had the bestperformance at all thread levels. This is an improvement over the <code>mtmalloc</code> that was included with the Solaris 8 Operating System. In previous tests, Sun engineers found that <code>mtmalloc</code> in the Solaris 8 OS did speed up as more threads were added, but did not scale as well as <code>Hoard</code> or <code>ptmalloc</code>. <code>mtmalloc</code> in the Solaris 9 OS has closed that gap, performing even slightly faster than <code>Hoard</code> in our <code>ThreadTest</code> test.</p><p><b>Heap Usage</b><br>When an application executes, the operating system creates a virtualaddress space for the new process. This address space contains itemssuch as the stack, the application's code, data, and the heap. The heapis where dynamic memory allocation occurs, as discussed in thisdocument. Various system calls are used to manage a process's heap. The<code>brk()</code> and <code>sbrk()</code>system calls can be used to resize a process's data segment toaccommodate requests for more memory allocations. See the manual pagefor <code>brk()</code> and <code>sbrk()</code> for more details.</p><p><code>malloc</code> on the Solaris OS is slow because only one threadmay allocate or deallocate memory at any given time. However, sinceonly one memory operation is going on at a time, the overall heap usageis low. While low heap usage is good, the slow performance of <code>malloc</code> in multithreaded applications still should not justify using it in such applications.</p><p><code>ptmalloc</code> has the lowest reported heap usage. The allocation scheme for <code>ptmalloc</code>is different than for the others we tested, allocating memory inanonymous pages. An anonymous page is a page that is not associatedwith a particular <code>vnode</code>, or file/directory. The programused in these tests to measure the heap size did not take anonymouspages into account, and therefore <code>ptmalloc</code>'s heap usage numbers appear lower than they really are.</p><p>Heap usage for <code>Hoard</code> and <code>libumem</code> is in the middle, and does fairly well.</p><p>Heap usage for Solaris <code>mtmalloc</code> was much higher than the others, especially in <code>mtmalloctest</code>. This is most likely because <code>mtmalloc</code>is a power of two allocator, that is, it rounds the size of requestedblocks up to the next power of two. For example, if a request is madeto allocate 17 bytes, the actual size of the allocated block would berounded up to 32 bytes. As these requests add up, it can lead tointernal fragmentation, so that the "extra" memory that is allocated iswasted.</p><h2>Conclusions</h2><p>So, which allocator should you use in your application? <code>malloc</code>on the Solaris OS was shown to be a strong choice for single-threadedcode. However, for better performance and scalability, you should tryto multithread the application. Multithreaded code can improveperformance and scalability on a multiprocessor system using amultithreaded memory allocator. For multithreaded code, you should useSolaris <code>mtmalloc</code> or <code>Hoard</code>. As shown in this document, both options yielded close results. If heap usage is a concern, use <code>Hoard</code>, since <code>mtmalloc</code>wastes some space by using fixed power of two allocation sizes.Otherwise, either of these will perform well for your application.</p><p>Keep in mind that these conclusions apply to applications running onsystems with multiple processors. Uniprocessor systems were not testedin these benchmarks, and may show different results for theseallocators.</p><h4>Resources</h4><ul><li><a href="http://www.hoard.org/" target="_blank"><code>Hoard</code> home page</a></li><li><a href="ftp://ftp.cs.utexas.edu/pub/emery/papers/asplos2000.pdf" target="_blank">Hoard:A Scalable Memory Allocator for Multithreaded Applications (paper byEmery D. Berger, Kathryn S. McKinley, Robert D. Blumofe, and Paul R.Wilson)</a></li><li><a href="http://www.malloc.de/en/" target="_blank">Wolfram Gloger's malloc homepage (home of ptmalloc)</a></li><li><a href="http://docs.sun.com/" target="_blank">Sun Product Documentation</a></li><li><a href="http://docs.sun.com/?q=malloc&amp;p=/doc/816-0213/6m6ne385r&amp;a=view" target="_blank">Solaris 9 Reference Manual Collection man pages for malloc</a></li><li><a href="http://docs.sun.com/?q=malloc&amp;p=/doc/816-0213/6m6ne386t&amp;a=view" target="_blank">Solaris 9 Reference Manual man pages for mtmalloc</a></li></ul><a name="author"></a><h4>About the Authors</h4><br><p>Neelakanth Nadgir is a software engineer in Sun's Market DevelopmentEngineering organization. He works with tool vendors to develop "bestof breed" applications on Sun systems. He also volunteers for the GNUproject. In his spare time, he likes to go hiking in Big Basin StatePark.</p><p>Joe Attardi is an intern at Sun Microsystems in Burlington,Massachusetts. He is currently in his senior year at the University ofMassachusetts at Lowell.</p><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>

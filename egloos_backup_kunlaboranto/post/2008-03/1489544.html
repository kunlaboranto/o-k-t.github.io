<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[펌] [바람이] Mysql InnoDB - DoubleWrite</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">kun</strong> 님 (<strong class="name">okseop7</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2008-03-05 20:24:00</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[펌] [바람이] Mysql InnoDB - DoubleWrite</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">From : http://hackereyes.tistory.com/entry/%EB%B0%94%EB%9E%8C%EC%9D%B4-Mysql-InnoDB-DoubleWrite<br><br><div class="titleWrap"><h2><a style="" href="http://hackereyes.tistory.com/entry/%EB%B0%94%EB%9E%8C%EC%9D%B4-Mysql-InnoDB-DoubleWrite">[바람이] Mysql InnoDB - DoubleWrite</a></h2><span class="category"><a href="http://hackereyes.tistory.com/category/%EB%8F%84%EC%84%9C%EA%B4%80%20I/Database">도서관 I/Database</a> </span><span class="date">2007/08/07 16:42<br><br></span><p><code class="literal"><font face="굴림체">InnoDB</font></code> uses simulated asynchronous disk I/O: <code class="literal"><font face="굴림체">InnoDB</font></code> creates a number of threads to take care of I/O operations, such as read-ahead. </p><p>There are two read-ahead heuristics in <code class="literal"><font face="굴림체">InnoDB</font></code>: </p><div class="itemizedlist"><ul type="disc"><li><p>In sequential read-ahead, if <code class="literal"><font face="굴림체">InnoDB</font></code>notices that the access pattern to a segment in the tablespace issequential, it posts in advance a batch of reads of database pages tothe I/O system. </p></li><li><p>In random read-ahead, if <code class="literal"><font face="굴림체">InnoDB</font></code>notices that some area in a tablespace seems to be in the process ofbeing fully read into the buffer pool, it posts the remaining reads tothe I/O system. </p></li></ul></div><p><code class="literal"><font face="굴림체">InnoDB</font></code> uses a novel file flush technique called <em class="firstterm">doublewrite</em>.It adds safety to recovery following an operating system crash or apower outage, and improves performance on most varieties of Unix byreducing the need for <code class="literal"><font face="굴림체">fsync()</font></code> operations. </p><p>Doublewrite means that before writing pages to a data file, <code class="literal"><font face="굴림체">InnoDB</font></code>first writes them to a contiguous tablespace area called thedoublewrite buffer. Only after the write and the flush to thedoublewrite buffer has completed does <code class="literal"><font face="굴림체">InnoDB</font></code> write the pages to their proper positions in the data file. If the operating system crashes in the middle of a page write, <code class="literal"><font face="굴림체">InnoDB</font></code> can later find a good copy of the page from the doublewrite buffer during recovery. <br><br>원문 : <a href="http://www.mysqlkorea.co.kr/sub.html?mcode=develop&amp;scode=01&amp;m_no=20752&amp;cat1=14&amp;cat2=422&amp;cat3=448&amp;lang=e">http://www.mysqlkorea.co.kr/sub.html?mcode=develop&amp;scode=01&amp;m_no=20752&amp;cat1=14&amp;cat2=422&amp;cat3=448&amp;lang=e</a><br><br>InnoDB의 버퍼를 공부하다 보니 DoubleWrite Buffer에 대해서 나오길래 찾다가 MySql 홈페이지에서 찾았다.<br><br></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">는 시뮬레이티드 비동기<span lang="EN"> (simulated asynchronous) </span>디스크<span lang="EN"> I/O</span>를 사용한다<span lang="EN">: </span></span><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">는 읽기<span lang="EN">-</span>위주<span lang="EN"> (read-ahead)</span>와 같은<span lang="EN"> I/O </span>연산을 잘 처리하기 위해 수많은 쓰레드를 생성한다<span lang="EN">. </span></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><span style="font-size: 9pt; font-family: 굴림;"><span lang="EN"><o:p></o:p></span></span>&nbsp;</p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">에는 두 가지의 읽기<span lang="EN">-</span>위주 방법이 존재한다<span lang="EN">: <o:p></o:p></span></span></p><ul type="disc"><li class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;"><span style="font-size: 9pt; font-family: 굴림;">시퀀셜 읽기<span lang="EN">-</span>위주의 경우<span lang="EN">, </span></span><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">가 테이블스페이스에 있는 세그먼트에 대한 접속 패턴이 시퀀셜이라는 것을 인지한다면<span lang="EN">, </span>앞에 존재하는 데이터베이스 페이지의 읽기 배치 연산을<span lang="EN"> I/O</span>시스템에 보낸다<span lang="EN">. <o:p></o:p></span></span></li><li class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;"><span style="font-size: 9pt; font-family: 굴림;">무작위 읽기<span lang="EN">-</span>위주의 경우<span lang="EN">, </span>만일 </span><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">가 테이블스페이스의 어떤 부분이 버퍼 풀 안으로 전체적인 읽기를 진행하는 것처럼 인지한다면<span lang="EN">, </span>나머지 읽기 연산을<span lang="EN"> I/O </span>시스템에 보낸다<span lang="EN">. <o:p></o:p></span></span></li></ul><p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">는<i><span lang="EN">doublewrite</span></i>라고 불리우는 기발한 파일 플러시 기법<span lang="EN"> (novel file flush technique)</span>을 사용한다<span lang="EN">. </span>이 기법은<span lang="EN"> OS </span>크래시 또는 전원 문제 이후의 복구 연산을 보다 안전하게 하도록 하며<span lang="EN">, </span></span><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">fsync()</span></b><span style="font-size: 9pt; font-family: 굴림;" lang="EN"> </span><span style="font-size: 9pt; font-family: 굴림;">연산에 대한 필요성을 절감시킴으로써 다양한 유닉스 버전의 성능을<span id="callbacknesthackereyestistorycom2222874" style="width: 1px; height: 1px; float: right;"><embed allowscriptaccess="always" id="bootstrapperhackereyestistorycom2222874" src="http://hackereyes.tistory.com/plugin/CallBack_bootstrapperSrc" wmode="transparent" type="application/x-shockwave-flash" enablecontextmenu="false" flashvars="&amp;callbackId=hackereyestistorycom2222874&amp;host=http://hackereyes.tistory.com&amp;embedCodeSrc=http%3A%2F%2Fhackereyes.tistory.com%2Fplugin%2FCallBack_bootstrapper%3F%26src%3Dhttp%3A%2F%2Fcfs.tistory.com%2Fblog%2Fplugins%2FCallBack%2Fcallback%26id%3D222%26callbackId%3Dhackereyestistorycom2222874%26destDocId%3Dcallbacknesthackereyestistorycom2222874%26host%3Dhttp%3A%2F%2Fhackereyes.tistory.com%26float%3Dleft" swliveconnect="true" height="1" width="1"></span> 향상시켜준다<span lang="EN">. </span></span></p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><span style="font-size: 9pt; font-family: 굴림;"><span lang="EN"><o:p></o:p></span></span>&nbsp;</p><p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><span style="font-size: 9pt; font-family: 굴림;">이중 쓰기란<span lang="EN">, </span>데이터 파일에 페이지를 쓰기 전에<span lang="EN">, </span></span><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">는 우선 페이지를 이중 쓰기 버퍼라고 불리우는 인접한 테이블스페이스에 기록한다는 것을 의미한다<span lang="EN">. </span>이중 쓰기 버퍼에 기록을 하고 이것을 플러시한 후에야 </span><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">는 그 페이지를 데이터 파일의 적당한 위치에 기록을 하게 된다<span lang="EN">. </span>만일<span lang="EN"> OS</span>가 페이지 쓰기 중간에 크래시 된다면<span lang="EN">, </span></span><b><span style="font-size: 9pt; color: rgb(2, 103, 137); font-family: 굴림;" lang="EN">InnoDB</span></b><span style="font-size: 9pt; font-family: 굴림;">는 나중을 복구를 할 때 이중 쓰기 버퍼에서 제대로 된 페이지를 찾을 수가 있게 된다<span lang="EN">. <o:p></o:p></span></span></p><p><br><br>이는 한글 메뉴얼 site에서 번역본을 찾은 것이며, 조금 번역이 잘못된 것을 고쳐 보았다.<br><br><br>다음은 조금 이해하기 어려운 용어를 정리해 보았다. 도움이 되길...<br><br>* 읽기-위주 (read-ahead)<br>&nbsp; - 딱히 번역할 말을 나도 찾지 못하겠다. 쩌비. <br>&nbsp;&nbsp; 우선, read-ahead란 일반적으로 데이터는 연속된 공간에 순차적으로 저장되어지는 점(locality)을 모태로 읽기연산이 발행하면, 특정한 몇몇 페이지(단지 읽기의 단위를 표현하고 싶었다.)를 미리 같이 읽어 버리는 기법을 말한다. 즉,여기에서는 버퍼에 7번 페이지를 읽어달라고 요청이 오면, 8번 페이지도 곧 읽기 요청이 올것이라고 예상하고, 미리 7번 8번페이지를 같이 읽어들이는 기법을 말한다. <br>&nbsp; &nbsp; 이는, 8번이 될 수도 있고, 8~n번 페이지를 모두 동시에 읽을 수도 있으며, 이는 여러 알고리즘 기법에 따라 다르다.<br>&nbsp; &nbsp; 그리고, 꼭 8번이 되지 않을 수도 있으며, 임의(random)의 한 페이지을 미리 읽는 기법도 있으니, 참고하기 바란다. (위에 보니 나와있다... 헐... 미리 다 읽고 써야겠다.)</p><fieldset style="margin: 20px 0px; padding: 5px;"><legend><span><strong>크리에이티브 커먼즈 라이센스</strong></span></legend><!--Creative Commons License--><div style="float: left; width: 88px; margin-top: 3px;"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/" target="_blank"><img alt="Creative Commons License" style="border-width: 0pt;" src="http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a></div><div style="margin-left: 92px; margin-top: 3px; text-align: justify;">이 저작물은 <a style="" rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/" target="_blank">크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이센스</a>에 따라 이용하실 수 있습니다.</div></fieldset><br></div><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>
